{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/use-analytics.ts"],"sourcesContent":["\"use client\";\n\nimport { useCallback } from \"react\";\n\ninterface AnalyticsEvent {\n  event: string;\n  properties?: Record<string, unknown>;\n  timestamp?: number;\n}\n\ninterface NavigationEvent extends AnalyticsEvent {\n  event: \"navigation\";\n  properties: {\n    from: string;\n    to: string;\n    method: \"click\" | \"keyboard\" | \"programmatic\";\n  };\n}\n\ninterface ButtonClickEvent extends AnalyticsEvent {\n  event: \"button_click\";\n  properties: {\n    button: string;\n    location: string;\n    action: string;\n  };\n}\n\ninterface CustomEvent extends AnalyticsEvent {\n  event: string;\n  properties?: Record<string, unknown>;\n}\n\ntype TrackableEvent = NavigationEvent | ButtonClickEvent | CustomEvent;\n\n// Type definitions for analytics services\ninterface GoogleAnalytics {\n  gtag: (command: string, eventName: string, parameters?: Record<string, unknown>) => void;\n}\n\ninterface Mixpanel {\n  track: (eventName: string, properties?: Record<string, unknown>) => void;\n}\n\ninterface WindowWithAnalytics extends Window {\n  gtag?: GoogleAnalytics['gtag'];\n  mixpanel?: Mixpanel;\n}\n\nclass Analytics {\n  private events: TrackableEvent[] = [];\n  private isEnabled: boolean;\n\n  constructor() {\n    this.isEnabled = process.env.NODE_ENV === \"production\" || \n                    process.env.NEXT_PUBLIC_ANALYTICS_ENABLED === \"true\";\n  }\n\n  track(event: TrackableEvent): void {\n    if (!this.isEnabled) {\n      // In development, just log to console\n      // console.log(\"Analytics Event:\", event);\n      return;\n    }\n\n    // Add timestamp if not provided\n    if (!event.timestamp) {\n      event.timestamp = Date.now();\n    }\n\n    this.events.push(event);\n\n    // In production, you would send this to your analytics service\n    // Example: Google Analytics, Mixpanel, etc.\n    this.sendToAnalyticsService(event);\n  }\n\n  private sendToAnalyticsService(event: TrackableEvent): void {\n    // Example implementation for Google Analytics 4\n    if (typeof window !== \"undefined\" && (window as WindowWithAnalytics).gtag) {\n      (window as WindowWithAnalytics).gtag!(\"event\", event.event, event.properties);\n    }\n\n    // Example implementation for Mixpanel\n    if (typeof window !== \"undefined\" && (window as WindowWithAnalytics).mixpanel) {\n      (window as WindowWithAnalytics).mixpanel!.track(event.event, event.properties);\n    }\n\n    // Example implementation for custom analytics endpoint\n    if (process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT) {\n      fetch(process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(event),\n      }).catch((error) => {\n        console.error(\"Failed to send analytics event:\", error);\n      });\n    }\n  }\n\n  getEvents(): TrackableEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n}\n\n// Global analytics instance\nconst analytics = new Analytics();\n\nexport function useAnalytics() {\n  const trackNavigation = useCallback((from: string, to: string, method: \"click\" | \"keyboard\" | \"programmatic\" = \"click\") => {\n    analytics.track({\n      event: \"navigation\",\n      properties: {\n        from,\n        to,\n        method,\n      },\n    });\n  }, []);\n\n  const trackButtonClick = useCallback((button: string, location: string, action: string) => {\n    analytics.track({\n      event: \"button_click\",\n      properties: {\n        button,\n        location,\n        action,\n      },\n    });\n  }, []);\n\n  const trackCustomEvent = useCallback((event: string, properties?: Record<string, unknown>) => {\n    analytics.track({\n      event,\n      properties,\n    } as CustomEvent);\n  }, []);\n\n  return {\n    trackNavigation,\n    trackButtonClick,\n    trackCustomEvent,\n    getEvents: analytics.getEvents.bind(analytics),\n    clearEvents: analytics.clearEvents.bind(analytics),\n  };\n}\n"],"names":[],"mappings":";;;;AAEA;AAFA;;AAiDA,MAAM;IACI,SAA2B,EAAE,CAAC;IAC9B,UAAmB;IAE3B,aAAc;QACZ,IAAI,CAAC,SAAS,GAAG,oDAAyB,gBAC1B,QAAQ,GAAG,CAAC,6BAA6B,KAAK;IAChE;IAEA,MAAM,KAAqB,EAAQ;QACjC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,sCAAsC;YACtC,0CAA0C;YAC1C;QACF;QAEA,gCAAgC;QAChC,IAAI,CAAC,MAAM,SAAS,EAAE;YACpB,MAAM,SAAS,GAAG,KAAK,GAAG;QAC5B;QAEA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAEjB,+DAA+D;QAC/D,4CAA4C;QAC5C,IAAI,CAAC,sBAAsB,CAAC;IAC9B;IAEQ,uBAAuB,KAAqB,EAAQ;QAC1D,gDAAgD;QAChD;;QAIA,sCAAsC;QACtC;;QAIA,uDAAuD;QACvD,IAAI,QAAQ,GAAG,CAAC,8BAA8B,EAAE;YAC9C,MAAM,QAAQ,GAAG,CAAC,8BAA8B,EAAE;gBAChD,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,MAAM,KAAK,SAAS,CAAC;YACvB,GAAG,KAAK,CAAC,CAAC;gBACR,QAAQ,KAAK,CAAC,mCAAmC;YACnD;QACF;IACF;IAEA,YAA8B;QAC5B,OAAO;eAAI,IAAI,CAAC,MAAM;SAAC;IACzB;IAEA,cAAoB;QAClB,IAAI,CAAC,MAAM,GAAG,EAAE;IAClB;AACF;AAEA,4BAA4B;AAC5B,MAAM,YAAY,IAAI;AAEf,SAAS;IACd,MAAM,kBAAkB,IAAA,wOAAW,EAAC,CAAC,MAAc,IAAY,SAAgD,OAAO;QACpH,UAAU,KAAK,CAAC;YACd,OAAO;YACP,YAAY;gBACV;gBACA;gBACA;YACF;QACF;IACF,GAAG,EAAE;IAEL,MAAM,mBAAmB,IAAA,wOAAW,EAAC,CAAC,QAAgB,UAAkB;QACtE,UAAU,KAAK,CAAC;YACd,OAAO;YACP,YAAY;gBACV;gBACA;gBACA;YACF;QACF;IACF,GAAG,EAAE;IAEL,MAAM,mBAAmB,IAAA,wOAAW,EAAC,CAAC,OAAe;QACnD,UAAU,KAAK,CAAC;YACd;YACA;QACF;IACF,GAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA,WAAW,UAAU,SAAS,CAAC,IAAI,CAAC;QACpC,aAAa,UAAU,WAAW,CAAC,IAAI,CAAC;IAC1C;AACF"}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/use-active-section.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nexport function useActiveSection(sectionIds: string[], offset: number = 100) {\n  const [activeSection, setActiveSection] = useState<string>('');\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollPosition = window.scrollY;\n      const windowHeight = window.innerHeight;\n      const viewportTop = scrollPosition;\n      const viewportBottom = scrollPosition + windowHeight;\n      const viewportCenter = scrollPosition + (windowHeight / 2);\n        \n      // Find which section is most prominently visible in the viewport\n      let bestSection = '';\n      let bestScore = -1;\n      \n      for (let i = 0; i < sectionIds.length; i++) {\n        const sectionId = sectionIds[i];\n        const element = document.getElementById(sectionId);\n        \n        if (element) {\n          const elementTop = element.offsetTop;\n          const elementBottom = elementTop + element.offsetHeight;\n          const elementCenter = elementTop + (element.offsetHeight / 2);\n          \n          // Calculate how much of this section is visible in the viewport\n          const visibleTop = Math.max(elementTop, viewportTop);\n          const visibleBottom = Math.min(elementBottom, viewportBottom);\n          const visibleHeight = Math.max(0, visibleBottom - visibleTop);\n          \n          // Calculate a score based on visibility and proximity to viewport center\n          const visibilityRatio = visibleHeight / element.offsetHeight;\n          const distanceFromCenter = Math.abs(elementCenter - viewportCenter);\n          const score = visibilityRatio - (distanceFromCenter / windowHeight) * 0.1;\n          \n          if (score > bestScore) {\n            bestScore = score;\n            bestSection = sectionId;\n          }\n        }\n      }\n      \n      // Only set active section if we found a section with reasonable visibility\n      if (bestScore > 0.1) {\n        setActiveSection(bestSection);\n      }\n    };\n\n    // Initial check\n    handleScroll();\n    \n    // Add scroll listener with throttling\n    let ticking = false;\n    const throttledHandleScroll = () => {\n      if (!ticking) {\n        requestAnimationFrame(() => {\n          handleScroll();\n          ticking = false;\n        });\n        ticking = true;\n      }\n    };\n    \n    window.addEventListener('scroll', throttledHandleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', throttledHandleScroll);\n    };\n  }, [sectionIds, offset]);\n\n  return activeSection;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,iBAAiB,UAAoB,EAAE,SAAiB,GAAG;IACzE,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,qOAAQ,EAAS;IAE3D,IAAA,sOAAS,EAAC;QACR,MAAM,eAAe;YACnB,MAAM,iBAAiB,OAAO,OAAO;YACrC,MAAM,eAAe,OAAO,WAAW;YACvC,MAAM,cAAc;YACpB,MAAM,iBAAiB,iBAAiB;YACxC,MAAM,iBAAiB,iBAAkB,eAAe;YAExD,iEAAiE;YACjE,IAAI,cAAc;YAClB,IAAI,YAAY,CAAC;YAEjB,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;gBAC1C,MAAM,YAAY,UAAU,CAAC,EAAE;gBAC/B,MAAM,UAAU,SAAS,cAAc,CAAC;gBAExC,IAAI,SAAS;oBACX,MAAM,aAAa,QAAQ,SAAS;oBACpC,MAAM,gBAAgB,aAAa,QAAQ,YAAY;oBACvD,MAAM,gBAAgB,aAAc,QAAQ,YAAY,GAAG;oBAE3D,gEAAgE;oBAChE,MAAM,aAAa,KAAK,GAAG,CAAC,YAAY;oBACxC,MAAM,gBAAgB,KAAK,GAAG,CAAC,eAAe;oBAC9C,MAAM,gBAAgB,KAAK,GAAG,CAAC,GAAG,gBAAgB;oBAElD,yEAAyE;oBACzE,MAAM,kBAAkB,gBAAgB,QAAQ,YAAY;oBAC5D,MAAM,qBAAqB,KAAK,GAAG,CAAC,gBAAgB;oBACpD,MAAM,QAAQ,kBAAkB,AAAC,qBAAqB,eAAgB;oBAEtE,IAAI,QAAQ,WAAW;wBACrB,YAAY;wBACZ,cAAc;oBAChB;gBACF;YACF;YAEA,2EAA2E;YAC3E,IAAI,YAAY,KAAK;gBACnB,iBAAiB;YACnB;QACF;QAEA,gBAAgB;QAChB;QAEA,sCAAsC;QACtC,IAAI,UAAU;QACd,MAAM,wBAAwB;YAC5B,IAAI,CAAC,SAAS;gBACZ,sBAAsB;oBACpB;oBACA,UAAU;gBACZ;gBACA,UAAU;YACZ;QACF;QAEA,OAAO,gBAAgB,CAAC,UAAU,uBAAuB;YAAE,SAAS;QAAK;QAEzE,OAAO;YACL,OAAO,mBAAmB,CAAC,UAAU;QACvC;IACF,GAAG;QAAC;QAAY;KAAO;IAEvB,OAAO;AACT"}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useModalScrollLock.ts"],"sourcesContent":["'use client'\n\nimport { useEffect, useRef } from 'react'\n\n// Global counter to track how many modals are open\nlet modalCount = 0\nlet originalBodyStyle = ''\n\n/**\n * Custom hook to handle body scroll locking for modals\n * This ensures that when multiple modals are open, scroll is only restored\n * when ALL modals are closed\n */\nexport function useModalScrollLock(isOpen: boolean) {\n  const isLockedRef = useRef(false)\n\n  useEffect(() => {\n    if (isOpen && !isLockedRef.current) {\n      // Store original body style only once\n      if (modalCount === 0) {\n        originalBodyStyle = document.body.style.overflow || ''\n      }\n      \n      // Increment modal count and lock scroll\n      modalCount++\n      document.body.style.overflow = 'hidden'\n      isLockedRef.current = true\n    } else if (!isOpen && isLockedRef.current) {\n      // Decrement modal count\n      modalCount--\n      isLockedRef.current = false\n      \n      // Only restore scroll when all modals are closed\n      if (modalCount <= 0) {\n        modalCount = 0 // Ensure it doesn't go negative\n        document.body.style.overflow = originalBodyStyle\n        originalBodyStyle = '' // Reset for next time\n      }\n    }\n\n    // Cleanup function to ensure proper restoration\n    return () => {\n      if (isLockedRef.current) {\n        modalCount--\n        isLockedRef.current = false\n        \n        if (modalCount <= 0) {\n          modalCount = 0\n          document.body.style.overflow = originalBodyStyle\n          originalBodyStyle = ''\n        }\n      }\n    }\n  }, [isOpen])\n}\n\n/**\n * Utility function to force restore scroll (for emergency cases)\n */\nexport function forceRestoreScroll() {\n  modalCount = 0\n  document.body.style.overflow = originalBodyStyle\n  originalBodyStyle = ''\n}\n"],"names":[],"mappings":";;;;;;AAEA;AAFA;;AAIA,mDAAmD;AACnD,IAAI,aAAa;AACjB,IAAI,oBAAoB;AAOjB,SAAS,mBAAmB,MAAe;IAChD,MAAM,cAAc,IAAA,mOAAM,EAAC;IAE3B,IAAA,sOAAS,EAAC;QACR,IAAI,UAAU,CAAC,YAAY,OAAO,EAAE;YAClC,sCAAsC;YACtC,IAAI,eAAe,GAAG;gBACpB,oBAAoB,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI;YACtD;YAEA,wCAAwC;YACxC;YACA,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;YAC/B,YAAY,OAAO,GAAG;QACxB,OAAO,IAAI,CAAC,UAAU,YAAY,OAAO,EAAE;YACzC,wBAAwB;YACxB;YACA,YAAY,OAAO,GAAG;YAEtB,iDAAiD;YACjD,IAAI,cAAc,GAAG;gBACnB,aAAa,GAAE,gCAAgC;gBAC/C,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;gBAC/B,oBAAoB,IAAG,sBAAsB;YAC/C;QACF;QAEA,gDAAgD;QAChD,OAAO;YACL,IAAI,YAAY,OAAO,EAAE;gBACvB;gBACA,YAAY,OAAO,GAAG;gBAEtB,IAAI,cAAc,GAAG;oBACnB,aAAa;oBACb,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;oBAC/B,oBAAoB;gBACtB;YACF;QACF;IACF,GAAG;QAAC;KAAO;AACb;AAKO,SAAS;IACd,aAAa;IACb,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;IAC/B,oBAAoB;AACtB"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useTokenValidation.ts"],"sourcesContent":["import { useEffect, useCallback } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { clearUser } from '@/store/slices/userSlice';\nimport { isTokenExpired, isTokenExpiringSoon, handleTokenExpiration } from '@/lib/jwt-client';\nimport { useNotificationStore } from '@/components/ui/global-notification';\nimport { getApiUrl, API_CONFIG } from '@/lib/config';\n\nexport const useTokenValidation = () => {\n  const dispatch = useDispatch();\n  const { showNotification } = useNotificationStore();\n\n  const checkTokenExpiration = useCallback(() => {\n    const token = localStorage.getItem('accessToken');\n    \n    if (!token) {\n      return;\n    }\n\n    // Check if token is expired\n    if (isTokenExpired(token)) {\n      console.log('Token expired, logging out user');\n      dispatch(clearUser());\n      handleTokenExpiration();\n      showNotification('Token expired. Please login again.', 'error');\n      return;\n    }\n\n    // Check if token is expiring soon (within 1 hour)\n    if (isTokenExpiringSoon(token, 60)) {\n      console.log('Token expiring soon, showing warning to user');\n      // You can show a notification to the user here\n      // For now, we'll just log it\n    }\n  }, [dispatch, showNotification]);\n\n  const validateTokenWithServer = useCallback(async () => {\n    const token = localStorage.getItem('accessToken');\n    if (!token) {\n      return false;\n    }\n\n    try {\n      const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.AUTH.VALIDATE_TOKEN), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ token }),\n      });\n\n      // Handle 401 Unauthorized (user deleted or token invalid)\n      if (response.status === 401) {\n        console.log('Server returned 401 - user deleted or token invalid, logging out user');\n        dispatch(clearUser());\n        handleTokenExpiration();\n        showNotification('Session expired. Please login again.', 'error');\n        return false;\n      }\n\n      const data = await response.json();\n\n      if (!data.success) {\n        console.log('Server validation failed, logging out user');\n        dispatch(clearUser());\n        handleTokenExpiration();\n        showNotification('Token expired. Please login again.', 'error');\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Token validation error:', error);\n      return false;\n    }\n  }, [dispatch, showNotification]);\n\n  // Check token expiration on mount and every 5 minutes\n  useEffect(() => {\n    checkTokenExpiration();\n\n    const interval = setInterval(checkTokenExpiration, 5 * 60 * 1000); // 5 minutes\n\n    return () => clearInterval(interval);\n  }, [checkTokenExpiration]);\n\n  // Validate token with server on mount (only if token exists)\n  useEffect(() => {\n    const token = localStorage.getItem('accessToken');\n    if (token) {\n      validateTokenWithServer();\n    }\n  }, [validateTokenWithServer]);\n\n  return {\n    checkTokenExpiration,\n    validateTokenWithServer,\n  };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,qBAAqB;IAChC,MAAM,WAAW,IAAA,4LAAW;IAC5B,MAAM,EAAE,gBAAgB,EAAE,GAAG,IAAA,8LAAoB;IAEjD,MAAM,uBAAuB,IAAA,wOAAW,EAAC;QACvC,MAAM,QAAQ,aAAa,OAAO,CAAC;QAEnC,IAAI,CAAC,OAAO;YACV;QACF;QAEA,4BAA4B;QAC5B,IAAI,IAAA,iKAAc,EAAC,QAAQ;YACzB,QAAQ,GAAG,CAAC;YACZ,SAAS,IAAA,oKAAS;YAClB,IAAA,wKAAqB;YACrB,iBAAiB,sCAAsC;YACvD;QACF;QAEA,kDAAkD;QAClD,IAAI,IAAA,sKAAmB,EAAC,OAAO,KAAK;YAClC,QAAQ,GAAG,CAAC;QACZ,+CAA+C;QAC/C,6BAA6B;QAC/B;IACF,GAAG;QAAC;QAAU;KAAiB;IAE/B,MAAM,0BAA0B,IAAA,wOAAW,EAAC;QAC1C,MAAM,QAAQ,aAAa,OAAO,CAAC;QACnC,IAAI,CAAC,OAAO;YACV,OAAO;QACT;QAEA,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,IAAA,qJAAS,EAAC,sJAAU,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,GAAG;gBAChF,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,MAAM,KAAK,SAAS,CAAC;oBAAE;gBAAM;YAC/B;YAEA,0DAA0D;YAC1D,IAAI,SAAS,MAAM,KAAK,KAAK;gBAC3B,QAAQ,GAAG,CAAC;gBACZ,SAAS,IAAA,oKAAS;gBAClB,IAAA,wKAAqB;gBACrB,iBAAiB,wCAAwC;gBACzD,OAAO;YACT;YAEA,MAAM,OAAO,MAAM,SAAS,IAAI;YAEhC,IAAI,CAAC,KAAK,OAAO,EAAE;gBACjB,QAAQ,GAAG,CAAC;gBACZ,SAAS,IAAA,oKAAS;gBAClB,IAAA,wKAAqB;gBACrB,iBAAiB,sCAAsC;gBACvD,OAAO;YACT;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YACzC,OAAO;QACT;IACF,GAAG;QAAC;QAAU;KAAiB;IAE/B,sDAAsD;IACtD,IAAA,sOAAS,EAAC;QACR;QAEA,MAAM,WAAW,YAAY,sBAAsB,IAAI,KAAK,OAAO,YAAY;QAE/E,OAAO,IAAM,cAAc;IAC7B,GAAG;QAAC;KAAqB;IAEzB,6DAA6D;IAC7D,IAAA,sOAAS,EAAC;QACR,MAAM,QAAQ,aAAa,OAAO,CAAC;QACnC,IAAI,OAAO;YACT;QACF;IACF,GAAG;QAAC;KAAwB;IAE5B,OAAO;QACL;QACA;IACF;AACF"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useAuthErrorHandler.ts"],"sourcesContent":["'use client'\n\nimport { useEffect } from 'react'\nimport { useAppDispatch } from '@/store/hooks'\nimport { clearUser } from '@/store/slices/userSlice'\nimport { isTokenExpired } from '@/lib/jwt-client'\nimport { useNotificationStore } from '@/components/ui/global-notification'\n\nexport function useAuthErrorHandler() {\n  const dispatch = useAppDispatch()\n  const { showNotification } = useNotificationStore()\n\n  useEffect(() => {\n    // Create a global fetch interceptor\n    const originalFetch = window.fetch\n\n    window.fetch = async (...args) => {\n      try {\n        const response = await originalFetch(...args)\n        \n        // Check if response is 401 (Unauthorized)\n        if (response.status === 401) {\n          const responseData = await response.clone().json().catch(() => ({}))\n          \n          // Check if it's a token-related error\n          if (responseData.message?.includes('token') || \n              responseData.message?.includes('unauthorized') ||\n              responseData.message?.includes('expired')) {\n            // Safeguard: only force logout if the client-side token is missing or actually expired\n            const token = typeof window !== 'undefined' ? localStorage.getItem('accessToken') : null\n            const shouldLogout = !token || isTokenExpired(token)\n\n            if (shouldLogout) {\n              console.log('ðŸ” Auth Error Handler: Token expired or invalid, logging out user')\n              dispatch(clearUser())\n              \n              // Check if we're on a protected page - if so, don't show toast (ProtectedRoute will handle it)\n              const currentPath = window.location.pathname\n              const isProtectedPage = currentPath.includes('/create-video') || \n                                   currentPath.includes('/account') || \n                                   currentPath.includes('/gallery') || \n                                   currentPath.includes('/report-analytics') || \n                                   currentPath.includes('/scheduled-post')\n              \n              // Never show toast for protected pages - ProtectedRoute handles it\n              if (!isProtectedPage) {\n                // Only show toast for API calls on non-protected pages\n                showNotification('Unauthorized access', 'error')\n              }\n              \n              return new Response(JSON.stringify({ \n                success: false, \n                message: 'Authentication failed' \n              }), {\n                status: 401,\n                headers: { 'Content-Type': 'application/json' }\n              })\n            }\n            \n            // If token exists and is not expired client-side, don't auto-logout; let the caller handle the 401\n            console.log('ðŸ” Auth Error Handler: 401 received but token appears valid client-side; not logging out')\n            return response\n          }\n        }\n        \n        // Check for network errors (status 0 or failed fetch)\n        if (response.status === 0 || !response.ok) {\n          console.log('ðŸ” Auth Error Handler: Network error detected, not clearing user data')\n          // Don't clear user data on network errors - might be temporary\n          return response\n        }\n        \n        return response\n      } catch (error) {\n        console.error('Fetch interceptor error:', error)\n        return originalFetch(...args)\n      }\n    }\n\n    // Cleanup function\n    return () => {\n      window.fetch = originalFetch\n    }\n  }, [dispatch, showNotification])\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AACA;AACA;AANA;;;;;;AAQO,SAAS;IACd,MAAM,WAAW,IAAA,2JAAc;IAC/B,MAAM,EAAE,gBAAgB,EAAE,GAAG,IAAA,8LAAoB;IAEjD,IAAA,sOAAS,EAAC;QACR,oCAAoC;QACpC,MAAM,gBAAgB,OAAO,KAAK;QAElC,OAAO,KAAK,GAAG,OAAO,GAAG;YACvB,IAAI;gBACF,MAAM,WAAW,MAAM,iBAAiB;gBAExC,0CAA0C;gBAC1C,IAAI,SAAS,MAAM,KAAK,KAAK;oBAC3B,MAAM,eAAe,MAAM,SAAS,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;oBAElE,sCAAsC;oBACtC,IAAI,aAAa,OAAO,EAAE,SAAS,YAC/B,aAAa,OAAO,EAAE,SAAS,mBAC/B,aAAa,OAAO,EAAE,SAAS,YAAY;wBAC7C,uFAAuF;wBACvF,MAAM,QAAQ,sCAAgC,0BAAsC;wBACpF,MAAM,eAAe,CAAC,SAAS,IAAA,iKAAc,EAAC;wBAE9C,wCAAkB;4BAChB,QAAQ,GAAG,CAAC;4BACZ,SAAS,IAAA,oKAAS;4BAElB,+FAA+F;4BAC/F,MAAM,cAAc,OAAO,QAAQ,CAAC,QAAQ;4BAC5C,MAAM,kBAAkB,YAAY,QAAQ,CAAC,oBACxB,YAAY,QAAQ,CAAC,eACrB,YAAY,QAAQ,CAAC,eACrB,YAAY,QAAQ,CAAC,wBACrB,YAAY,QAAQ,CAAC;4BAE1C,mEAAmE;4BACnE,IAAI,CAAC,iBAAiB;gCACpB,uDAAuD;gCACvD,iBAAiB,uBAAuB;4BAC1C;4BAEA,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;gCACjC,SAAS;gCACT,SAAS;4BACX,IAAI;gCACF,QAAQ;gCACR,SAAS;oCAAE,gBAAgB;gCAAmB;4BAChD;wBACF;;;oBAKF;gBACF;gBAEA,sDAAsD;gBACtD,IAAI,SAAS,MAAM,KAAK,KAAK,CAAC,SAAS,EAAE,EAAE;oBACzC,QAAQ,GAAG,CAAC;oBACZ,+DAA+D;oBAC/D,OAAO;gBACT;gBAEA,OAAO;YACT,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,4BAA4B;gBAC1C,OAAO,iBAAiB;YAC1B;QACF;QAEA,mBAAmB;QACnB,OAAO;YACL,OAAO,KAAK,GAAG;QACjB;IACF,GAAG;QAAC;QAAU;KAAiB;AACjC"}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useDeploymentReload.ts"],"sourcesContent":["'use client'\n\nimport { useEffect, useRef, useState } from 'react'\n\ninterface DeploymentInfo {\n  deploymentId: string\n  deploymentUrl: string\n  createdAt: string\n}\n\n/**\n * Hook to automatically hard refresh the page when a new Vercel deployment is detected\n * \n * This hook:\n * 1. Polls the deployment check endpoint to detect new deployments\n * 2. Uses BroadcastChannel for cross-tab communication\n * 3. Triggers a hard refresh (cache bypass) when new deployment is detected\n * 4. Only runs in production/browser environment\n */\nexport const useDeploymentReload = () => {\n  const [isChecking, setIsChecking] = useState(false)\n  const lastDeploymentIdRef = useRef<string | null>(null)\n  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null)\n  const broadcastChannelRef = useRef<BroadcastChannel | null>(null)\n  const isReloadingRef = useRef(false)\n\n  useEffect(() => {\n    // Only run in browser environment\n    if (typeof window === 'undefined') {\n      console.log('ðŸ”„ Deployment reload: Skipping (server-side)')\n      return\n    }\n\n    console.log('ðŸ”„ Deployment reload: Hook initialized', {\n      hostname: window.location.hostname,\n      nodeEnv: process.env.NODE_ENV,\n      timestamp: new Date().toISOString()\n    })\n\n    // Only run in production (Vercel deployments)\n    const isProduction = process.env.NODE_ENV === 'production' || \n                         window.location.hostname.includes('vercel.app') ||\n                         window.location.hostname.includes('edgeairealty.com')\n\n    if (!isProduction) {\n      console.log('ðŸ”„ Deployment reload: Skipping in development', {\n        reason: 'Not in production environment',\n        hostname: window.location.hostname,\n        nodeEnv: process.env.NODE_ENV\n      })\n      return\n    }\n\n    console.log('ðŸ”„ Deployment reload: Production mode detected - Starting deployment monitoring', {\n      hostname: window.location.hostname,\n      timestamp: new Date().toISOString()\n    })\n\n    // Initialize BroadcastChannel for cross-tab communication\n    try {\n      broadcastChannelRef.current = new BroadcastChannel('deployment-reload')\n      console.log('ðŸ”„ Deployment reload: BroadcastChannel initialized for cross-tab communication')\n      \n      broadcastChannelRef.current.onmessage = (event) => {\n        console.log('ðŸ”„ Deployment reload: Message received from another tab', event.data)\n        if (event.data.type === 'new-deployment' && !isReloadingRef.current) {\n          console.log('ðŸ”„ Deployment reload: New deployment detected from another tab, reloading...', {\n            deploymentId: event.data.deploymentId,\n            timestamp: new Date().toISOString()\n          })\n          isReloadingRef.current = true\n          // Hard refresh with cache bypass\n          console.log('ðŸ”„ Deployment reload: Executing hard reload from cross-tab message...')\n          window.location.reload()\n        }\n      }\n    } catch (error) {\n      console.warn('ðŸ”„ Deployment reload: BroadcastChannel not supported', error)\n    }\n\n    // Function to check for new deployments\n    const checkDeployment = async () => {\n      if (isReloadingRef.current) {\n        console.log('ðŸ”„ Deployment reload: Check skipped (reload already in progress)')\n        return\n      }\n\n      console.log('ðŸ”„ Deployment reload: Checking for new deployment...', {\n        timestamp: new Date().toISOString(),\n        lastDeploymentId: lastDeploymentIdRef.current\n      })\n\n      try {\n        setIsChecking(true)\n        \n        // Call deployment check API\n        console.log('ðŸ”„ Deployment reload: Calling /api/deployment/check endpoint...')\n        const response = await fetch('/api/deployment/check', {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          cache: 'no-store', // Always fetch fresh data\n        })\n\n        console.log('ðŸ”„ Deployment reload: API response received', {\n          status: response.status,\n          ok: response.ok,\n          timestamp: new Date().toISOString()\n        })\n\n        if (!response.ok) {\n          console.warn('ðŸ”„ Deployment reload: Check endpoint returned error', {\n            status: response.status,\n            statusText: response.statusText,\n            timestamp: new Date().toISOString()\n          })\n          return\n        }\n\n        const data = await response.json()\n        console.log('ðŸ”„ Deployment reload: API response data', {\n          success: data.success,\n          hasDeployment: !!data.deployment,\n          deploymentId: data.deployment?.deploymentId || data.deployment?.id,\n          timestamp: new Date().toISOString()\n        })\n        \n        if (data.success && data.deployment) {\n          // Use deploymentId, id, or buildTime as identifier\n          const currentDeploymentId = data.deployment.deploymentId || \n                                     data.deployment.id || \n                                     data.deployment.buildTime ||\n                                     null\n          \n          if (!currentDeploymentId) {\n            console.warn('ðŸ”„ Deployment reload: No deployment identifier found in response')\n            return\n          }\n          \n          // First check - just store the deployment ID\n          if (!lastDeploymentIdRef.current) {\n            lastDeploymentIdRef.current = currentDeploymentId\n            console.log('ðŸ”„ Deployment reload: âœ… Initial deployment ID stored', {\n              deploymentId: currentDeploymentId,\n              timestamp: new Date().toISOString(),\n              message: 'No reload needed - this is the first check'\n            })\n            return\n          }\n\n          console.log('ðŸ”„ Deployment reload: Comparing deployment IDs', {\n            stored: lastDeploymentIdRef.current,\n            current: currentDeploymentId,\n            match: currentDeploymentId === lastDeploymentIdRef.current,\n            timestamp: new Date().toISOString()\n          })\n\n          // Check if deployment ID has changed (new deployment)\n          if (currentDeploymentId !== lastDeploymentIdRef.current) {\n            console.log('ðŸ”„ Deployment reload: ðŸš¨ NEW DEPLOYMENT DETECTED!', {\n              oldDeploymentId: lastDeploymentIdRef.current,\n              newDeploymentId: currentDeploymentId,\n              timestamp: new Date().toISOString(),\n              action: 'Will reload page in 2 seconds'\n            })\n            \n            // Update stored deployment ID\n            lastDeploymentIdRef.current = currentDeploymentId\n            \n            // Broadcast to other tabs\n            if (broadcastChannelRef.current) {\n              try {\n                console.log('ðŸ”„ Deployment reload: Broadcasting to other tabs...', {\n                  deploymentId: currentDeploymentId,\n                  timestamp: new Date().toISOString()\n                })\n                broadcastChannelRef.current.postMessage({ \n                  type: 'new-deployment', \n                  deploymentId: currentDeploymentId \n                })\n                console.log('ðŸ”„ Deployment reload: âœ… Broadcast sent to other tabs')\n              } catch (error) {\n                console.warn('ðŸ”„ Deployment reload: âŒ Failed to broadcast to other tabs', error)\n              }\n            } else {\n              console.log('ðŸ”„ Deployment reload: âš ï¸ BroadcastChannel not available - skipping cross-tab notification')\n            }\n\n            // Set flag to prevent multiple reloads\n            isReloadingRef.current = true\n            console.log('ðŸ”„ Deployment reload: Reload flag set to prevent multiple reloads')\n\n            // Show a brief message to user\n            if (typeof window !== 'undefined' && window.document) {\n              console.log('ðŸ”„ Deployment reload: Creating user notification...')\n              const notification = document.createElement('div')\n              notification.textContent = 'New version available. Reloading...'\n              notification.style.cssText = `\n                position: fixed;\n                top: 20px;\n                right: 20px;\n                background: #5046E5;\n                color: white;\n                padding: 12px 24px;\n                border-radius: 8px;\n                z-index: 9999;\n                font-family: system-ui, -apple-system, sans-serif;\n                font-size: 14px;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n                animation: slideIn 0.3s ease-out;\n              `\n              \n              // Add animation\n              const style = document.createElement('style')\n              style.textContent = `\n                @keyframes slideIn {\n                  from {\n                    transform: translateX(100%);\n                    opacity: 0;\n                  }\n                  to {\n                    transform: translateX(0);\n                    opacity: 1;\n                  }\n                }\n              `\n              document.head.appendChild(style)\n              document.body.appendChild(notification)\n\n              // Remove notification after 2 seconds and reload\n              console.log('ðŸ”„ Deployment reload: â±ï¸ Setting 2-second delay before reload...', {\n                timestamp: new Date().toISOString(),\n                reloadTime: new Date(Date.now() + 2000).toISOString()\n              })\n              \n              const reloadTimeout = setTimeout(() => {\n                console.log('ðŸ”„ Deployment reload: ðŸ”„ EXECUTING HARD RELOAD NOW!', {\n                  timestamp: new Date().toISOString(),\n                  deploymentId: currentDeploymentId\n                })\n                \n                try {\n                  if (notification.parentNode) {\n                    notification.parentNode.removeChild(notification)\n                    console.log('ðŸ”„ Deployment reload: âœ… Notification removed')\n                  }\n                  if (style.parentNode) {\n                    style.parentNode.removeChild(style)\n                    console.log('ðŸ”„ Deployment reload: âœ… Style removed')\n                  }\n                  // Hard refresh with cache bypass\n                  // Note: reload() bypasses cache in modern browsers\n                  console.log('ðŸ”„ Deployment reload: ðŸš€ Calling window.location.reload()...')\n                  window.location.reload()\n                } catch (error) {\n                  console.warn('ðŸ”„ Deployment reload: âŒ Error during reload', error)\n                  // Fallback: try direct navigation\n                  console.log('ðŸ”„ Deployment reload: ðŸ”„ Trying fallback reload method...')\n                  window.location.href = window.location.href\n                }\n              }, 2000)\n\n              // Store timeout for potential cleanup\n              // Note: This will be cleared on page reload anyway\n            } else {\n              // Fallback: immediate reload\n              console.log('ðŸ”„ Deployment reload: ðŸ”„ Executing immediate reload (fallback)...', {\n                timestamp: new Date().toISOString(),\n                deploymentId: currentDeploymentId\n              })\n              window.location.reload()\n            }\n          } else {\n            console.log('ðŸ”„ Deployment reload: âœ… Same deployment ID - no reload needed', {\n              deploymentId: currentDeploymentId,\n              timestamp: new Date().toISOString()\n            })\n          }\n        } else {\n          console.warn('ðŸ”„ Deployment reload: âš ï¸ Invalid API response structure', {\n            hasSuccess: 'success' in data,\n            hasDeployment: 'deployment' in data,\n            data: data\n          })\n        }\n      } catch (error) {\n        console.warn('ðŸ”„ Deployment reload: âŒ Error checking deployment', {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n          timestamp: new Date().toISOString()\n        })\n      } finally {\n        setIsChecking(false)\n        console.log('ðŸ”„ Deployment reload: Check completed', {\n          isChecking: false,\n          timestamp: new Date().toISOString()\n        })\n      }\n    }\n\n    // Initial check after a short delay\n    console.log('ðŸ”„ Deployment reload: â±ï¸ Scheduling initial check in 5 seconds...', {\n      timestamp: new Date().toISOString(),\n      checkTime: new Date(Date.now() + 5000).toISOString()\n    })\n    \n    const initialTimeout = setTimeout(() => {\n      console.log('ðŸ”„ Deployment reload: ðŸ• Initial check triggered (5 seconds after page load)')\n      checkDeployment()\n    }, 5000) // Wait 5 seconds after page load\n\n    // Set up polling interval (check every 2 minutes)\n    console.log('ðŸ”„ Deployment reload: â±ï¸ Setting up polling interval (every 2 minutes)...', {\n      interval: '2 minutes',\n      timestamp: new Date().toISOString()\n    })\n    \n    checkIntervalRef.current = setInterval(() => {\n      console.log('ðŸ”„ Deployment reload: ðŸ• Polling interval triggered (2 minutes elapsed)')\n      checkDeployment()\n    }, 2 * 60 * 1000) // 2 minutes\n\n    // Also check when page becomes visible (user returns to tab)\n    const handleVisibilityChange = () => {\n      if (!document.hidden && !isReloadingRef.current) {\n        console.log('ðŸ”„ Deployment reload: ðŸ‘ï¸ Page became visible - checking for new deployment...', {\n          timestamp: new Date().toISOString(),\n          wasHidden: document.hidden\n        })\n        checkDeployment()\n      } else if (document.hidden) {\n        console.log('ðŸ”„ Deployment reload: ðŸ‘ï¸ Page hidden - skipping check', {\n          timestamp: new Date().toISOString()\n        })\n      }\n    }\n\n    document.addEventListener('visibilitychange', handleVisibilityChange)\n    console.log('ðŸ”„ Deployment reload: âœ… Visibility change listener added')\n\n    console.log('ðŸ”„ Deployment reload: âœ… All setup complete!', {\n      initialCheckDelay: '5 seconds',\n      pollingInterval: '2 minutes',\n      broadcastChannel: broadcastChannelRef.current ? 'enabled' : 'disabled',\n      timestamp: new Date().toISOString()\n    })\n\n    // Cleanup\n    return () => {\n      console.log('ðŸ”„ Deployment reload: ðŸ§¹ Cleaning up...', {\n        timestamp: new Date().toISOString()\n      })\n      \n      clearTimeout(initialTimeout)\n      console.log('ðŸ”„ Deployment reload: âœ… Initial timeout cleared')\n      \n      if (checkIntervalRef.current) {\n        clearInterval(checkIntervalRef.current)\n        console.log('ðŸ”„ Deployment reload: âœ… Polling interval cleared')\n      }\n      \n      if (broadcastChannelRef.current) {\n        broadcastChannelRef.current.close()\n        console.log('ðŸ”„ Deployment reload: âœ… BroadcastChannel closed')\n      }\n      \n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n      console.log('ðŸ”„ Deployment reload: âœ… Visibility change listener removed')\n      \n      console.log('ðŸ”„ Deployment reload: âœ… Cleanup complete')\n    }\n  }, [])\n\n  return { isChecking }\n}\n\n"],"names":[],"mappings":";;;;AAEA;AAFA;;AAmBO,MAAM,sBAAsB;IACjC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,qOAAQ,EAAC;IAC7C,MAAM,sBAAsB,IAAA,mOAAM,EAAgB;IAClD,MAAM,mBAAmB,IAAA,mOAAM,EAAwB;IACvD,MAAM,sBAAsB,IAAA,mOAAM,EAA0B;IAC5D,MAAM,iBAAiB,IAAA,mOAAM,EAAC;IAE9B,IAAA,sOAAS,EAAC;QACR,kCAAkC;QAClC,wCAAmC;YACjC,QAAQ,GAAG,CAAC;YACZ;QACF;;;QAQA,8CAA8C;QAC9C,MAAM;QAwCN,wCAAwC;QACxC,MAAM;QAkON,MAAM,4BAGG,iCAAiC;QAa1C,6DAA6D;QAC7D,MAAM;IAgDR,GAAG,EAAE;IAEL,OAAO;QAAE;IAAW;AACtB"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useUnifiedSocket.ts"],"sourcesContent":["import { useEffect, useState, useCallback, useRef } from 'react'\nimport { io, Socket } from 'socket.io-client'\nimport { getApiUrl } from '@/lib/config'\nimport { apiService, PendingWorkflow } from '@/lib/api-service'\nimport { useNotificationStore } from '@/components/ui/global-notification'\n\nexport interface VideoStatusUpdate {\n  videoId: string\n  status: 'pending' | 'processing' | 'completed' | 'success' | 'failed'\n  message: string\n  downloadUrl?: string\n  timestamp: string\n}\n\nexport interface AvatarStatusUpdate {\n  step: string\n  status: 'progress' | 'success' | 'error'\n  data?: {\n    message: string\n    error?: string\n    avatarId?: string\n    previewImageUrl?: string\n  }\n  timestamp: string\n}\n\nexport interface VideoAvatarStatusUpdate {\n  notificationId: string\n  avatarId: string\n  step: string\n  status: 'progress' | 'completed' | 'error'\n  data?: {\n    message: string\n    error?: string\n    avatarId?: string\n    progress?: number\n    avatar_name?: string\n    preview_image_url?: string\n    preview_video_url?: string\n    default_voice_id?: string\n  }\n  timestamp: string\n}\n\nexport interface ScheduleStatusUpdate {\n  scheduleId: string\n  status: 'processing' | 'ready' | 'failed'\n  message: string\n  data?: {\n    scheduleId?: string\n    error?: string\n    generationTime?: number\n  }\n  timestamp: string\n}\n\nexport interface VideoInProgress {\n  id: string\n  title: string\n  status: 'processing'\n  timestamp: string\n  message: string\n}\n\nexport interface UnifiedSocketState {\n  socket: Socket | null\n  isConnected: boolean\n  videoUpdates: VideoStatusUpdate[]\n  avatarUpdates: AvatarStatusUpdate[]\n  videoAvatarUpdates: VideoAvatarStatusUpdate[]\n  scheduleUpdates: ScheduleStatusUpdate[]\n  latestVideoUpdate: VideoStatusUpdate | null\n  latestAvatarUpdate: AvatarStatusUpdate | null\n  latestVideoAvatarUpdate: VideoAvatarStatusUpdate | null\n  latestScheduleUpdate: ScheduleStatusUpdate | null\n  isVideoProcessing: boolean\n  isAvatarProcessing: boolean\n  isVideoAvatarProcessing: boolean\n  isScheduleProcessing: boolean\n  pendingVideos: VideoInProgress[]\n  addPendingVideo: (video: VideoInProgress) => void\n  removePendingVideo: () => void\n  clearVideoUpdates: () => void\n  clearCompletedVideoUpdates: () => void\n  clearAvatarUpdates: () => void\n  clearVideoAvatarUpdates: () => void\n  clearScheduleUpdates: () => void\n  syncPendingVideos: (userId: string) => Promise<void>\n}\n\nconst PENDING_VIDEOS_KEY = 'pendingVideos'\n\nexport const useUnifiedSocket = (userId: string | null): UnifiedSocketState => {\n  const [socket, setSocket] = useState<Socket | null>(null)\n  const [isConnected, setIsConnected] = useState(false)\n  const [videoUpdates, setVideoUpdates] = useState<VideoStatusUpdate[]>([])\n  const [avatarUpdates, setAvatarUpdates] = useState<AvatarStatusUpdate[]>([])\n  const [videoAvatarUpdates, setVideoAvatarUpdates] = useState<VideoAvatarStatusUpdate[]>([])\n  const [scheduleUpdates, setScheduleUpdates] = useState<ScheduleStatusUpdate[]>([])\n  const [pendingVideos, setPendingVideos] = useState<VideoInProgress[]>([])\n  const { showNotification } = useNotificationStore()\n  \n  // Track processed events to prevent duplicates\n  const processedEvents = useRef(new Set<string>())\n  const socketConnectedHandlers = useRef<Set<() => void>>(new Set())\n  // Track if we've synced with DB to avoid duplicate syncing\n  const hasSyncedWithDB = useRef(false)\n  // Track if we should skip saving to localStorage (to prevent overwriting after DB sync)\n  const skipSaveToLocalStorage = useRef(false)\n  // Track failed videos to avoid duplicate notifications\n  const notifiedFailedVideos = useRef(new Set<string>())\n  // Track completed videos to avoid duplicate notifications\n  const notifiedCompletedVideos = useRef(new Set<string>())\n\n  const clearVideoUpdates = useCallback(() => {\n    setVideoUpdates([])\n  }, [])\n\n  const clearCompletedVideoUpdates = useCallback(() => {\n    setVideoUpdates(prev => prev.filter(update => \n      update.status !== 'completed' && update.status !== 'success' && update.status !== 'failed'\n    ))\n  }, [])\n\n  const clearAvatarUpdates = useCallback(() => {\n    setAvatarUpdates([])\n  }, [])\n\n  const clearVideoAvatarUpdates = useCallback(() => {\n    setVideoAvatarUpdates([])\n  }, [])\n\n  const clearScheduleUpdates = useCallback(() => {\n    setScheduleUpdates([])\n  }, [])\n\n  const addPendingVideo = useCallback((video: VideoInProgress) => {\n    setPendingVideos(prev => [...prev, video])\n    console.log('âž• Added pending video:', video)\n  }, [])\n\n  const removePendingVideo = useCallback(() => {\n    setPendingVideos(prev => {\n      if (prev.length === 0) {\n        console.log('âš ï¸ No pending videos to remove')\n        return prev\n      }\n      const removed = prev[0]\n      const remaining = prev.slice(1)\n      console.log('âž– Removed pending video (FIFO):', removed)\n      return remaining\n    })\n  }, [])\n\n  // Sync pending videos with database - DB is the source of truth\n  const syncPendingVideos = useCallback(async (userId: string) => {\n    try {\n      console.log('ðŸ” Syncing pending videos with DB for user:', userId)\n      const result = await apiService.checkPendingWorkflows(userId)\n      \n      if (result.success && result.data) {\n        const { workflows } = result.data\n        \n        // Log all workflows to debug status values\n        console.log('ðŸ“Š All workflows from DB:', workflows.map((w: PendingWorkflow) => ({ \n          id: w._id, \n          status: w.status, \n          title: w.title \n        })))\n        \n        // Check for failed workflows and show notifications\n        // Collect notifications to show after state update (to avoid React warning)\n        const notificationsToShow: Array<{ message: string; type: 'error' | 'success' }> = []\n        \n        // Use functional update to access current pending videos\n        setPendingVideos(prev => {\n          // Create a map of current video IDs (both DB format and temporary format)\n          const currentVideoIds = new Set<string>()\n          const currentVideoTitles = new Map<string, string>() // Map title to video ID\n          \n          prev.forEach(v => {\n            currentVideoIds.add(v.id)\n            currentVideoTitles.set(v.title, v.id)\n            \n            // Also extract workflow ID if it's in DB format (video-{_id}-{executionId})\n            const match = v.id.match(/^video-(.+)-(.+)$/)\n            if (match) {\n              currentVideoIds.add(match[1]) // Add workflow _id\n            }\n          })\n          \n          // Find failed workflows\n          const failedWorkflows = workflows.filter(\n            (workflow: PendingWorkflow) => workflow.status === 'failed'\n          )\n          \n          // Collect failed video notifications (only once per video)\n          failedWorkflows.forEach((workflow: PendingWorkflow) => {\n            const workflowId = workflow._id\n            const videoId = `video-${workflow._id}-${workflow.executionId}`\n            const videoTitle = workflow.title || 'Video'\n            \n            // Check if this failed workflow matches any current pending video\n            // Match by: workflow _id, video ID format, or title\n            const matchesCurrentVideo = \n              currentVideoIds.has(workflowId) || \n              currentVideoIds.has(videoId) ||\n              currentVideoTitles.has(videoTitle)\n            \n            if (matchesCurrentVideo && !notifiedFailedVideos.current.has(videoId)) {\n              notifiedFailedVideos.current.add(videoId)\n              notificationsToShow.push({\n                message: `Video \"${videoTitle}\" creation failed. Please try creating it again.`,\n                type: 'error'\n              })\n              console.log('âŒ Video failed:', videoTitle, workflow._id)\n            }\n          })\n          \n          // Find completed workflows\n          const completedWorkflows = workflows.filter(\n            (workflow: PendingWorkflow) => workflow.status === 'completed'\n          )\n          \n          // Collect completed video notifications (only once per video)\n          completedWorkflows.forEach((workflow: PendingWorkflow) => {\n            const workflowId = workflow._id\n            const videoId = `video-${workflow._id}-${workflow.executionId}`\n            const videoTitle = workflow.title || 'Video'\n            \n            // Check if this completed workflow matches any current pending video\n            // Match by: workflow _id, video ID format, or title\n            const matchesCurrentVideo = \n              currentVideoIds.has(workflowId) || \n              currentVideoIds.has(videoId) ||\n              currentVideoTitles.has(videoTitle)\n            \n            if (matchesCurrentVideo && !notifiedCompletedVideos.current.has(videoId)) {\n              notifiedCompletedVideos.current.add(videoId)\n              notificationsToShow.push({\n                message: `Video \"${videoTitle}\" is ready! You can view it in your gallery.`,\n                type: 'success'\n              })\n              console.log('âœ… Video completed:', videoTitle, workflow._id)\n            }\n          })\n          \n          return prev // Return unchanged for now, we'll update below\n        })\n        \n        // Show notifications after state update (defer to avoid React warning)\n        if (notificationsToShow.length > 0) {\n          setTimeout(() => {\n            notificationsToShow.forEach(({ message, type }) => {\n              showNotification(message, type, type === 'error' ? 15000 : undefined)\n            })\n          }, 0)\n        }\n        \n        // Filter workflows that are not completed or failed (include all active states)\n        const pendingWorkflows = workflows.filter(\n          (workflow: PendingWorkflow) => \n            workflow.status !== 'completed' && workflow.status !== 'failed'\n        )\n        \n        console.log('ðŸ“Š Found pending workflows from DB:', pendingWorkflows.length, 'workflows')\n        \n        // DB is the source of truth - always sync with DB\n        if (typeof window !== 'undefined') {\n          // Create videos from DB workflows\n          const videosFromDB: VideoInProgress[] = pendingWorkflows.map((workflow: PendingWorkflow, index: number) => ({\n            id: `video-${workflow._id}-${workflow.executionId}`,\n            title: workflow.title || `Video ${index + 1}`,\n            status: 'processing',\n            timestamp: workflow.createdAt || new Date().toISOString(),\n            message: 'Your video creation is in progress'\n          }))\n          \n          // Remove failed videos from pending list (they're already filtered out above)\n          // This will automatically remove them from toasts and tiles\n          skipSaveToLocalStorage.current = true\n          setPendingVideos(videosFromDB)\n          hasSyncedWithDB.current = true\n          console.log('âœ… Synced pending videos with DB (source of truth):', videosFromDB.length, 'videos')\n          \n          // Clean up notified failed/completed videos that are no longer in the system\n          const currentVideoIds = new Set(videosFromDB.map(v => v.id))\n          notifiedFailedVideos.current.forEach(videoId => {\n            if (!currentVideoIds.has(videoId)) {\n              // Keep in set for a while to avoid duplicate notifications if user creates same video again\n              // Will be cleaned up on logout or after some time\n            }\n          })\n          notifiedCompletedVideos.current.forEach(videoId => {\n            if (!currentVideoIds.has(videoId)) {\n              // Keep in set for a while to avoid duplicate notifications if user creates same video again\n              // Will be cleaned up on logout or after some time\n            }\n          })\n          \n          // Reset skip flag after a short delay\n          setTimeout(() => {\n            skipSaveToLocalStorage.current = false\n          }, 100)\n        }\n      } else {\n        // If DB check fails, try to load from localStorage as fallback\n        if (typeof window !== 'undefined' && !hasSyncedWithDB.current) {\n          try {\n            const saved = localStorage.getItem(PENDING_VIDEOS_KEY)\n            if (saved) {\n              const parsed = JSON.parse(saved) as VideoInProgress[]\n              if (Array.isArray(parsed) && parsed.length > 0) {\n                skipSaveToLocalStorage.current = true\n                setPendingVideos(parsed)\n                console.log('ðŸ“¦ Loaded pending videos from localStorage (DB unavailable):', parsed.length, 'videos')\n                setTimeout(() => {\n                  skipSaveToLocalStorage.current = false\n                }, 100)\n              }\n            }\n          } catch (error) {\n            console.warn('Failed to load pending videos from localStorage:', error)\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to sync pending videos:', error)\n      // Fallback to localStorage if DB sync fails\n      if (typeof window !== 'undefined' && !hasSyncedWithDB.current) {\n        try {\n          const saved = localStorage.getItem(PENDING_VIDEOS_KEY)\n          if (saved) {\n            const parsed = JSON.parse(saved) as VideoInProgress[]\n            if (Array.isArray(parsed) && parsed.length > 0) {\n              skipSaveToLocalStorage.current = true\n              setPendingVideos(parsed)\n              console.log('ðŸ“¦ Loaded pending videos from localStorage (fallback):', parsed.length, 'videos')\n              setTimeout(() => {\n                skipSaveToLocalStorage.current = false\n              }, 100)\n            }\n          }\n        } catch (err) {\n          console.warn('Failed to load pending videos from localStorage:', err)\n        }\n      }\n    }\n  }, [showNotification])\n\n  // Initial sync with DB on mount if userId is available\n  useEffect(() => {\n    if (userId && !hasSyncedWithDB.current) {\n      console.log('ðŸ”„ Initial sync with DB on mount')\n      syncPendingVideos(userId)\n    }\n  }, [userId, syncPendingVideos])\n\n  // Continuous polling every 20 seconds regardless of connection status\n  useEffect(() => {\n    if (!userId) return\n\n    const pollInterval = setInterval(() => {\n      console.log('ðŸ”„ Periodic polling: syncing pending videos with DB (every 20s)')\n      syncPendingVideos(userId)\n    }, 60000) // Poll every 60 seconds continuously\n\n    return () => clearInterval(pollInterval)\n  }, [userId, syncPendingVideos])\n\n  // Save pending videos to localStorage whenever they change\n  useEffect(() => {\n    if (userId && typeof window !== 'undefined' && !skipSaveToLocalStorage.current) {\n      try {\n        if (pendingVideos.length > 0) {\n          localStorage.setItem(PENDING_VIDEOS_KEY, JSON.stringify(pendingVideos))\n          console.log('ðŸ’¾ Saved pending videos to localStorage:', pendingVideos.length, 'videos')\n        } else {\n          localStorage.removeItem(PENDING_VIDEOS_KEY)\n          console.log('ðŸ§¹ Cleared pending videos from localStorage')\n        }\n      } catch (error) {\n        console.warn('Failed to save pending videos to localStorage:', error)\n      }\n    } else if (skipSaveToLocalStorage.current) {\n      console.log('â­ï¸ Skipping save to localStorage (just synced with DB)')\n    }\n  }, [pendingVideos, userId])\n\n  // Get latest updates\n  const latestVideoUpdate = videoUpdates.length > 0 ? videoUpdates[videoUpdates.length - 1] : null\n  const latestAvatarUpdate = avatarUpdates.length > 0 ? avatarUpdates[avatarUpdates.length - 1] : null\n  const latestVideoAvatarUpdate = videoAvatarUpdates.length > 0 ? videoAvatarUpdates[videoAvatarUpdates.length - 1] : null\n  const latestScheduleUpdate = scheduleUpdates.length > 0 ? scheduleUpdates[scheduleUpdates.length - 1] : null\n\n  // Check processing states\n  const isVideoProcessing = videoUpdates.some(update => \n    update.status === 'pending' || update.status === 'processing'\n  )\n  const isAvatarProcessing = avatarUpdates.some(update => \n    update.status === 'progress' && update.step !== 'ready'\n  )\n  const isVideoAvatarProcessing = videoAvatarUpdates.some(update => \n    update.status === 'progress'\n  )\n  const isScheduleProcessing = scheduleUpdates.some(update => \n    update.status === 'processing'\n  )\n\n  useEffect(() => {\n    if (!userId) {\n      // Clean up socket and clear all data if no user\n      if (socket) {\n        socket.close()\n        setSocket(null)\n        setIsConnected(false)\n      }\n      setVideoUpdates([])\n      setAvatarUpdates([])\n      setVideoAvatarUpdates([])\n      setScheduleUpdates([])\n      \n      // Only clear pendingVideos if this is a real logout (socket exists)\n      // Don't clear on initial mount when userId is temporarily null\n      if (socket) {\n        // This is a real logout (socket exists), clear everything\n        setPendingVideos([])\n        if (typeof window !== 'undefined') {\n          try {\n            localStorage.removeItem(PENDING_VIDEOS_KEY)\n            console.log('ðŸ§¹ Cleared pending videos from localStorage on logout')\n          } catch (error) {\n            console.warn('Failed to clear pending videos from localStorage:', error)\n          }\n        }\n        hasSyncedWithDB.current = false\n        notifiedFailedVideos.current.clear()\n        notifiedCompletedVideos.current.clear()\n        console.log('ðŸ§¹ User logged out - cleared all socket data')\n      } else {\n        // This is initial mount (no socket yet), sync with DB instead of clearing\n        console.log('â­ï¸ Initial mount - will sync pending videos with DB on connection')\n      }\n      \n      processedEvents.current.clear()\n      socketConnectedHandlers.current.clear()\n      return\n    }\n\n    // Get backend URL from config\n    const backendUrl = getApiUrl('').replace('/api', '')\n    console.log('ðŸ”Œ Unified WebSocket connecting to:', backendUrl)\n    \n    // Create new socket connection\n    const newSocket = io(backendUrl, {\n      transports: ['websocket'],\n      autoConnect: true,\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n    })\n\n    // Connection event handlers\n    newSocket.on('connect', () => {\n      console.log('ðŸ”Œ Unified WebSocket connected')\n      setIsConnected(true)\n      \n      // Join user-specific room\n      newSocket.emit('join-room', userId)\n      console.log(`ðŸ  Joined room for user: ${userId}`)\n      \n      // Emit test connection\n      newSocket.emit('test-connection', { userId, timestamp: new Date().toISOString() })\n      \n      // Trigger socket connected event for any registered handlers\n      socketConnectedHandlers.current.forEach(handler => {\n        try {\n          handler()\n        } catch (error) {\n          console.error('Error in socket connected handler:', error)\n        }\n      })\n      \n      // Sync pending videos with DB after connection (DB is source of truth)\n      syncPendingVideos(userId)\n    })\n\n    newSocket.on('disconnect', (reason: any) => {\n      console.log('ðŸ”Œ Unified WebSocket disconnected:', reason)\n      setIsConnected(false)\n    })\n\n    newSocket.on('connect_error', (error: any) => {\n      console.error('ðŸ”Œ Unified WebSocket connection error:', error)\n      setIsConnected(false)\n    })\n\n    newSocket.on('reconnect', (attemptNumber: number) => {\n      console.log(`ðŸ”Œ Unified WebSocket reconnected after ${attemptNumber} attempts`)\n      setIsConnected(true)\n      newSocket.emit('join-room', userId)\n      \n      // Trigger socket connected event for reconnection\n      socketConnectedHandlers.current.forEach(handler => {\n        try {\n          handler()\n        } catch (error) {\n          console.error('Error in socket reconnected handler:', error)\n        }\n      })\n      \n      // Sync pending videos with DB after reconnection (DB is source of truth)\n      syncPendingVideos(userId)\n    })\n\n    // Video status updates\n    newSocket.on('video-download-update', (update: any) => {\n      console.log('ðŸŽ¥ Video update received:', update)\n      \n      // Handle both videoId and id fields, and allow processing without strict videoId validation\n      const videoId = update.videoId || update.id || 'processing-video'\n      \n      const eventKey = `video-${videoId}-${update.timestamp || Date.now()}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸŽ¥ Duplicate video event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      \n      // Map the socket event format to our internal format\n      let status = update.status || update.type || 'pending'\n      \n      // Handle the specific case where type: 'progress' should map to status: 'processing'\n      if (update.type === 'progress' && update.status === 'processing') {\n        status = 'processing'\n      } else if (update.type === 'progress') {\n        status = 'processing'\n      }\n      \n      const videoUpdate: VideoStatusUpdate = {\n        videoId: videoId,\n        status: status as 'pending' | 'processing' | 'completed' | 'success' | 'failed',\n        message: update.message || update.data?.message || 'Video processing update',\n        downloadUrl: update.downloadUrl || update.data?.downloadUrl,\n        timestamp: update.timestamp || new Date().toISOString()\n      }\n      \n      console.log('ðŸŽ¥ Processed video update:', videoUpdate)\n      setVideoUpdates(prev => [...prev, videoUpdate])\n\n      // Add video to progress tracking when processing status arrives\n      // Only add if we don't have videos from DB sync (to avoid duplicates)\n      if (status === 'processing' || status === 'pending') {\n        // If we synced with DB, don't add from socket events - DB is source of truth\n        if (hasSyncedWithDB.current) {\n          console.log('ðŸ“¦ Already synced with DB, skipping socket event addition (DB is source of truth)')\n          return\n        }\n        \n        setPendingVideos(prev => {\n          // If we already have videos, don't add duplicates\n          if (prev.length > 0) {\n            console.log('ðŸ“¦ Already have pending videos, skipping socket event addition')\n            return prev\n          }\n          \n          // Only add one video if we have no videos at all\n          const newVideo: VideoInProgress = {\n            id: `video-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            title: update.title || update.data?.title || 'Processing Video...',\n            status: 'processing',\n            timestamp: update.timestamp || new Date().toISOString(),\n            message: update.message || update.data?.message || 'Your video creation is in progress'\n          }\n          \n          console.log('âž• Added pending video from socket event:', newVideo)\n          return [...prev, newVideo]\n        })\n      }\n\n      // Remove one video from progress tracking when success/completed arrives (FIFO)\n      // Verify in DB first before removing\n      if (status === 'completed' || status === 'success') {\n        console.log('âœ… Video completed/success - verifying in DB before removing (FIFO)')\n        \n        // Helper function to show notification and remove video\n        const showNotificationAndRemove = (prev: VideoInProgress[], context: string) => {\n          if (prev.length === 0) {\n            return prev\n          }\n          const removed = prev[0]\n          const videoId = removed.id\n          const videoTitle = removed.title || 'Video'\n          \n          // Show notification if not already notified\n          if (!notifiedCompletedVideos.current.has(videoId)) {\n            notifiedCompletedVideos.current.add(videoId)\n            showNotification(\n              `Video \"${videoTitle}\" is ready! You can view it in your gallery.`,\n              'success'\n            )\n            console.log('âœ… Video completed notification shown:', videoTitle, videoId)\n          }\n          \n          const remaining = prev.slice(1)\n          console.log(`âž– Removed pending video (FIFO, ${context}):`, removed)\n          return remaining\n        }\n        \n        // Verify completion in DB before removing\n        if (userId) {\n          // First sync with DB to get latest state\n          syncPendingVideos(userId).then(() => {\n            // After DB sync, check if we should remove one video\n            // DB sync already updated the state, so we just need to verify count\n            apiService.checkPendingWorkflows(userId).then(result => {\n              if (result.success && result.data) {\n                const pendingWorkflows = result.data.workflows.filter(\n                  (workflow: PendingWorkflow) => \n                    workflow.status !== 'completed' && workflow.status !== 'failed'\n                )\n                \n                // Get current local state count\n                setPendingVideos(prev => {\n                  // Only remove if DB has fewer pending items than our local state\n                  if (pendingWorkflows.length < prev.length) {\n                    return showNotificationAndRemove(prev, 'DB verified')\n                  } else {\n                    console.log('â¸ï¸ DB verification: keeping pending videos (count matches)')\n                    return prev\n                  }\n                })\n              } else {\n                // If DB check fails, still remove (FIFO assumption)\n                setPendingVideos(prev => showNotificationAndRemove(prev, 'DB check failed'))\n              }\n            }).catch(() => {\n              // If DB check fails, still remove (FIFO assumption)\n              setPendingVideos(prev => showNotificationAndRemove(prev, 'DB error'))\n            })\n          }).catch(() => {\n            // If sync fails, still remove (FIFO assumption)\n            setPendingVideos(prev => showNotificationAndRemove(prev, 'sync failed'))\n          })\n        } else {\n          // No userId, just remove (FIFO)\n          setPendingVideos(prev => {\n            if (prev.length === 0) {\n              console.log('âš ï¸ No pending videos to remove')\n              return prev\n            }\n            return showNotificationAndRemove(prev, 'no userId')\n          })\n        }\n      }\n\n      // Remove one video from progress tracking when error/failed arrives (FIFO)\n      // Verify in DB first before removing\n      if (status === 'error' || status === 'failed') {\n        console.log('âŒ Video error/failed - verifying in DB before removing (FIFO)')\n        \n        // Helper function to show error notification and remove video\n        const showErrorNotificationAndRemove = (prev: VideoInProgress[], context: string, errorMessage?: string) => {\n          if (prev.length === 0) {\n            return prev\n          }\n          const removed = prev[0]\n          const videoId = removed.id\n          const videoTitle = removed.title || 'Video'\n          \n          // Show notification if not already notified\n          if (!notifiedFailedVideos.current.has(videoId)) {\n            notifiedFailedVideos.current.add(videoId)\n            // Use socket message if available, otherwise use user-friendly fallback\n            const message = errorMessage || `Video \"${videoTitle}\" creation failed. Please try creating it again.`\n            showNotification(message, 'error', 15000)\n            console.log('âŒ Video failed notification shown:', videoTitle, videoId, message)\n          }\n          \n          const remaining = prev.slice(1)\n          console.log(`âž– Removed pending video (FIFO, ${context}):`, removed)\n          return remaining\n        }\n        \n        // Get error message from socket update\n        const errorMessage = update.message || update.data?.message || undefined\n        \n        // Verify failure in DB before removing\n        if (userId) {\n          // First sync with DB to get latest state\n          syncPendingVideos(userId).then(() => {\n            // After DB sync, check if we should remove one video\n            // DB sync already updated the state, so we just need to verify count\n            apiService.checkPendingWorkflows(userId).then(result => {\n              if (result.success && result.data) {\n                const pendingWorkflows = result.data.workflows.filter(\n                  (workflow: PendingWorkflow) => \n                    workflow.status !== 'completed' && workflow.status !== 'failed'\n                )\n                \n                // Get current local state count\n                setPendingVideos(prev => {\n                  // Only remove if DB has fewer pending items than our local state\n                  if (pendingWorkflows.length < prev.length) {\n                    return showErrorNotificationAndRemove(prev, 'DB verified', errorMessage)\n                  } else {\n                    console.log('â¸ï¸ DB verification: keeping pending videos (count matches)')\n                    return prev\n                  }\n                })\n              } else {\n                // If DB check fails, still remove (FIFO assumption)\n                setPendingVideos(prev => showErrorNotificationAndRemove(prev, 'DB check failed', errorMessage))\n              }\n            }).catch(() => {\n              // If DB check fails, still remove (FIFO assumption)\n              setPendingVideos(prev => showErrorNotificationAndRemove(prev, 'DB error', errorMessage))\n            })\n          }).catch(() => {\n            // If sync fails, still remove (FIFO assumption)\n            setPendingVideos(prev => showErrorNotificationAndRemove(prev, 'sync failed', errorMessage))\n          })\n        } else {\n          // No userId, just remove (FIFO)\n          setPendingVideos(prev => {\n            if (prev.length === 0) {\n              console.log('âš ï¸ No pending videos to remove')\n              return prev\n            }\n            return showErrorNotificationAndRemove(prev, 'no userId', errorMessage)\n          })\n        }\n      }\n    })\n\n    // Avatar status updates\n    newSocket.on('photo-avatar-update', (update: AvatarStatusUpdate) => {\n      console.log('ðŸ“¸ Avatar update received:', update)\n      \n      const eventKey = `avatar-${update.step}-${update.timestamp}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸ“¸ Duplicate avatar event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      setAvatarUpdates(prev => [...prev, update])\n    })\n\n    // Avatar completion\n    newSocket.on('avatar-ready', (data: { avatarId: string; previewImageUrl?: string }) => {\n      console.log('âœ… Avatar ready:', data)\n      \n      const timestamp = new Date().toISOString()\n      const eventKey = `avatar-ready-${data.avatarId}-${timestamp}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸ“¸ Duplicate avatar-ready event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      \n      const completionUpdate: AvatarStatusUpdate = {\n        step: 'complete',\n        status: 'success',\n        data: {\n          message: 'Your avatar is ready!',\n          avatarId: data.avatarId,\n          previewImageUrl: data.previewImageUrl\n        },\n        timestamp: timestamp\n      }\n      \n      setAvatarUpdates(prev => [...prev, completionUpdate])\n    })\n\n    // Video Avatar status updates\n    newSocket.on('video-avatar-update', (update: VideoAvatarStatusUpdate) => {\n      console.log('ðŸŽ¬ Video Avatar update received:', update)\n      \n      const eventKey = `video-avatar-${update.step}-${update.timestamp}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸŽ¬ Duplicate video avatar event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      setVideoAvatarUpdates(prev => [...prev, update])\n      \n      // Auto-disconnect on completion or error as requested\n      if (update.status === 'completed' || update.status === 'error') {\n        console.log('ðŸŽ¬ Video avatar process finished, disconnecting socket')\n        setTimeout(() => {\n          newSocket.disconnect()\n        }, 1000) // Small delay to ensure final update is processed\n      }\n    })\n\n    // Schedule status updates\n    newSocket.on('schedule-status', (data: any) => {\n      console.log('ðŸ“… Schedule status update received:', data)\n      \n      const eventKey = `schedule-status-${data.scheduleId || 'unknown'}-${data.timestamp || Date.now()}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸ“… Duplicate schedule status event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n        console.log('data', data)\n      const scheduleUpdate: ScheduleStatusUpdate = {\n        scheduleId: data.data.scheduleId || 'unknown',\n        status: data.status === 'ready' ? 'ready' : data.status === 'failed' ? 'failed' : 'processing',\n        message: data.message || (data.status === 'ready' ? 'Your schedule is ready!' : data.status === 'failed' ? 'Schedule generation failed. Please try again.' : 'Schedule generation started.'),\n        data: {\n          scheduleId: data.data.scheduleId,\n          error: data.error,\n          generationTime: data.generationTime\n        },\n        timestamp: data.timestamp || new Date().toISOString()\n      }\n      \n      console.log('ðŸ“… Processed schedule status update:', scheduleUpdate)\n      setScheduleUpdates(prev => [...prev, scheduleUpdate])\n      \n      // Auto-disconnect on completion or failure as requested\n      if (data.status === 'ready' || data.status === 'failed') {\n        console.log('ðŸ“… Schedule generation finished, disconnecting socket')\n        setTimeout(() => {\n          newSocket.disconnect()\n        }, 1000) // Small delay to ensure final update is processed\n      }\n    })\n\n    setSocket(newSocket)\n\n    // Store references for cleanup\n    const currentProcessedEvents = processedEvents.current\n    const currentSocketHandlers = socketConnectedHandlers.current\n\n    // Cleanup function\n    return () => {\n      console.log('ðŸ§¹ Cleaning up unified WebSocket connection')\n      currentProcessedEvents.clear()\n      currentSocketHandlers.clear()\n      newSocket.close()\n    }\n  }, [userId, syncPendingVideos]) // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Expose method to register socket connected handlers\n  useEffect(() => {\n    if (socket) {\n      // Add method to socket for external handlers\n      (socket as any).onSocketConnected = (handler: () => void) => {\n        socketConnectedHandlers.current.add(handler)\n        return () => {\n          socketConnectedHandlers.current.delete(handler)\n        }\n      }\n    }\n  }, [socket])\n\n  return {\n    socket,\n    isConnected,\n    videoUpdates,\n    avatarUpdates,\n    videoAvatarUpdates,\n    scheduleUpdates,\n    latestVideoUpdate,\n    latestAvatarUpdate,\n    latestVideoAvatarUpdate,\n    latestScheduleUpdate,\n    isVideoProcessing,\n    isAvatarProcessing,\n    isVideoAvatarProcessing,\n    isScheduleProcessing,\n    pendingVideos,\n    addPendingVideo,\n    removePendingVideo,\n    clearVideoUpdates,\n    clearCompletedVideoUpdates,\n    clearAvatarUpdates,\n    clearVideoAvatarUpdates,\n    clearScheduleUpdates,\n    syncPendingVideos\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1111, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useProcessingToasts.ts"],"sourcesContent":["import { useState, useCallback, useMemo } from 'react'\nimport { VideoInProgress } from './useUnifiedSocket'\n\nexport interface ProcessingToast {\n  id: string\n  title: string\n  message: string\n  timestamp: string\n  minimized: boolean\n}\n\nexport interface UseProcessingToastsReturn {\n  toasts: ProcessingToast[]\n  minimizedCount: number\n  minimizeToast: (id: string) => void\n  restoreToast: (id: string) => void\n  updateToasts: (videos: VideoInProgress[]) => void\n}\n\nexport function useProcessingToasts(): UseProcessingToastsReturn {\n  const [toasts, setToasts] = useState<ProcessingToast[]>([])\n\n  // Convert VideoInProgress[] to ProcessingToast[] and merge with existing minimize states\n  const updateToasts = useCallback((videos: VideoInProgress[]) => {\n    setToasts(prev => {\n      // Create a map of existing minimize states by ID\n      const minimizedMap = new Map<string, boolean>()\n      prev.forEach(toast => {\n        minimizedMap.set(toast.id, toast.minimized)\n      })\n\n      // Convert videos to toasts, preserving minimize state if toast already exists\n      const newToasts: ProcessingToast[] = videos.map(video => ({\n        id: video.id,\n        title: video.title,\n        message: video.message,\n        timestamp: video.timestamp,\n        minimized: minimizedMap.get(video.id) ?? false // Preserve existing minimize state or default to false\n      }))\n\n      // Return only toasts for videos that are still pending\n      // All toasts (including minimized ones) are removed when their video completes/fails\n      return newToasts\n    })\n  }, [])\n\n  const minimizeToast = useCallback((id: string) => {\n    setToasts(prev => \n      prev.map(toast => \n        toast.id === id ? { ...toast, minimized: true } : toast\n      )\n    )\n  }, [])\n\n  const restoreToast = useCallback((id: string) => {\n    setToasts(prev => \n      prev.map(toast => \n        toast.id === id ? { ...toast, minimized: false } : toast\n      )\n    )\n  }, [])\n\n  const minimizedCount = useMemo(() => {\n    return toasts.filter(toast => toast.minimized).length\n  }, [toasts])\n\n  return {\n    toasts,\n    minimizedCount,\n    minimizeToast,\n    restoreToast,\n    updateToasts\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;;AAmBO,SAAS;IACd,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,qOAAQ,EAAoB,EAAE;IAE1D,yFAAyF;IACzF,MAAM,eAAe,IAAA,wOAAW,EAAC,CAAC;QAChC,UAAU,CAAA;YACR,iDAAiD;YACjD,MAAM,eAAe,IAAI;YACzB,KAAK,OAAO,CAAC,CAAA;gBACX,aAAa,GAAG,CAAC,MAAM,EAAE,EAAE,MAAM,SAAS;YAC5C;YAEA,8EAA8E;YAC9E,MAAM,YAA+B,OAAO,GAAG,CAAC,CAAA,QAAS,CAAC;oBACxD,IAAI,MAAM,EAAE;oBACZ,OAAO,MAAM,KAAK;oBAClB,SAAS,MAAM,OAAO;oBACtB,WAAW,MAAM,SAAS;oBAC1B,WAAW,aAAa,GAAG,CAAC,MAAM,EAAE,KAAK,MAAM,uDAAuD;gBACxG,CAAC;YAED,uDAAuD;YACvD,qFAAqF;YACrF,OAAO;QACT;IACF,GAAG,EAAE;IAEL,MAAM,gBAAgB,IAAA,wOAAW,EAAC,CAAC;QACjC,UAAU,CAAA,OACR,KAAK,GAAG,CAAC,CAAA,QACP,MAAM,EAAE,KAAK,KAAK;oBAAE,GAAG,KAAK;oBAAE,WAAW;gBAAK,IAAI;IAGxD,GAAG,EAAE;IAEL,MAAM,eAAe,IAAA,wOAAW,EAAC,CAAC;QAChC,UAAU,CAAA,OACR,KAAK,GAAG,CAAC,CAAA,QACP,MAAM,EAAE,KAAK,KAAK;oBAAE,GAAG,KAAK;oBAAE,WAAW;gBAAM,IAAI;IAGzD,GAAG,EAAE;IAEL,MAAM,iBAAiB,IAAA,oOAAO,EAAC;QAC7B,OAAO,OAAO,MAAM,CAAC,CAAA,QAAS,MAAM,SAAS,EAAE,MAAM;IACvD,GAAG;QAAC;KAAO;IAEX,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 1169, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useVideoUpload.ts"],"sourcesContent":["import { useRef, useState } from 'react';\n\nexport interface ValidationError {\n  type: string;\n  message: string;\n}\n\nexport interface VideoUploadState {\n  file: File | null;\n  preview: string | null;\n  isValidating: boolean;\n  isValid: boolean;\n  errors: ValidationError[];\n}\n\nexport const useVideoUpload = () => {\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const dragCounterRef = useRef<Map<string, number>>(new Map());\n\n  const [isDragging, setIsDragging] = useState<string | null>(null);\n  const [uploadState, setUploadState] = useState<VideoUploadState>({\n    file: null,\n    preview: null,\n    isValidating: false,\n    isValid: false,\n    errors: []\n  });\n\n  const validateVideo = (file: File, type: 'consent' | 'training'): Promise<boolean> => {\n    return new Promise((resolve) => {\n      const errors: ValidationError[] = [];\n\n      if (type === 'training') {\n        const maxSize = 1000 * 1024 * 1024;\n        if (file.size > maxSize) {\n          const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);\n          errors.push({\n            type: 'size',\n            message: `File size exceeds maximum limit of 1000MB (${fileSizeMB}MB)`\n          });\n          setUploadState(prev => ({\n            ...prev,\n            isValidating: false,\n            isValid: false,\n            errors\n          }));\n          resolve(false);\n          return;\n        }\n      }\n\n      if (file.type !== 'video/mp4' && file.type !== 'video/quicktime') {\n        errors.push({\n          type: 'format',\n          message: 'Only MP4 or MOV format is supported'\n        });\n      }\n\n      const video = document.createElement('video');\n      video.preload = 'metadata';\n\n      video.onloadedmetadata = () => {\n        window.URL.revokeObjectURL(video.src);\n\n        if (type === 'consent') {\n          if (video.duration > 20) {\n            errors.push({\n              type: 'duration',\n              message: `Consent video is too long (${Math.round(video.duration)}s). Maximum duration is 20 seconds`\n            });\n          }\n        } else if (type === 'training') {\n          if (video.duration < 30) {\n            errors.push({\n              type: 'duration',\n              message: `Training video is too short (${Math.round(video.duration)}s). Minimum duration is 30 seconds`\n            });\n          }\n          if (video.duration > 240) {\n            errors.push({\n              type: 'duration',\n              message: `Training video is too long (${Math.round(video.duration)}s). Maximum duration is 4 minutes`\n            });\n          }\n        }\n\n        if (video.videoHeight < 720) {\n          errors.push({\n            type: 'quality',\n            message: `Video quality is too low (${video.videoWidth}x${video.videoHeight}). Minimum height is 720px`\n          });\n        }\n\n        setUploadState(prev => ({\n          ...prev,\n          isValidating: false,\n          isValid: errors.length === 0,\n          errors\n        }));\n\n        resolve(errors.length === 0);\n      };\n\n      video.onerror = () => {\n        errors.push({\n          type: 'error',\n          message: 'Failed to load video file'\n        });\n        setUploadState(prev => ({\n          ...prev,\n          isValidating: false,\n          isValid: false,\n          errors\n        }));\n        resolve(false);\n      };\n\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  const handleFileSelect = async (file: File, type: 'consent' | 'training') => {\n    setUploadState(prev => ({\n      ...prev,\n      isValidating: true,\n      isValid: false,\n      errors: []\n    }));\n\n    const preview = URL.createObjectURL(file);\n    setUploadState(prev => ({\n      ...prev,\n      file,\n      preview\n    }));\n\n    await validateVideo(file, type);\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>, type: 'consent' | 'training') => {\n    if (e.target.files && e.target.files[0]) {\n      handleFileSelect(e.target.files[0], type);\n    }\n  };\n\n  const handleDragEnter = (e: React.DragEvent, type: string) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const currentCount = dragCounterRef.current.get(type) || 0;\n    const newCount = currentCount + 1;\n    dragCounterRef.current.set(type, newCount);\n    \n    // Only set dragging state when entering the drop zone (counter goes from 0 to 1)\n    if (newCount === 1) {\n      setIsDragging(type);\n    }\n  };\n\n  const handleDragLeave = (e: React.DragEvent, type: string) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const currentCount = dragCounterRef.current.get(type) || 0;\n    const newCount = Math.max(0, currentCount - 1);\n    dragCounterRef.current.set(type, newCount);\n    \n    // Only clear dragging state when truly leaving the drop zone (counter reaches 0)\n    if (newCount === 0) {\n      setIsDragging(null);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  const handleDrop = (e: React.DragEvent, type: 'consent' | 'training') => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Reset counter and clear dragging state\n    dragCounterRef.current.set(type, 0);\n    setIsDragging(null);\n\n    const files = e.dataTransfer.files;\n    if (files && files[0]) {\n      console.log('ðŸ“ File selected from drop:', files[0]);\n      handleFileSelect(files[0], type);\n    } else {\n      console.log('âŒ No files in drop event');\n    }\n  };\n\n  const clearSelection = () => {\n    setUploadState({\n      file: null,\n      preview: null,\n      isValidating: false,\n      isValid: false,\n      errors: []\n    });\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  const getBorderClasses = (type: string) => {\n    if (isDragging === type) {\n      return 'border-[#6366F1] bg-[#6366F1]/5 border-2';\n    }\n    if (uploadState.errors.length > 0 && !uploadState.isValidating) {\n      return 'border-red-500';\n    }\n    if (uploadState.isValid && !uploadState.isValidating) {\n      return 'border-green-500';\n    }\n    return 'border-[#D1D5DB]';\n  };\n\n  return {\n    fileInputRef,\n    videoRef,\n    uploadState,\n    isDragging,\n    handleFileSelect,\n    handleInputChange,\n    handleDragEnter,\n    handleDragLeave,\n    handleDragOver,\n    handleDrop,\n    clearSelection,\n    getBorderClasses\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1372, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useSubscription.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { apiService, type SubscriptionData } from '@/lib/api-service'\n\nexport interface SubscriptionUsage {\n  videoCount: number\n  videoLimit: number\n  isLimitReached: boolean\n  remainingVideos: number\n  usagePercentage: number\n}\n\nexport const useSubscription = () => {\n  const [subscription, setSubscription] = useState<SubscriptionData | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const fetchSubscription = useCallback(async (): Promise<SubscriptionData | null> => {\n    try {\n      setLoading(true)\n      setError(null)\n      \n      const response = await apiService.getCurrentSubscription()\n      \n      if (response.success && response.data?.subscription) {\n        const subscriptionData = response.data.subscription\n        setSubscription(subscriptionData)\n        return subscriptionData\n      } else {\n        setError(response.message || 'Failed to fetch subscription details')\n        return null\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to load subscription details'\n      setError(errorMessage)\n      return null\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const getUsageInfo = useCallback((subscriptionData?: SubscriptionData): SubscriptionUsage => {\n    const data = subscriptionData || subscription\n    if (!data) {\n      return {\n        videoCount: 0,\n        videoLimit: 0,\n        isLimitReached: true,\n        remainingVideos: 0,\n        usagePercentage: 100\n      }\n    }\n\n    const videoCount = data.videoCount || 0\n    const videoLimit = data.videoLimit || 0\n    const remainingVideos = Math.max(0, videoLimit - videoCount)\n    const isLimitReached = videoCount >= videoLimit\n    const usagePercentage = videoLimit > 0 ? (videoCount / videoLimit) * 100 : 0\n\n    return {\n      videoCount,\n      videoLimit,\n      isLimitReached,\n      remainingVideos,\n      usagePercentage\n    }\n  }, [subscription])\n\n  const checkVideoUsageLimit = useCallback(async (): Promise<{\n    canCreateVideo: boolean\n    usageInfo: SubscriptionUsage\n    message?: string\n  }> => {\n    const subscriptionData = await fetchSubscription()\n    const usageInfo = getUsageInfo(subscriptionData || undefined)\n\n    if (!subscriptionData) {\n      return {\n        canCreateVideo: false,\n        usageInfo,\n        message: 'No active subscription found. Please subscribe to create content.'\n      }\n    }\n\n    // Check if subscription status is pending\n    if (subscriptionData.status === 'pending') {\n      return {\n        canCreateVideo: false,\n        usageInfo,\n        message: 'Your payment is still being processed. Please wait for payment confirmation before creating videos.'\n      }\n    }\n\n    if (usageInfo.isLimitReached) {\n      return {\n        canCreateVideo: false,\n        usageInfo,\n        message: `You've reached your video limit (${usageInfo.videoCount}/${usageInfo.videoLimit}). Upgrade your subscription to create more videos.`\n      }\n    }\n\n    return {\n      canCreateVideo: true,\n      usageInfo,\n      message: `You have ${usageInfo.remainingVideos} videos remaining this period.`\n    }\n  }, [fetchSubscription, getUsageInfo])\n\n  return {\n    subscription,\n    loading,\n    error,\n    fetchSubscription,\n    getUsageInfo,\n    checkVideoUsageLimit\n  }\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAaO,MAAM,kBAAkB;IAC7B,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,qOAAQ,EAA0B;IAC1E,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,qOAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,qOAAQ,EAAgB;IAElD,MAAM,oBAAoB,IAAA,wOAAW,EAAC;QACpC,IAAI;YACF,WAAW;YACX,SAAS;YAET,MAAM,WAAW,MAAM,8JAAU,CAAC,sBAAsB;YAExD,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE,cAAc;gBACnD,MAAM,mBAAmB,SAAS,IAAI,CAAC,YAAY;gBACnD,gBAAgB;gBAChB,OAAO;YACT,OAAO;gBACL,SAAS,SAAS,OAAO,IAAI;gBAC7B,OAAO;YACT;QACF,EAAE,OAAO,KAAK;YACZ,MAAM,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;YAC1D,SAAS;YACT,OAAO;QACT,SAAU;YACR,WAAW;QACb;IACF,GAAG,EAAE;IAEL,MAAM,eAAe,IAAA,wOAAW,EAAC,CAAC;QAChC,MAAM,OAAO,oBAAoB;QACjC,IAAI,CAAC,MAAM;YACT,OAAO;gBACL,YAAY;gBACZ,YAAY;gBACZ,gBAAgB;gBAChB,iBAAiB;gBACjB,iBAAiB;YACnB;QACF;QAEA,MAAM,aAAa,KAAK,UAAU,IAAI;QACtC,MAAM,aAAa,KAAK,UAAU,IAAI;QACtC,MAAM,kBAAkB,KAAK,GAAG,CAAC,GAAG,aAAa;QACjD,MAAM,iBAAiB,cAAc;QACrC,MAAM,kBAAkB,aAAa,IAAI,AAAC,aAAa,aAAc,MAAM;QAE3E,OAAO;YACL;YACA;YACA;YACA;YACA;QACF;IACF,GAAG;QAAC;KAAa;IAEjB,MAAM,uBAAuB,IAAA,wOAAW,EAAC;QAKvC,MAAM,mBAAmB,MAAM;QAC/B,MAAM,YAAY,aAAa,oBAAoB;QAEnD,IAAI,CAAC,kBAAkB;YACrB,OAAO;gBACL,gBAAgB;gBAChB;gBACA,SAAS;YACX;QACF;QAEA,0CAA0C;QAC1C,IAAI,iBAAiB,MAAM,KAAK,WAAW;YACzC,OAAO;gBACL,gBAAgB;gBAChB;gBACA,SAAS;YACX;QACF;QAEA,IAAI,UAAU,cAAc,EAAE;YAC5B,OAAO;gBACL,gBAAgB;gBAChB;gBACA,SAAS,CAAC,iCAAiC,EAAE,UAAU,UAAU,CAAC,CAAC,EAAE,UAAU,UAAU,CAAC,mDAAmD,CAAC;YAChJ;QACF;QAEA,OAAO;YACL,gBAAgB;YAChB;YACA,SAAS,CAAC,SAAS,EAAE,UAAU,eAAe,CAAC,8BAA8B,CAAC;QAChF;IACF,GAAG;QAAC;QAAmB;KAAa;IAEpC,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 1479, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useSchedule.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { apiService } from '@/lib/api-service'\n\ninterface UseScheduleReturn {\n  scheduleData: any\n  scheduleLoading: boolean\n  scheduleError: string | null\n  fetchSchedule: () => Promise<void>\n  deleteSchedule: (scheduleId: string) => Promise<boolean>\n  clearScheduleData: () => void\n}\n\nexport const useSchedule = (): UseScheduleReturn => {\n  const [scheduleData, setScheduleData] = useState<any>(null)\n  const [scheduleLoading, setScheduleLoading] = useState(false)\n  const [scheduleError, setScheduleError] = useState<string | null>(null)\n\n  // Fetch schedule data\n  const fetchSchedule = useCallback(async () => {\n    try {\n      setScheduleLoading(true)\n      setScheduleError(null)\n      \n      const response = await apiService.getSchedule()\n      \n      if (response.success && response.data) {\n        setScheduleData(response.data)\n        console.log('Schedule data fetched successfully:', response.data)\n      } else {\n        setScheduleData(null)\n        // setScheduleError(response.message || 'Failed to fetch schedule data')\n      }\n    } catch (error: any) {\n      console.error('âŒ Error fetching schedule data:', error)\n      setScheduleData(null)\n      // setScheduleError(error.message || 'Failed to fetch schedule data')\n    } finally {\n      setScheduleLoading(false)\n    }\n  }, [])\n\n  // Delete schedule\n  const deleteSchedule = useCallback(async (scheduleId: string): Promise<boolean> => {\n    try {\n      setScheduleLoading(true)\n      setScheduleError(null)\n      const response = await apiService.deleteSchedule(scheduleId)\n      \n      if (response.success) {\n        console.log('Schedule deleted successfully')\n        \n        // Show success notification\n        if ((window as any).showNotification) {\n          (window as any).showNotification({\n            type: 'success',\n            title: 'Schedule Deleted',\n            message: 'Your schedule has been deleted successfully!',\n            duration: 5000\n          })\n        }\n        \n        // Refresh schedule data after successful deletion\n        await fetchSchedule()\n        \n        return true\n      } else {\n        console.error('Failed to delete schedule:', response.message)\n        \n        // Show error notification\n        if ((window as any).showNotification) {\n          (window as any).showNotification({\n            type: 'error',\n            title: 'Delete Failed',\n            message: response.message || 'Failed to delete schedule',\n            duration: 5000\n          })\n        }\n        \n        // setScheduleError(response.message || 'Failed to delete schedule')\n        return false\n      }\n    } catch (error: any) {\n      console.error('Error deleting schedule:', error)\n      \n      // Show error notification\n      if ((window as any).showNotification) {\n        (window as any).showNotification({\n          type: 'error',\n          title: 'Network Error',\n          message: 'Failed to delete schedule. Please try again.',\n          duration: 5000\n        })\n      }\n      \n      // setScheduleError(error.message || 'Failed to delete schedule')\n      return false\n    } finally {\n      setScheduleLoading(false)\n    }\n  }, [fetchSchedule])\n\n  // Clear schedule data\n  const clearScheduleData = useCallback(() => {\n    setScheduleData(null)\n    setScheduleError(null)\n  }, [])\n\n  return {\n    // State\n    scheduleData,\n    scheduleLoading,\n    scheduleError,\n    \n    // Actions\n    fetchSchedule,\n    deleteSchedule,\n    \n    // Utilities\n    clearScheduleData\n  }\n}\n\nexport default useSchedule\n"],"names":[],"mappings":";;;;;;AAEA;AACA;AAHA;;;AAcO,MAAM,cAAc;IACzB,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,qOAAQ,EAAM;IACtD,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,qOAAQ,EAAC;IACvD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,qOAAQ,EAAgB;IAElE,sBAAsB;IACtB,MAAM,gBAAgB,IAAA,wOAAW,EAAC;QAChC,IAAI;YACF,mBAAmB;YACnB,iBAAiB;YAEjB,MAAM,WAAW,MAAM,8JAAU,CAAC,WAAW;YAE7C,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;gBACrC,gBAAgB,SAAS,IAAI;gBAC7B,QAAQ,GAAG,CAAC,uCAAuC,SAAS,IAAI;YAClE,OAAO;gBACL,gBAAgB;YAChB,wEAAwE;YAC1E;QACF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,mCAAmC;YACjD,gBAAgB;QAChB,qEAAqE;QACvE,SAAU;YACR,mBAAmB;QACrB;IACF,GAAG,EAAE;IAEL,kBAAkB;IAClB,MAAM,iBAAiB,IAAA,wOAAW,EAAC,OAAO;QACxC,IAAI;YACF,mBAAmB;YACnB,iBAAiB;YACjB,MAAM,WAAW,MAAM,8JAAU,CAAC,cAAc,CAAC;YAEjD,IAAI,SAAS,OAAO,EAAE;gBACpB,QAAQ,GAAG,CAAC;gBAEZ,4BAA4B;gBAC5B,IAAI,AAAC,OAAe,gBAAgB,EAAE;oBACnC,OAAe,gBAAgB,CAAC;wBAC/B,MAAM;wBACN,OAAO;wBACP,SAAS;wBACT,UAAU;oBACZ;gBACF;gBAEA,kDAAkD;gBAClD,MAAM;gBAEN,OAAO;YACT,OAAO;gBACL,QAAQ,KAAK,CAAC,8BAA8B,SAAS,OAAO;gBAE5D,0BAA0B;gBAC1B,IAAI,AAAC,OAAe,gBAAgB,EAAE;oBACnC,OAAe,gBAAgB,CAAC;wBAC/B,MAAM;wBACN,OAAO;wBACP,SAAS,SAAS,OAAO,IAAI;wBAC7B,UAAU;oBACZ;gBACF;gBAEA,oEAAoE;gBACpE,OAAO;YACT;QACF,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,4BAA4B;YAE1C,0BAA0B;YAC1B,IAAI,AAAC,OAAe,gBAAgB,EAAE;gBACnC,OAAe,gBAAgB,CAAC;oBAC/B,MAAM;oBACN,OAAO;oBACP,SAAS;oBACT,UAAU;gBACZ;YACF;YAEA,iEAAiE;YACjE,OAAO;QACT,SAAU;YACR,mBAAmB;QACrB;IACF,GAAG;QAAC;KAAc;IAElB,sBAAsB;IACtB,MAAM,oBAAoB,IAAA,wOAAW,EAAC;QACpC,gBAAgB;QAChB,iBAAiB;IACnB,GAAG,EAAE;IAEL,OAAO;QACL,QAAQ;QACR;QACA;QACA;QAEA,UAAU;QACV;QACA;QAEA,YAAY;QACZ;IACF;AACF;uCAEe"}},
    {"offset": {"line": 1590, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useAvatarStorage.ts"],"sourcesContent":["'use client'\n\nimport { useCallback } from 'react'\n\nexport interface SelectedAvatar {\n  avatar_id: string\n  avatar_name: string\n  preview_image_url: string\n  avatarType?: 'video_avatar' | 'photo_avatar'\n}\n\nexport interface SelectedAvatars {\n  title: SelectedAvatar\n  body: SelectedAvatar\n  conclusion: SelectedAvatar\n}\n\nexport interface AvatarIds {\n  avatar_title: string\n  avatar_body: string\n  avatar_conclusion: string\n}\n\nexport const useAvatarStorage = () => {\n  const getSelectedAvatars = useCallback((): SelectedAvatars | null => {\n    try {\n      const saved = localStorage.getItem('selectedAvatars')\n      if (!saved) return null\n      \n      const parsed = JSON.parse(saved)\n      \n      // Validate the structure\n      if (!parsed.title || !parsed.body || !parsed.conclusion) {\n        console.warn('Invalid avatar data structure in localStorage')\n        return null\n      }\n      \n      return parsed\n    } catch (error) {\n      console.warn('Failed to parse avatar data from localStorage:', error)\n      return null\n    }\n  }, [])\n\n  const saveSelectedAvatars = useCallback((avatars: SelectedAvatars): void => {\n    try {\n      localStorage.setItem('selectedAvatars', JSON.stringify(avatars))\n    } catch (error) {\n      throw new Error('Failed to save avatar selection to localStorage')\n    }\n  }, [])\n\n  const getAvatarIds = useCallback((): AvatarIds | null => {\n    const avatars = getSelectedAvatars()\n    if (!avatars) return null\n\n    return {\n      avatar_title: avatars.title.avatar_id,\n      avatar_body: avatars.body.avatar_id,\n      avatar_conclusion: avatars.conclusion.avatar_id\n    }\n  }, [getSelectedAvatars])\n\n  const validateAvatarSelection = useCallback((avatarIds: AvatarIds): void => {\n    const required = ['avatar_title', 'avatar_body', 'avatar_conclusion'] as const\n    const missing = required.filter(key => !avatarIds[key] || avatarIds[key].trim() === '')\n    \n    if (missing.length > 0) {\n      throw new Error(`Missing avatar selection: ${missing.join(', ')}`)\n    }\n  }, [])\n\n  const clearSelectedAvatars = useCallback((): void => {\n    try {\n      localStorage.removeItem('selectedAvatars')\n    } catch {\n      console.warn('Failed to clear avatar data from localStorage')\n    }\n  }, [])\n\n  return {\n    getSelectedAvatars,\n    saveSelectedAvatars,\n    getAvatarIds,\n    validateAvatarSelection,\n    clearSelectedAvatars\n  }\n}\n"],"names":[],"mappings":";;;;AAEA;AAFA;;AAuBO,MAAM,mBAAmB;IAC9B,MAAM,qBAAqB,IAAA,wOAAW,EAAC;QACrC,IAAI;YACF,MAAM,QAAQ,aAAa,OAAO,CAAC;YACnC,IAAI,CAAC,OAAO,OAAO;YAEnB,MAAM,SAAS,KAAK,KAAK,CAAC;YAE1B,yBAAyB;YACzB,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,UAAU,EAAE;gBACvD,QAAQ,IAAI,CAAC;gBACb,OAAO;YACT;YAEA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,kDAAkD;YAC/D,OAAO;QACT;IACF,GAAG,EAAE;IAEL,MAAM,sBAAsB,IAAA,wOAAW,EAAC,CAAC;QACvC,IAAI;YACF,aAAa,OAAO,CAAC,mBAAmB,KAAK,SAAS,CAAC;QACzD,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM;QAClB;IACF,GAAG,EAAE;IAEL,MAAM,eAAe,IAAA,wOAAW,EAAC;QAC/B,MAAM,UAAU;QAChB,IAAI,CAAC,SAAS,OAAO;QAErB,OAAO;YACL,cAAc,QAAQ,KAAK,CAAC,SAAS;YACrC,aAAa,QAAQ,IAAI,CAAC,SAAS;YACnC,mBAAmB,QAAQ,UAAU,CAAC,SAAS;QACjD;IACF,GAAG;QAAC;KAAmB;IAEvB,MAAM,0BAA0B,IAAA,wOAAW,EAAC,CAAC;QAC3C,MAAM,WAAW;YAAC;YAAgB;YAAe;SAAoB;QACrE,MAAM,UAAU,SAAS,MAAM,CAAC,CAAA,MAAO,CAAC,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,OAAO;QAEpF,IAAI,QAAQ,MAAM,GAAG,GAAG;YACtB,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,QAAQ,IAAI,CAAC,OAAO;QACnE;IACF,GAAG,EAAE;IAEL,MAAM,uBAAuB,IAAA,wOAAW,EAAC;QACvC,IAAI;YACF,aAAa,UAAU,CAAC;QAC1B,EAAE,OAAM;YACN,QAAQ,IAAI,CAAC;QACf;IACF,GAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useUserSettings.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { API_CONFIG, getApiUrl, getAuthenticatedHeaders } from '@/lib/config'\n\ninterface UserSettings {\n  prompt: string\n  avatar: string | string[]\n  titleAvatar?: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' }\n  bodyAvatar?: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' }\n  conclusionAvatar?: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' }\n  name: string\n  position: string\n  language?: string\n  companyName: string\n  license: string\n  tailoredFit: string\n  socialHandles: string\n  city: string\n  preferredTone: string\n  callToAction: string\n  email: string\n  gender?: string\n  preset?: string\n  selectedVoiceId?: string\n  selectedMusicTrackId?: string\n  selectedVoicePreset?: string\n  selectedMusicPreset?: string\n  videoCaption?: string\n}\n\ninterface UserSettingsResponse {\n  success: boolean\n  data: UserSettings\n  message?: string\n}\n\ninterface UseUserSettingsProps {\n  userEmail?: string\n  avatars: { custom: any[], default: any[] }\n  setSelectedAvatars: (avatars: { title: any, body: any, conclusion: any }) => void\n  setValue: (name: any, value: any) => void\n}\n\nexport const useUserSettings = ({ userEmail, avatars, setSelectedAvatars, setValue }: UseUserSettingsProps) => {\n  const [loadingUserSettings, setLoadingUserSettings] = useState(false)\n  const [savingUserSettings, setSavingUserSettings] = useState(false)\n\n  const fetchUserSettings = useCallback(async () => {\n    setLoadingUserSettings(true)\n    try {\n      if (!userEmail) {\n        console.error('User email is required to fetch settings')\n        return { success: false, data: null }\n      }\n\n      const response = await fetch(\n        `${getApiUrl(API_CONFIG.ENDPOINTS.USER_SETTINGS)}?email=${userEmail}`,\n        {\n          method: 'GET',\n          headers: getAuthenticatedHeaders()\n        }\n      )\n\n      if (!response.ok) {\n        // console.error('Failed to fetch user settings:', await response.text())\n        return { success: false, data: null }\n      }\n\n      const userSettings: UserSettingsResponse = await response.json()\n      console.log('Fetched user settings:', userSettings)\n\n      if (userSettings.success && userSettings.data) {\n        const settings = userSettings.data\n        setValue('prompt', settings.prompt || '')\n        // Set avatar field to first avatar ID for form validation\n        if (Array.isArray(settings.avatar) && settings.avatar.length > 0) {\n          setValue('avatar', settings.avatar[0])\n        } else if (typeof settings.avatar === 'string') {\n          setValue('avatar', settings.avatar)\n        } else {\n          setValue('avatar', '')\n        }\n        setValue('name', settings.name || '')\n        setValue('position', settings.position || '')\n        setValue('language', settings.language || '')\n        setValue('companyName', settings.companyName || '')\n        setValue('license', settings.license || '')\n        setValue('tailoredFit', settings.tailoredFit || '')\n        setValue('socialHandles', settings.socialHandles || '')\n        setValue('city', settings.city || '')\n        setValue('preferredTone', settings.preferredTone || '')\n        setValue('callToAction', settings.callToAction || '')\n        setValue('email', settings.email || '')\n        // Convert gender from lowercase (API format) to capitalized (form format)\n        const genderValue = settings.gender || ''\n        const capitalizedGender = genderValue ? genderValue.charAt(0).toUpperCase() + genderValue.slice(1).toLowerCase() : ''\n        setValue('gender', capitalizedGender)\n        setValue('preset', settings.preset || '')\n        setValue('videoCaption', settings.videoCaption || '')\n\n            // Handle avatar loading - prioritize avatar array from API response\n            if (settings.avatar && Array.isArray(settings.avatar)) {\n              // New format: avatar is an array of IDs from API response\n              const avatarIds = settings.avatar.filter(id => id && id.trim() !== '')\n              console.log('ðŸ” Loading avatars from API response array:', avatarIds)\n              \n              if (avatarIds.length > 0) {\n                const foundAvatars = avatarIds.map(id => \n                  [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === id)\n                ).filter(Boolean)\n                \n                if (foundAvatars.length > 0) {\n                  setSelectedAvatars({\n                    title: foundAvatars[0] || null,\n                    body: foundAvatars[1] || null,\n                    conclusion: foundAvatars[2] || null\n                  })\n                  \n                  // Update the form's avatar field to show the first avatar in the dropdown\n                  setValue('avatar', foundAvatars[0].avatar_id)\n                  \n                  console.log('ðŸŽ¯ Avatars loaded from API response array:', {\n                    avatar_ids: avatarIds,\n                    loaded_avatars: foundAvatars.map(avatar => ({\n                      avatar_id: avatar.avatar_id,\n                      avatar_name: avatar.avatar_name || avatar.name,\n                      avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === avatar.avatar_id) ? 'custom' : 'default'\n                    })),\n                    assigned_to_slots: ['title', 'body', 'conclusion'],\n                    form_avatar_field_updated: foundAvatars[0].avatar_id\n                  })\n                }\n              }\n            } else if (settings.titleAvatar || settings.bodyAvatar || settings.conclusionAvatar) {\n              // Fallback: individual avatar IDs (legacy support) or new structure with avatar_id and avatarType\n              const getAvatarId = (avatar: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' } | undefined): string => {\n                if (!avatar) return ''\n                if (typeof avatar === 'string') return avatar\n                return avatar.avatar_id || ''\n              }\n              \n              const titleAvatarId = getAvatarId(settings.titleAvatar)\n              const bodyAvatarId = getAvatarId(settings.bodyAvatar)\n              const conclusionAvatarId = getAvatarId(settings.conclusionAvatar)\n              \n              const titleAvatar = titleAvatarId ? \n                [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === titleAvatarId) : null\n              const bodyAvatar = bodyAvatarId ? \n                [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === bodyAvatarId) : null\n              const conclusionAvatar = conclusionAvatarId ? \n                [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === conclusionAvatarId) : null\n\n              setSelectedAvatars({\n                title: titleAvatar,\n                body: bodyAvatar,\n                conclusion: conclusionAvatar\n              })\n              \n              // Update the form's avatar field to show the first avatar in the dropdown\n              if (titleAvatar) {\n                setValue('avatar', titleAvatar.avatar_id)\n              }\n              \n              console.log('ðŸŽ¯ Individual avatars loaded from user settings (legacy):', {\n                title: titleAvatar ? {\n                  avatar_id: titleAvatar.avatar_id,\n                  avatar_name: titleAvatar.avatar_name || titleAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === titleAvatar.avatar_id) ? 'custom' : 'default'\n                } : null,\n                body: bodyAvatar ? {\n                  avatar_id: bodyAvatar.avatar_id,\n                  avatar_name: bodyAvatar.avatar_name || bodyAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === bodyAvatar.avatar_id) ? 'custom' : 'default'\n                } : null,\n                conclusion: conclusionAvatar ? {\n                  avatar_id: conclusionAvatar.avatar_id,\n                  avatar_name: conclusionAvatar.avatar_name || conclusionAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === conclusionAvatar.avatar_id) ? 'custom' : 'default'\n                } : null,\n                form_avatar_field_updated: titleAvatar?.avatar_id || 'none'\n              })\n            } else if (settings.avatar && typeof settings.avatar === 'string') {\n              // Legacy format: avatar is a single string\n              const foundAvatar = [...avatars.custom, ...avatars.default].find(avatar =>\n                avatar.avatar_id === settings.avatar\n              )\n              if (foundAvatar) {\n                setSelectedAvatars({\n                  title: foundAvatar,\n                  body: foundAvatar,\n                  conclusion: foundAvatar\n                })\n                \n                // Update the form's avatar field to show the avatar in the dropdown\n                setValue('avatar', foundAvatar.avatar_id)\n                \n                console.log('ðŸŽ¯ Single avatar loaded from user settings (legacy):', {\n                  avatar_id: foundAvatar.avatar_id,\n                  avatar_name: foundAvatar.avatar_name || foundAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === foundAvatar.avatar_id) ? 'custom' : 'default',\n                  assigned_to_slots: ['title', 'body', 'conclusion'],\n                  form_avatar_field_updated: foundAvatar.avatar_id\n                })\n              } else {\n                console.log('âŒ Avatar not found in available avatars:', {\n                  requested_avatar_id: settings.avatar,\n                  available_custom_avatars: avatars.custom.map(a => a.avatar_id),\n                  available_default_avatars: avatars.default.map(a => a.avatar_id)\n                })\n              }\n            }\n        console.log('Form populated with user settings')\n        // Note: Removed automatic validation trigger to prevent validation errors on empty fields\n        return { success: true, data: userSettings.data }\n      }\n      return { success: false, data: null }\n    } catch (error) {\n      console.error('Error fetching user settings:', error)\n      return { success: false, data: null }\n    } finally {\n      setLoadingUserSettings(false)\n    }\n  }, [userEmail, avatars, setSelectedAvatars, setValue])\n\n  const saveUserSettings = useCallback(async (userSettingsData: UserSettings) => {\n    setSavingUserSettings(true)\n    try {\n      // Create a clean payload with proper array (matching curl request format)\n      // Handle new structure: avatar fields can be objects with avatar_id and avatarType\n      const getAvatarId = (avatar: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' } | undefined): string => {\n        if (!avatar) return ''\n        if (typeof avatar === 'string') return avatar\n        return avatar.avatar_id || ''\n      }\n      const cleanPayload = {\n        prompt: userSettingsData.prompt,\n        avatar: Array.isArray(userSettingsData.avatar) ? userSettingsData.avatar : [],\n        titleAvatar: typeof userSettingsData.titleAvatar === 'object' && userSettingsData.titleAvatar !== null\n          ? userSettingsData.titleAvatar\n          : getAvatarId(userSettingsData.titleAvatar),\n        bodyAvatar: typeof userSettingsData.bodyAvatar === 'object' && userSettingsData.bodyAvatar !== null\n          ? userSettingsData.bodyAvatar\n          : getAvatarId(userSettingsData.bodyAvatar),\n        conclusionAvatar: typeof userSettingsData.conclusionAvatar === 'object' && userSettingsData.conclusionAvatar !== null\n          ? userSettingsData.conclusionAvatar\n          : getAvatarId(userSettingsData.conclusionAvatar),\n        name: userSettingsData.name,\n        position: userSettingsData.position,\n        language: userSettingsData.language || '',\n        companyName: userSettingsData.companyName,\n        license: userSettingsData.license,\n        tailoredFit: userSettingsData.tailoredFit,\n        socialHandles: userSettingsData.socialHandles,\n        city: userSettingsData.city,\n        preferredTone: userSettingsData.preferredTone,\n        callToAction: userSettingsData.callToAction,\n        email: userSettingsData.email,\n        gender: userSettingsData.gender ? userSettingsData.gender.toLowerCase() : '',\n        preset: userSettingsData.preset || '',\n        selectedVoiceId: userSettingsData.selectedVoiceId || '',\n        selectedMusicTrackId: userSettingsData.selectedMusicTrackId || '',\n        selectedVoicePreset: userSettingsData.selectedVoicePreset || '',\n        selectedMusicPreset: userSettingsData.selectedMusicPreset || '',\n        videoCaption: userSettingsData.videoCaption || ''\n      }\n      \n      const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.USER_SETTINGS), {\n        method: 'POST',\n        headers: getAuthenticatedHeaders(),\n        body: JSON.stringify(cleanPayload)\n      })\n\n      if (!response.ok) {\n        console.error('Failed to store user settings:', await response.text())\n        return { success: false, error: 'Failed to store user settings' }\n      }\n\n      const result = await response.json()\n      console.log('User settings stored successfully:', result)\n      return { success: true, data: result }\n    } catch (error) {\n      console.error('Error storing user settings:', error)\n      return { success: false, error: 'Error storing user settings' }\n    } finally {\n      setSavingUserSettings(false)\n    }\n  }, [])\n\n  return {\n    loadingUserSettings,\n    savingUserSettings,\n    fetchUserSettings,\n    saveUserSettings\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1941, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useScheduleValidation.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { ScheduleData, ValidationError, ValidationResult } from '@/types/post-types'\n\nexport const useScheduleValidation = () => {\n  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([])\n\n  const validateScheduleData = useCallback((scheduleData: ScheduleData): ValidationResult => {\n    const errors: ValidationError[] = []\n\n    // Validate frequency\n    if (!scheduleData.frequency || scheduleData.frequency.trim() === '') {\n      errors.push({\n        field: 'frequency',\n        message: 'Please select a posting frequency'\n      })\n    }\n\n    // Validate posts based on frequency\n    const expectedPostCount = getExpectedPostCount(scheduleData.frequency)\n\n    let validPosts\n    if (scheduleData.frequency === 'Daily') {\n      validPosts = scheduleData.posts.filter(post => post.time && post.time.trim() !== '')\n    } else {\n      validPosts = scheduleData.posts.filter(post => (post.day || post.date) && post.time)\n    }\n\n    if (validPosts.length === 0) {\n      if (scheduleData.frequency === 'Daily') {\n        errors.push({\n          field: 'posts',\n          message: 'Please select at least one time'\n        })\n      } else {\n        errors.push({\n          field: 'posts',\n          message: 'Please select at least one day/date and time'\n        })\n      }\n    } else if (scheduleData.frequency !== 'Custom' && validPosts.length < expectedPostCount) {\n      errors.push({\n        field: 'posts',\n        message: `Please select ${expectedPostCount} ${scheduleData.frequency.toLowerCase()} as specified`\n      })\n    }\n\n    // Enhanced validation for individual posts\n    scheduleData.posts.forEach((post, index) => {\n      const postNumber = index + 1\n      \n      // For Daily frequency, only validate time\n      if (scheduleData.frequency === 'Daily') {\n        if (!post.time || post.time.trim() === '') {\n          errors.push({\n            field: `time_${index}`,\n            message: `Please select a time for Day ${postNumber}`\n          })\n        }\n      } else {\n        // For non-Daily frequencies, validate both day/date and time\n        if ((post.day || post.date) && (!post.time || post.time.trim() === '')) {\n          errors.push({\n            field: `time_${index}`,\n            message: `Please select a time for Day ${postNumber}`\n          })\n        }\n        \n        if (post.time && post.time.trim() !== '' && !post.day && !post.date) {\n          errors.push({\n            field: `day_${index}`,\n            message: `Please select a day or date for Time ${postNumber}`\n          })\n        }\n      }\n      \n      // For non-Daily frequencies, check if day is missing\n      if (scheduleData.frequency !== 'Daily' && scheduleData.frequency !== 'Custom' && (!post.day || post.day.trim() === '')) {\n        errors.push({\n          field: `day_${index}`,\n          message: `Please select a day for Day ${postNumber}`\n        })\n      }\n    })\n\n    // Date validation removed - allow past dates to hit the API\n\n    // Enhanced time validation\n    validPosts.forEach((post, index) => {\n      if (post.time && post.time.trim() !== '') {\n        const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/\n        if (!timeRegex.test(post.time)) {\n          errors.push({\n            field: `time_${index}`,\n            message: `Invalid time format for Time ${index + 1}. Use HH:MM format`\n          })\n        } else {\n          const [hours, minutes] = post.time.split(':').map(Number)\n          if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {\n            errors.push({\n              field: `time_${index}`,\n              message: `Invalid time for Time ${index + 1}. Hours must be 0-23, minutes 0-59`\n            })\n          }\n        }\n      }\n    })\n\n    // Check for duplicate days (for day-based frequencies)\n    if (scheduleData.frequency !== 'Daily' && scheduleData.frequency !== 'Custom') {\n      const selectedDays = scheduleData.posts\n        .filter(post => post.day && post.day.trim() !== '')\n        .map(post => post.day)\n      \n      const duplicateDays = selectedDays.filter((day, index) => \n        selectedDays.indexOf(day) !== index\n      )\n      \n      if (duplicateDays.length > 0) {\n        errors.push({\n          field: 'posts',\n          message: `Duplicate days selected: ${duplicateDays.join(', ')}. Please select different days.`\n        })\n      }\n    }\n\n    setValidationErrors(errors)\n    return {\n      isValid: errors.length === 0,\n      errors\n    }\n  }, [])\n\n  const getExpectedPostCount = (frequency: string): number => {\n    switch (frequency) {\n      case 'Once a Week':\n        return 1\n      case 'Twice a Week':\n        return 2\n      case 'Three Times a Week':\n        return 3\n      case 'Daily':\n        return 1\n      default:\n        return 2\n    }\n  }\n\n  const clearValidationErrors = useCallback(() => {\n    setValidationErrors([])\n  }, [])\n\n  const getFieldError = useCallback((field: string): string | null => {\n    const error = validationErrors.find(err => err.field === field)\n    return error ? error.message : null\n  }, [validationErrors])\n\n  // Validate individual field in real-time\n  const validateField = useCallback((field: string, value: string, postIndex?: number): string | null => {\n    if (!value || value.trim() === '') {\n      if (field === 'frequency') {\n        return 'Please select a posting frequency'\n      } else if (field === 'day' && postIndex !== undefined) {\n        return `Please select a day for Day ${postIndex + 1}`\n      } else if (field === 'time' && postIndex !== undefined) {\n        return `Please select a time for Time ${postIndex + 1}`\n      }\n      return 'This field is required'\n    }\n\n    // Time format validation\n    if (field === 'time' && value.trim() !== '') {\n      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/\n      if (!timeRegex.test(value)) {\n        return 'Invalid time format. Use HH:MM format'\n      }\n    }\n\n    return null\n  }, [])\n\n  // Check if all required fields are filled\n  const isFormComplete = useCallback((scheduleData: ScheduleData): boolean => {\n    if (!scheduleData.frequency || scheduleData.frequency.trim() === '') {\n      return false\n    }\n\n    const expectedPostCount = getExpectedPostCount(scheduleData.frequency)\n    const validPosts = scheduleData.posts.filter(post => {\n      if (scheduleData.frequency === 'Daily') {\n        return post.time && post.time.trim() !== ''\n      } else {\n        return (post.day || post.date) && post.time && post.time.trim() !== ''\n      }\n    })\n\n    return validPosts.length >= expectedPostCount\n  }, [])\n\n  // Get validation summary\n  const getValidationSummary = useCallback((): { totalErrors: number; fieldErrors: string[] } => {\n    const fieldErrors = validationErrors.map(error => error.message)\n    return {\n      totalErrors: validationErrors.length,\n      fieldErrors\n    }\n  }, [validationErrors])\n\n  return {\n    validateScheduleData,\n    clearValidationErrors,\n    getFieldError,\n    validateField,\n    isFormComplete,\n    getValidationSummary,\n    validationErrors,\n    hasErrors: validationErrors.length > 0\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useSocialAccounts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react'\nimport { useSelector } from 'react-redux'\nimport { RootState } from '@/store'\nimport { API_CONFIG, getApiUrl, getAuthenticatedHeaders } from '@/lib/config'\n\ninterface ConnectedAccount {\n  id: number\n  name: string\n  type: string\n  _type: string\n  active: boolean\n  image: string\n  post_maxlength: number\n  attachment_types: string[]\n  max_attachments: number\n  post_media_required: boolean\n  video_dimensions: {\n    min: [number, number | null]\n    max: [number | null, number | null]\n  }\n  video_duration: {\n    min: number\n    max: number\n  }\n  user_id: number\n  account_id: string\n  public_id: string\n  extra_data: any\n}\n\ninterface SocialBuResponse {\n  success: boolean\n  message: string\n  data: ConnectedAccount[]\n}\n\ninterface SocialPlatform {\n  id: string\n  name: string\n  type: string\n  _type: string\n  icon: string\n}\n\nexport const useSocialAccounts = () => {\n  const [connectedAccounts, setConnectedAccounts] = useState<ConnectedAccount[]>([])\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [disconnecting, setDisconnecting] = useState<number | null>(null)\n  const refetchTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Get access token from Redux store\n  const accessToken = useSelector((state: RootState) => state.user.accessToken)\n  const userId = useSelector((state: RootState) => state.user.user?.id)\n\n  // Available social media platforms\n  const availablePlatforms: SocialPlatform[] = [\n    {\n      id: 'instagram',\n      name: 'Instagram',\n      type: 'instagram.api',\n      _type: 'Instagram Business',\n      icon: 'instagram'\n    },\n    {\n      id: 'twitter',\n      name: 'X (Twitter)',\n      type: 'twitter.profile',\n      _type: 'X (Twitter) Account',\n      icon: 'twitter'\n    },\n    {\n      id: 'youtube',\n      name: 'YouTube',\n      type: 'google.youtube',\n      _type: 'YouTube Channel',\n      icon: 'youtube'\n    },\n    {\n      id: 'tiktok',\n      name: 'TikTok',\n      type: 'tiktok.profile',\n      _type: 'TikTok Account',\n      icon: 'tiktok'\n    },\n    {\n      id: 'facebook',\n      name: 'Facebook',\n      type: 'facebook.page',\n      _type: 'Facebook Page',\n      icon: 'facebook'\n    },\n    {\n      id: 'linkedin',\n      name: 'LinkedIn',\n      type: 'linkedin.profile',\n      _type: 'LinkedIn Profile',\n      icon: 'linkedin'\n    }\n  ]\n\n// Fetch connected accounts\nconst fetchConnectedAccounts = useCallback(async () => {\n  if (!accessToken) {\n    setError('Authentication required')\n    setLoading(false)\n    return\n  }\n\n  try {\n    setLoading(true)\n    setError(null)\n\n    const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.SOCIALBU.ACCOUNTS_PUBLIC), {\n      method: 'GET',\n      headers: getAuthenticatedHeaders()\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to fetch connected accounts')\n    }\n\n    const data: SocialBuResponse = await response.json()\n\n    if (data.success) {\n      setConnectedAccounts(data.data)\n    } else {\n      throw new Error(data.message || 'Failed to fetch accounts')\n    }\n  } catch (err: any) {\n    console.error('Error fetching connected accounts:', err)\n    setError(err.message || 'Failed to fetch connected accounts')\n  } finally {\n    setLoading(false)\n  }\n}, [accessToken])\n\n// Disconnect/Delete an account\nconst disconnectAccount = useCallback(async (accountId: number) => {\n  if (!accessToken) {\n    setError('Authentication required')\n    return\n  }\n\n  try {\n    setDisconnecting(accountId)\n    setError(null)\n\n    const response = await fetch(getApiUrl(`${API_CONFIG.ENDPOINTS.SOCIALBU.ACCOUNT_DELETE}/${accountId}`), {\n      method: 'DELETE',\n      headers: getAuthenticatedHeaders()\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to disconnect account')\n    }\n\n    const data = await response.json()\n\n    if (data.success) {\n      // Refetch connected accounts to get fresh data from server\n      await fetchConnectedAccounts()\n    } else {\n      throw new Error(data.message || 'Failed to disconnect account')\n    }\n  } catch (err: any) {\n    console.error('Error disconnecting account:', err)\n    setError(err.message || 'Failed to disconnect account')\n  } finally {\n    setDisconnecting(null)\n  }\n}, [accessToken, fetchConnectedAccounts])\n\n// Connect a new platform\nconst connectPlatform = useCallback(async (platformId: string) => {\n  if (!accessToken) {\n    setError('Authentication required')\n    return\n  }\n\n  try {\n    setLoading(true)\n    setError(null)\n\n    // Map platform IDs to provider names\n    const providerMap: { [key: string]: string } = {\n      'instagram': 'instagram',\n      'twitter': 'twitter',\n      'youtube': 'youtube',\n      'tiktok': 'tiktok',\n      'facebook': 'facebook',\n        'linkedin': 'linkedin'\n    }\n\n    const provider = providerMap[platformId]\n    if (!provider) {\n      throw new Error('Invalid platform')\n    }\n    const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.SOCIALBU.ACCOUNTS_CONNECT), {\n      method: 'POST',\n      headers: getAuthenticatedHeaders(),\n      body: JSON.stringify({\n        provider: provider,\n        user_id: userId, // This should come from user data\n        postback_url: `${API_CONFIG.BACKEND_URL}/api/webhook/socialbu`\n      })\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to initiate connection')\n    }\n\n    const data = await response.json()\n\n    if (data.success && data.data?.connect_url) {\n      // Open the connect URL in a new tab\n      window.open(data.data.connect_url, '_blank')\n    } else {\n      throw new Error(data.message || 'Failed to get connection URL')\n    }\n  } catch (err: any) {\n    console.error('Error connecting platform:', err)\n    setError(err.message || 'Failed to connect platform')\n  } finally {\n    setLoading(false)\n  }\n}, [accessToken])\n\n// Check if a platform is connected\nconst isPlatformConnected = useCallback((platformType: string) => {\n  return connectedAccounts.some(account => account.type === platformType)\n}, [connectedAccounts])\n\n// Get connected account for a platform\nconst getConnectedAccount = useCallback((platformType: string) => {\n  return connectedAccounts.find(account => account.type === platformType)\n}, [connectedAccounts])\n\n// Auto-fetch when access token is available\nuseEffect(() => {\n  if (accessToken) {\n    fetchConnectedAccounts()\n  }\n}, [accessToken, fetchConnectedAccounts])\n\n// Auto-refetch when user returns to the website (handles webhook callbacks)\nuseEffect(() => {\n  const debouncedRefetch = () => {\n    if (refetchTimeoutRef.current) {\n      clearTimeout(refetchTimeoutRef.current)\n    }\n\n    refetchTimeoutRef.current = setTimeout(() => {\n      if (accessToken) {\n        fetchConnectedAccounts()\n      }\n    }, 500)\n  }\n\n  const handleVisibilityChange = () => {\n    if (!document.hidden && accessToken) {\n      debouncedRefetch()\n    }\n  }\n\n  const handleFocus = () => {\n    if (accessToken) {\n      debouncedRefetch()\n    }\n  }\n\n  // Listen for visibility changes (tab switching)\n  document.addEventListener('visibilitychange', handleVisibilityChange)\n\n  // Listen for window focus (returning from another app)\n  window.addEventListener('focus', handleFocus)\n\n  return () => {\n    if (refetchTimeoutRef.current) {\n      clearTimeout(refetchTimeoutRef.current)\n    }\n    document.removeEventListener('visibilitychange', handleVisibilityChange)\n    window.removeEventListener('focus', handleFocus)\n  }\n}, [accessToken, fetchConnectedAccounts])\n\nreturn {\n  connectedAccounts,\n  availablePlatforms,\n  loading,\n  error,\n  disconnecting,\n  fetchConnectedAccounts,\n  disconnectAccount,\n  connectPlatform,\n  isPlatformConnected,\n  getConnectedAccount\n}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2395, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useVoicesAndMusic.ts"],"sourcesContent":["'use client'\n\nimport { useState, useEffect, useCallback } from 'react'\nimport { apiService } from '@/lib/api-service'\nimport { Avatar } from '@/lib/api-service'\nimport { Voice } from '@/components/ui/voice-selector/types'\n\ninterface UseVoicesAndMusicProps {\n  preset: string | null | undefined\n  selectedAvatars: {\n    title: Avatar | null\n    body: Avatar | null\n    conclusion: Avatar | null\n  }\n  gender?: string | null // Gender from form dropdown\n}\n\ninterface UseVoicesAndMusicReturn {\n  voices: Voice[]  // Filtered voices based on preset/type\n  voicesLoading: boolean\n  voicesError: string | null\n  musicList: Voice[]  // Filtered music based on preset/type\n  musicLoading: boolean\n  musicError: string | null\n  allVoices: Voice[]  // All voices (low, medium, high)\n  allMusic: Voice[]  // All music (low, medium, high)\n}\n\nexport function useVoicesAndMusic({ preset, selectedAvatars, gender }: UseVoicesAndMusicProps): UseVoicesAndMusicReturn {\n  // Store ALL voices and music (low, medium, high combined)\n  const [allVoices, setAllVoices] = useState<Voice[]>([])\n  const [allMusic, setAllMusic] = useState<Voice[]>([])\n  \n  // Filtered voices and music based on preset/type\n  const [voices, setVoices] = useState<Voice[]>([])\n  const [musicList, setMusicList] = useState<Voice[]>([])\n  \n  const [voicesLoading, setVoicesLoading] = useState(false)\n  const [voicesError, setVoicesError] = useState<string | null>(null)\n  const [musicLoading, setMusicLoading] = useState(false)\n  const [musicError, setMusicError] = useState<string | null>(null)\n\n  // Helper function to get gender - only from form dropdown, NOT from avatar\n  const getGender = useCallback((): string | null => {\n    // Only use gender from form dropdown, ignore avatar gender\n    if (gender && gender.trim()) {\n      return gender.toLowerCase().trim()\n    }\n    // Return null if no gender is selected from dropdown\n    return null\n  }, [gender])\n\n  // Fetch ALL voices (low, medium, high) when avatars are selected - NO energyCategory parameter\n  const fetchAllVoices = useCallback(async (gender: string | null) => {\n    try {\n      setVoicesLoading(true)\n      setVoicesError(null)\n\n      // Fetch ALL voices without energyCategory parameter (only gender)\n      const response = await apiService.getVoices(undefined, gender)\n      \n      if (response.success && response.data) {\n        // Transform API response to Voice[] format\n        const apiVoices = Array.isArray(response.data) ? response.data : (response.data.voices || [])\n        \n        // Map API response to Voice interface\n        // API returns 'energy' field (not energyCategory), use it to determine type\n        // Check if voice is custom (has isCustom property or userId)\n        const transformedVoices: Voice[] = apiVoices.map((voice: any) => {\n          const isCustom = voice.isCustom === true || (voice.userId && voice.userId.trim() !== '')\n          \n          return {\n            id: voice.voice_id || voice.id || voice._id || '',\n            _id: voice._id || voice.id || undefined,\n            voice_id: voice.voice_id || voice.id || undefined,\n            name: voice.name || '',\n            artist: voice.artist || undefined,\n            type: isCustom ? 'custom' as const : ((voice.energy?.toLowerCase() || 'low') as 'low' | 'medium' | 'high'),\n            previewUrl: voice.preview_url || voice.previewUrl || voice.preview || undefined,\n            preview_url: voice.preview_url || voice.previewUrl || voice.preview || undefined,\n            thumbnailUrl: voice.thumbnail_url || voice.thumbnailUrl || voice.thumbnail || undefined,\n            isCustom: isCustom,\n            gender: voice.gender || undefined,\n            energy: voice.energy || undefined,\n            description: voice.description || undefined,\n            userId: voice.userId || voice.user_id || undefined\n          }\n        })\n        \n        setAllVoices(transformedVoices)\n        setVoicesError(null)\n      } else {\n        setVoicesError(response.message || 'Failed to load voices')\n        setAllVoices([])\n      }\n    } catch (error: any) {\n      setVoicesError(error.message || 'Failed to load voices')\n      setAllVoices([])\n    } finally {\n      setVoicesLoading(false)\n    }\n  }, [])\n\n  // Fetch ALL music (low, medium, high) when avatars are selected - NO energyCategory parameter\n  const fetchAllMusic = useCallback(async (gender: string | null) => {\n    try {\n      setMusicLoading(true)\n      setMusicError(null)\n\n      // Fetch ALL music with gender parameter if provided\n      const response = await apiService.getMusicTracks(undefined, gender)\n      \n      if (response.success && response.data) {\n        // Transform API response to Voice[] format\n        const musicData = Array.isArray(response.data) ? response.data : (response.data.tracks || response.data.music || [])\n        \n        // Transform music data according to the API response structure\n        // API should return energyCategory in the response, use it to determine type\n        const transformedMusic: Voice[] = musicData.map((music: any) => {\n          // Map s3PreviewUrl to preview_url and previewUrl for compatibility\n          const previewUrl = music.s3PreviewUrl || music.s3_preview_url || music.preview_url || music.previewUrl || music.preview || undefined\n          \n          return {\n            id: music.trackId || music.track_id || music.id || music._id || '',\n            _id: music._id || '', // Store the MongoDB _id for saving\n            name: music.name || '',\n            artist: music.metadata?.artist || music.artist || undefined,\n            type: (music.energyCategory?.toLowerCase() || 'low') as 'low' | 'medium' | 'high',\n            previewUrl: previewUrl,\n            preview_url: previewUrl, // Use s3PreviewUrl as preview_url\n            thumbnailUrl: music.thumbnail_url || music.thumbnailUrl || music.thumbnail || undefined,\n            s3FullTrackUrl: music.s3FullTrackUrl || music.s3_full_track_url || music.fullTrackUrl || undefined\n          }\n        })\n        \n        setAllMusic(transformedMusic)\n        setMusicError(null)\n      } else {\n        setMusicError(response.message || 'Failed to load music')\n        setAllMusic([])\n      }\n    } catch (error: any) {\n      setMusicError(error.message || 'Failed to load music')\n      setAllMusic([])\n    } finally {\n      setMusicLoading(false)\n    }\n  }, [])\n\n  // Effect to fetch voices and music ONLY when gender is selected from dropdown\n  // APIs are NOT called when avatar is selected - only when gender is explicitly selected\n  useEffect(() => {\n    // Check if gender is explicitly selected from dropdown\n    const hasGender = gender && String(gender).trim().length > 0\n    \n    console.log('ðŸŽµ useVoicesAndMusic - Gender effect triggered:', {\n      gender,\n      hasGender\n    })\n    \n    // Only call APIs if gender is explicitly selected from dropdown\n    // Avatar selection does NOT trigger API calls - removed avatar dependencies\n    if (hasGender) {\n      // Normalize gender to lowercase\n      const currentGender = String(gender).trim().toLowerCase()\n      console.log('ðŸŽµ Calling APIs with gender:', currentGender)\n      // Call APIs with gender parameter (only when gender is selected)\n      fetchAllVoices(currentGender)\n      fetchAllMusic(currentGender)\n    } else {\n      // Clear data only if no gender (but keep data if avatar is selected without gender)\n      const hasAvatar = selectedAvatars.body || selectedAvatars.title || selectedAvatars.conclusion\n      if (!hasAvatar) {\n        console.log('ðŸŽµ Clearing data - no gender and no avatar')\n        setAllVoices([])\n        setAllMusic([])\n        setVoices([])\n        setMusicList([])\n        setVoicesError(null)\n        setMusicError(null)\n      } else {\n        console.log('ðŸŽµ No gender selected but avatar exists - keeping existing data')\n      }\n    }\n    // If avatar is selected but no gender - do nothing (don't call APIs)\n    // Note: selectedAvatars is used inside but not in deps - this is intentional\n    // We only want to react to gender changes, not avatar changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [gender, fetchAllVoices, fetchAllMusic])\n\n  // Effect to filter voices and music based on preset\n  useEffect(() => {\n    if (!preset || !preset.trim()) {\n      // If no preset, show all voices and music\n      setVoices(allVoices)\n      setMusicList(allMusic)\n      return\n    }\n\n    const energyCategory = preset.toLowerCase()\n    \n    // Filter voices and music based on preset\n    const filteredVoices = allVoices.filter(v => v.type === energyCategory)\n    const filteredMusic = allMusic.filter(m => m.type === energyCategory)\n    \n    setVoices(filteredVoices)\n    setMusicList(filteredMusic)\n  }, [preset, allVoices, allMusic])\n\n  return {\n    voices,  // Filtered based on preset\n    voicesLoading,\n    voicesError,\n    musicList,  // Filtered based on preset\n    musicLoading,\n    musicError,\n    allVoices,  // All voices (low, medium, high)\n    allMusic  // All music (low, medium, high)\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}