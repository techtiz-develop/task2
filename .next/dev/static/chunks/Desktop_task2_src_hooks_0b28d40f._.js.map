{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/use-analytics.ts"],"sourcesContent":["\"use client\";\n\nimport { useCallback } from \"react\";\n\ninterface AnalyticsEvent {\n  event: string;\n  properties?: Record<string, unknown>;\n  timestamp?: number;\n}\n\ninterface NavigationEvent extends AnalyticsEvent {\n  event: \"navigation\";\n  properties: {\n    from: string;\n    to: string;\n    method: \"click\" | \"keyboard\" | \"programmatic\";\n  };\n}\n\ninterface ButtonClickEvent extends AnalyticsEvent {\n  event: \"button_click\";\n  properties: {\n    button: string;\n    location: string;\n    action: string;\n  };\n}\n\ninterface CustomEvent extends AnalyticsEvent {\n  event: string;\n  properties?: Record<string, unknown>;\n}\n\ntype TrackableEvent = NavigationEvent | ButtonClickEvent | CustomEvent;\n\n// Type definitions for analytics services\ninterface GoogleAnalytics {\n  gtag: (command: string, eventName: string, parameters?: Record<string, unknown>) => void;\n}\n\ninterface Mixpanel {\n  track: (eventName: string, properties?: Record<string, unknown>) => void;\n}\n\ninterface WindowWithAnalytics extends Window {\n  gtag?: GoogleAnalytics['gtag'];\n  mixpanel?: Mixpanel;\n}\n\nclass Analytics {\n  private events: TrackableEvent[] = [];\n  private isEnabled: boolean;\n\n  constructor() {\n    this.isEnabled = process.env.NODE_ENV === \"production\" || \n                    process.env.NEXT_PUBLIC_ANALYTICS_ENABLED === \"true\";\n  }\n\n  track(event: TrackableEvent): void {\n    if (!this.isEnabled) {\n      // In development, just log to console\n      // console.log(\"Analytics Event:\", event);\n      return;\n    }\n\n    // Add timestamp if not provided\n    if (!event.timestamp) {\n      event.timestamp = Date.now();\n    }\n\n    this.events.push(event);\n\n    // In production, you would send this to your analytics service\n    // Example: Google Analytics, Mixpanel, etc.\n    this.sendToAnalyticsService(event);\n  }\n\n  private sendToAnalyticsService(event: TrackableEvent): void {\n    // Example implementation for Google Analytics 4\n    if (typeof window !== \"undefined\" && (window as WindowWithAnalytics).gtag) {\n      (window as WindowWithAnalytics).gtag!(\"event\", event.event, event.properties);\n    }\n\n    // Example implementation for Mixpanel\n    if (typeof window !== \"undefined\" && (window as WindowWithAnalytics).mixpanel) {\n      (window as WindowWithAnalytics).mixpanel!.track(event.event, event.properties);\n    }\n\n    // Example implementation for custom analytics endpoint\n    if (process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT) {\n      fetch(process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(event),\n      }).catch((error) => {\n        console.error(\"Failed to send analytics event:\", error);\n      });\n    }\n  }\n\n  getEvents(): TrackableEvent[] {\n    return [...this.events];\n  }\n\n  clearEvents(): void {\n    this.events = [];\n  }\n}\n\n// Global analytics instance\nconst analytics = new Analytics();\n\nexport function useAnalytics() {\n  const trackNavigation = useCallback((from: string, to: string, method: \"click\" | \"keyboard\" | \"programmatic\" = \"click\") => {\n    analytics.track({\n      event: \"navigation\",\n      properties: {\n        from,\n        to,\n        method,\n      },\n    });\n  }, []);\n\n  const trackButtonClick = useCallback((button: string, location: string, action: string) => {\n    analytics.track({\n      event: \"button_click\",\n      properties: {\n        button,\n        location,\n        action,\n      },\n    });\n  }, []);\n\n  const trackCustomEvent = useCallback((event: string, properties?: Record<string, unknown>) => {\n    analytics.track({\n      event,\n      properties,\n    } as CustomEvent);\n  }, []);\n\n  return {\n    trackNavigation,\n    trackButtonClick,\n    trackCustomEvent,\n    getEvents: analytics.getEvents.bind(analytics),\n    clearEvents: analytics.clearEvents.bind(analytics),\n  };\n}\n"],"names":[],"mappings":";;;;AAsDqB;AApDrB;;AAFA;;AAiDA,MAAM;IACI,SAA2B,EAAE,CAAC;IAC9B,UAAmB;IAE3B,aAAc;QACZ,IAAI,CAAC,SAAS,GAAG,oDAAyB,gBAC1B,+LAAO,CAAC,GAAG,CAAC,6BAA6B,KAAK;IAChE;IAEA,MAAM,KAAqB,EAAQ;QACjC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,sCAAsC;YACtC,0CAA0C;YAC1C;QACF;QAEA,gCAAgC;QAChC,IAAI,CAAC,MAAM,SAAS,EAAE;YACpB,MAAM,SAAS,GAAG,KAAK,GAAG;QAC5B;QAEA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAEjB,+DAA+D;QAC/D,4CAA4C;QAC5C,IAAI,CAAC,sBAAsB,CAAC;IAC9B;IAEQ,uBAAuB,KAAqB,EAAQ;QAC1D,gDAAgD;QAChD,IAAI,+CAAkB,eAAe,AAAC,OAA+B,IAAI,EAAE;YACxE,OAA+B,IAAI,CAAE,SAAS,MAAM,KAAK,EAAE,MAAM,UAAU;QAC9E;QAEA,sCAAsC;QACtC,IAAI,+CAAkB,eAAe,AAAC,OAA+B,QAAQ,EAAE;YAC5E,OAA+B,QAAQ,CAAE,KAAK,CAAC,MAAM,KAAK,EAAE,MAAM,UAAU;QAC/E;QAEA,uDAAuD;QACvD,IAAI,+LAAO,CAAC,GAAG,CAAC,8BAA8B,EAAE;YAC9C,MAAM,+LAAO,CAAC,GAAG,CAAC,8BAA8B,EAAE;gBAChD,QAAQ;gBACR,SAAS;oBACP,gBAAgB;gBAClB;gBACA,MAAM,KAAK,SAAS,CAAC;YACvB,GAAG,KAAK,CAAC,CAAC;gBACR,QAAQ,KAAK,CAAC,mCAAmC;YACnD;QACF;IACF;IAEA,YAA8B;QAC5B,OAAO;eAAI,IAAI,CAAC,MAAM;SAAC;IACzB;IAEA,cAAoB;QAClB,IAAI,CAAC,MAAM,GAAG,EAAE;IAClB;AACF;AAEA,4BAA4B;AAC5B,MAAM,YAAY,IAAI;AAEf,SAAS;;IACd,MAAM,kBAAkB,IAAA,gMAAW;qDAAC,CAAC,MAAc,IAAY,SAAgD,OAAO;YACpH,UAAU,KAAK,CAAC;gBACd,OAAO;gBACP,YAAY;oBACV;oBACA;oBACA;gBACF;YACF;QACF;oDAAG,EAAE;IAEL,MAAM,mBAAmB,IAAA,gMAAW;sDAAC,CAAC,QAAgB,UAAkB;YACtE,UAAU,KAAK,CAAC;gBACd,OAAO;gBACP,YAAY;oBACV;oBACA;oBACA;gBACF;YACF;QACF;qDAAG,EAAE;IAEL,MAAM,mBAAmB,IAAA,gMAAW;sDAAC,CAAC,OAAe;YACnD,UAAU,KAAK,CAAC;gBACd;gBACA;YACF;QACF;qDAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA,WAAW,UAAU,SAAS,CAAC,IAAI,CAAC;QACpC,aAAa,UAAU,WAAW,CAAC,IAAI,CAAC;IAC1C;AACF;GArCgB"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/use-active-section.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nexport function useActiveSection(sectionIds: string[], offset: number = 100) {\n  const [activeSection, setActiveSection] = useState<string>('');\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollPosition = window.scrollY;\n      const windowHeight = window.innerHeight;\n      const viewportTop = scrollPosition;\n      const viewportBottom = scrollPosition + windowHeight;\n      const viewportCenter = scrollPosition + (windowHeight / 2);\n        \n      // Find which section is most prominently visible in the viewport\n      let bestSection = '';\n      let bestScore = -1;\n      \n      for (let i = 0; i < sectionIds.length; i++) {\n        const sectionId = sectionIds[i];\n        const element = document.getElementById(sectionId);\n        \n        if (element) {\n          const elementTop = element.offsetTop;\n          const elementBottom = elementTop + element.offsetHeight;\n          const elementCenter = elementTop + (element.offsetHeight / 2);\n          \n          // Calculate how much of this section is visible in the viewport\n          const visibleTop = Math.max(elementTop, viewportTop);\n          const visibleBottom = Math.min(elementBottom, viewportBottom);\n          const visibleHeight = Math.max(0, visibleBottom - visibleTop);\n          \n          // Calculate a score based on visibility and proximity to viewport center\n          const visibilityRatio = visibleHeight / element.offsetHeight;\n          const distanceFromCenter = Math.abs(elementCenter - viewportCenter);\n          const score = visibilityRatio - (distanceFromCenter / windowHeight) * 0.1;\n          \n          if (score > bestScore) {\n            bestScore = score;\n            bestSection = sectionId;\n          }\n        }\n      }\n      \n      // Only set active section if we found a section with reasonable visibility\n      if (bestScore > 0.1) {\n        setActiveSection(bestSection);\n      }\n    };\n\n    // Initial check\n    handleScroll();\n    \n    // Add scroll listener with throttling\n    let ticking = false;\n    const throttledHandleScroll = () => {\n      if (!ticking) {\n        requestAnimationFrame(() => {\n          handleScroll();\n          ticking = false;\n        });\n        ticking = true;\n      }\n    };\n    \n    window.addEventListener('scroll', throttledHandleScroll, { passive: true });\n    \n    return () => {\n      window.removeEventListener('scroll', throttledHandleScroll);\n    };\n  }, [sectionIds, offset]);\n\n  return activeSection;\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEO,SAAS,iBAAiB,UAAoB,EAAE,SAAiB,GAAG;;IACzE,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,6LAAQ,EAAS;IAE3D,IAAA,8LAAS;sCAAC;YACR,MAAM;2DAAe;oBACnB,MAAM,iBAAiB,OAAO,OAAO;oBACrC,MAAM,eAAe,OAAO,WAAW;oBACvC,MAAM,cAAc;oBACpB,MAAM,iBAAiB,iBAAiB;oBACxC,MAAM,iBAAiB,iBAAkB,eAAe;oBAExD,iEAAiE;oBACjE,IAAI,cAAc;oBAClB,IAAI,YAAY,CAAC;oBAEjB,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IAAK;wBAC1C,MAAM,YAAY,UAAU,CAAC,EAAE;wBAC/B,MAAM,UAAU,SAAS,cAAc,CAAC;wBAExC,IAAI,SAAS;4BACX,MAAM,aAAa,QAAQ,SAAS;4BACpC,MAAM,gBAAgB,aAAa,QAAQ,YAAY;4BACvD,MAAM,gBAAgB,aAAc,QAAQ,YAAY,GAAG;4BAE3D,gEAAgE;4BAChE,MAAM,aAAa,KAAK,GAAG,CAAC,YAAY;4BACxC,MAAM,gBAAgB,KAAK,GAAG,CAAC,eAAe;4BAC9C,MAAM,gBAAgB,KAAK,GAAG,CAAC,GAAG,gBAAgB;4BAElD,yEAAyE;4BACzE,MAAM,kBAAkB,gBAAgB,QAAQ,YAAY;4BAC5D,MAAM,qBAAqB,KAAK,GAAG,CAAC,gBAAgB;4BACpD,MAAM,QAAQ,kBAAkB,AAAC,qBAAqB,eAAgB;4BAEtE,IAAI,QAAQ,WAAW;gCACrB,YAAY;gCACZ,cAAc;4BAChB;wBACF;oBACF;oBAEA,2EAA2E;oBAC3E,IAAI,YAAY,KAAK;wBACnB,iBAAiB;oBACnB;gBACF;;YAEA,gBAAgB;YAChB;YAEA,sCAAsC;YACtC,IAAI,UAAU;YACd,MAAM;oEAAwB;oBAC5B,IAAI,CAAC,SAAS;wBACZ;gFAAsB;gCACpB;gCACA,UAAU;4BACZ;;wBACA,UAAU;oBACZ;gBACF;;YAEA,OAAO,gBAAgB,CAAC,UAAU,uBAAuB;gBAAE,SAAS;YAAK;YAEzE;8CAAO;oBACL,OAAO,mBAAmB,CAAC,UAAU;gBACvC;;QACF;qCAAG;QAAC;QAAY;KAAO;IAEvB,OAAO;AACT;GAtEgB"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useModalScrollLock.ts"],"sourcesContent":["'use client'\n\nimport { useEffect, useRef } from 'react'\n\n// Global counter to track how many modals are open\nlet modalCount = 0\nlet originalBodyStyle = ''\n\n/**\n * Custom hook to handle body scroll locking for modals\n * This ensures that when multiple modals are open, scroll is only restored\n * when ALL modals are closed\n */\nexport function useModalScrollLock(isOpen: boolean) {\n  const isLockedRef = useRef(false)\n\n  useEffect(() => {\n    if (isOpen && !isLockedRef.current) {\n      // Store original body style only once\n      if (modalCount === 0) {\n        originalBodyStyle = document.body.style.overflow || ''\n      }\n      \n      // Increment modal count and lock scroll\n      modalCount++\n      document.body.style.overflow = 'hidden'\n      isLockedRef.current = true\n    } else if (!isOpen && isLockedRef.current) {\n      // Decrement modal count\n      modalCount--\n      isLockedRef.current = false\n      \n      // Only restore scroll when all modals are closed\n      if (modalCount <= 0) {\n        modalCount = 0 // Ensure it doesn't go negative\n        document.body.style.overflow = originalBodyStyle\n        originalBodyStyle = '' // Reset for next time\n      }\n    }\n\n    // Cleanup function to ensure proper restoration\n    return () => {\n      if (isLockedRef.current) {\n        modalCount--\n        isLockedRef.current = false\n        \n        if (modalCount <= 0) {\n          modalCount = 0\n          document.body.style.overflow = originalBodyStyle\n          originalBodyStyle = ''\n        }\n      }\n    }\n  }, [isOpen])\n}\n\n/**\n * Utility function to force restore scroll (for emergency cases)\n */\nexport function forceRestoreScroll() {\n  modalCount = 0\n  document.body.style.overflow = originalBodyStyle\n  originalBodyStyle = ''\n}\n"],"names":[],"mappings":";;;;;;AAEA;;AAFA;;AAIA,mDAAmD;AACnD,IAAI,aAAa;AACjB,IAAI,oBAAoB;AAOjB,SAAS,mBAAmB,MAAe;;IAChD,MAAM,cAAc,IAAA,2LAAM,EAAC;IAE3B,IAAA,8LAAS;wCAAC;YACR,IAAI,UAAU,CAAC,YAAY,OAAO,EAAE;gBAClC,sCAAsC;gBACtC,IAAI,eAAe,GAAG;oBACpB,oBAAoB,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI;gBACtD;gBAEA,wCAAwC;gBACxC;gBACA,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;gBAC/B,YAAY,OAAO,GAAG;YACxB,OAAO,IAAI,CAAC,UAAU,YAAY,OAAO,EAAE;gBACzC,wBAAwB;gBACxB;gBACA,YAAY,OAAO,GAAG;gBAEtB,iDAAiD;gBACjD,IAAI,cAAc,GAAG;oBACnB,aAAa,GAAE,gCAAgC;oBAC/C,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;oBAC/B,oBAAoB,IAAG,sBAAsB;gBAC/C;YACF;YAEA,gDAAgD;YAChD;gDAAO;oBACL,IAAI,YAAY,OAAO,EAAE;wBACvB;wBACA,YAAY,OAAO,GAAG;wBAEtB,IAAI,cAAc,GAAG;4BACnB,aAAa;4BACb,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;4BAC/B,oBAAoB;wBACtB;oBACF;gBACF;;QACF;uCAAG;QAAC;KAAO;AACb;GAzCgB;AA8CT,SAAS;IACd,aAAa;IACb,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG;IAC/B,oBAAoB;AACtB"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useTokenValidation.ts"],"sourcesContent":["import { useEffect, useCallback } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { clearUser } from '@/store/slices/userSlice';\nimport { isTokenExpired, isTokenExpiringSoon, handleTokenExpiration } from '@/lib/jwt-client';\nimport { useNotificationStore } from '@/components/ui/global-notification';\nimport { getApiUrl, API_CONFIG } from '@/lib/config';\n\nexport const useTokenValidation = () => {\n  const dispatch = useDispatch();\n  const { showNotification } = useNotificationStore();\n\n  const checkTokenExpiration = useCallback(() => {\n    const token = localStorage.getItem('accessToken');\n    \n    if (!token) {\n      return;\n    }\n\n    // Check if token is expired\n    if (isTokenExpired(token)) {\n      console.log('Token expired, logging out user');\n      dispatch(clearUser());\n      handleTokenExpiration();\n      showNotification('Token expired. Please login again.', 'error');\n      return;\n    }\n\n    // Check if token is expiring soon (within 1 hour)\n    if (isTokenExpiringSoon(token, 60)) {\n      console.log('Token expiring soon, showing warning to user');\n      // You can show a notification to the user here\n      // For now, we'll just log it\n    }\n  }, [dispatch, showNotification]);\n\n  const validateTokenWithServer = useCallback(async () => {\n    const token = localStorage.getItem('accessToken');\n    if (!token) {\n      return false;\n    }\n\n    try {\n      const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.AUTH.VALIDATE_TOKEN), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ token }),\n      });\n\n      // Handle 401 Unauthorized (user deleted or token invalid)\n      if (response.status === 401) {\n        console.log('Server returned 401 - user deleted or token invalid, logging out user');\n        dispatch(clearUser());\n        handleTokenExpiration();\n        showNotification('Session expired. Please login again.', 'error');\n        return false;\n      }\n\n      const data = await response.json();\n\n      if (!data.success) {\n        console.log('Server validation failed, logging out user');\n        dispatch(clearUser());\n        handleTokenExpiration();\n        showNotification('Token expired. Please login again.', 'error');\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Token validation error:', error);\n      return false;\n    }\n  }, [dispatch, showNotification]);\n\n  // Check token expiration on mount and every 5 minutes\n  useEffect(() => {\n    checkTokenExpiration();\n\n    const interval = setInterval(checkTokenExpiration, 5 * 60 * 1000); // 5 minutes\n\n    return () => clearInterval(interval);\n  }, [checkTokenExpiration]);\n\n  // Validate token with server on mount (only if token exists)\n  useEffect(() => {\n    const token = localStorage.getItem('accessToken');\n    if (token) {\n      validateTokenWithServer();\n    }\n  }, [validateTokenWithServer]);\n\n  return {\n    checkTokenExpiration,\n    validateTokenWithServer,\n  };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAEO,MAAM,qBAAqB;;IAChC,MAAM,WAAW,IAAA,+LAAW;IAC5B,MAAM,EAAE,gBAAgB,EAAE,GAAG,IAAA,iMAAoB;IAEjD,MAAM,uBAAuB,IAAA,gMAAW;gEAAC;YACvC,MAAM,QAAQ,aAAa,OAAO,CAAC;YAEnC,IAAI,CAAC,OAAO;gBACV;YACF;YAEA,4BAA4B;YAC5B,IAAI,IAAA,oKAAc,EAAC,QAAQ;gBACzB,QAAQ,GAAG,CAAC;gBACZ,SAAS,IAAA,uKAAS;gBAClB,IAAA,2KAAqB;gBACrB,iBAAiB,sCAAsC;gBACvD;YACF;YAEA,kDAAkD;YAClD,IAAI,IAAA,yKAAmB,EAAC,OAAO,KAAK;gBAClC,QAAQ,GAAG,CAAC;YACZ,+CAA+C;YAC/C,6BAA6B;YAC/B;QACF;+DAAG;QAAC;QAAU;KAAiB;IAE/B,MAAM,0BAA0B,IAAA,gMAAW;mEAAC;YAC1C,MAAM,QAAQ,aAAa,OAAO,CAAC;YACnC,IAAI,CAAC,OAAO;gBACV,OAAO;YACT;YAEA,IAAI;gBACF,MAAM,WAAW,MAAM,MAAM,IAAA,wJAAS,EAAC,yJAAU,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,GAAG;oBAChF,QAAQ;oBACR,SAAS;wBACP,gBAAgB;oBAClB;oBACA,MAAM,KAAK,SAAS,CAAC;wBAAE;oBAAM;gBAC/B;gBAEA,0DAA0D;gBAC1D,IAAI,SAAS,MAAM,KAAK,KAAK;oBAC3B,QAAQ,GAAG,CAAC;oBACZ,SAAS,IAAA,uKAAS;oBAClB,IAAA,2KAAqB;oBACrB,iBAAiB,wCAAwC;oBACzD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,SAAS,IAAI;gBAEhC,IAAI,CAAC,KAAK,OAAO,EAAE;oBACjB,QAAQ,GAAG,CAAC;oBACZ,SAAS,IAAA,uKAAS;oBAClB,IAAA,2KAAqB;oBACrB,iBAAiB,sCAAsC;oBACvD,OAAO;gBACT;gBAEA,OAAO;YACT,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,2BAA2B;gBACzC,OAAO;YACT;QACF;kEAAG;QAAC;QAAU;KAAiB;IAE/B,sDAAsD;IACtD,IAAA,8LAAS;wCAAC;YACR;YAEA,MAAM,WAAW,YAAY,sBAAsB,IAAI,KAAK,OAAO,YAAY;YAE/E;gDAAO,IAAM,cAAc;;QAC7B;uCAAG;QAAC;KAAqB;IAEzB,6DAA6D;IAC7D,IAAA,8LAAS;wCAAC;YACR,MAAM,QAAQ,aAAa,OAAO,CAAC;YACnC,IAAI,OAAO;gBACT;YACF;QACF;uCAAG;QAAC;KAAwB;IAE5B,OAAO;QACL;QACA;IACF;AACF;GA1Fa;;QACM,+LAAW;QACC,iMAAoB"}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useAuthErrorHandler.ts"],"sourcesContent":["'use client'\n\nimport { useEffect } from 'react'\nimport { useAppDispatch } from '@/store/hooks'\nimport { clearUser } from '@/store/slices/userSlice'\nimport { isTokenExpired } from '@/lib/jwt-client'\nimport { useNotificationStore } from '@/components/ui/global-notification'\n\nexport function useAuthErrorHandler() {\n  const dispatch = useAppDispatch()\n  const { showNotification } = useNotificationStore()\n\n  useEffect(() => {\n    // Create a global fetch interceptor\n    const originalFetch = window.fetch\n\n    window.fetch = async (...args) => {\n      try {\n        const response = await originalFetch(...args)\n        \n        // Check if response is 401 (Unauthorized)\n        if (response.status === 401) {\n          const responseData = await response.clone().json().catch(() => ({}))\n          \n          // Check if it's a token-related error\n          if (responseData.message?.includes('token') || \n              responseData.message?.includes('unauthorized') ||\n              responseData.message?.includes('expired')) {\n            // Safeguard: only force logout if the client-side token is missing or actually expired\n            const token = typeof window !== 'undefined' ? localStorage.getItem('accessToken') : null\n            const shouldLogout = !token || isTokenExpired(token)\n\n            if (shouldLogout) {\n              console.log('ðŸ” Auth Error Handler: Token expired or invalid, logging out user')\n              dispatch(clearUser())\n              \n              // Check if we're on a protected page - if so, don't show toast (ProtectedRoute will handle it)\n              const currentPath = window.location.pathname\n              const isProtectedPage = currentPath.includes('/create-video') || \n                                   currentPath.includes('/account') || \n                                   currentPath.includes('/gallery') || \n                                   currentPath.includes('/report-analytics') || \n                                   currentPath.includes('/scheduled-post')\n              \n              // Never show toast for protected pages - ProtectedRoute handles it\n              if (!isProtectedPage) {\n                // Only show toast for API calls on non-protected pages\n                showNotification('Unauthorized access', 'error')\n              }\n              \n              return new Response(JSON.stringify({ \n                success: false, \n                message: 'Authentication failed' \n              }), {\n                status: 401,\n                headers: { 'Content-Type': 'application/json' }\n              })\n            }\n            \n            // If token exists and is not expired client-side, don't auto-logout; let the caller handle the 401\n            console.log('ðŸ” Auth Error Handler: 401 received but token appears valid client-side; not logging out')\n            return response\n          }\n        }\n        \n        // Check for network errors (status 0 or failed fetch)\n        if (response.status === 0 || !response.ok) {\n          console.log('ðŸ” Auth Error Handler: Network error detected, not clearing user data')\n          // Don't clear user data on network errors - might be temporary\n          return response\n        }\n        \n        return response\n      } catch (error) {\n        console.error('Fetch interceptor error:', error)\n        return originalFetch(...args)\n      }\n    }\n\n    // Cleanup function\n    return () => {\n      window.fetch = originalFetch\n    }\n  }, [dispatch, showNotification])\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AACA;AACA;;AANA;;;;;;AAQO,SAAS;;IACd,MAAM,WAAW,IAAA,8JAAc;IAC/B,MAAM,EAAE,gBAAgB,EAAE,GAAG,IAAA,iMAAoB;IAEjD,IAAA,8LAAS;yCAAC;YACR,oCAAoC;YACpC,MAAM,gBAAgB,OAAO,KAAK;YAElC,OAAO,KAAK;iDAAG,OAAO,GAAG;oBACvB,IAAI;wBACF,MAAM,WAAW,MAAM,iBAAiB;wBAExC,0CAA0C;wBAC1C,IAAI,SAAS,MAAM,KAAK,KAAK;4BAC3B,MAAM,eAAe,MAAM,SAAS,KAAK,GAAG,IAAI,GAAG,KAAK;iEAAC,IAAM,CAAC,CAAC,CAAC;;4BAElE,sCAAsC;4BACtC,IAAI,aAAa,OAAO,EAAE,SAAS,YAC/B,aAAa,OAAO,EAAE,SAAS,mBAC/B,aAAa,OAAO,EAAE,SAAS,YAAY;gCAC7C,uFAAuF;gCACvF,MAAM,QAAQ,uCAAgC,aAAa,OAAO,CAAC,iBAAiB;gCACpF,MAAM,eAAe,CAAC,SAAS,IAAA,oKAAc,EAAC;gCAE9C,IAAI,cAAc;oCAChB,QAAQ,GAAG,CAAC;oCACZ,SAAS,IAAA,uKAAS;oCAElB,+FAA+F;oCAC/F,MAAM,cAAc,OAAO,QAAQ,CAAC,QAAQ;oCAC5C,MAAM,kBAAkB,YAAY,QAAQ,CAAC,oBACxB,YAAY,QAAQ,CAAC,eACrB,YAAY,QAAQ,CAAC,eACrB,YAAY,QAAQ,CAAC,wBACrB,YAAY,QAAQ,CAAC;oCAE1C,mEAAmE;oCACnE,IAAI,CAAC,iBAAiB;wCACpB,uDAAuD;wCACvD,iBAAiB,uBAAuB;oCAC1C;oCAEA,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;wCACjC,SAAS;wCACT,SAAS;oCACX,IAAI;wCACF,QAAQ;wCACR,SAAS;4CAAE,gBAAgB;wCAAmB;oCAChD;gCACF;gCAEA,mGAAmG;gCACnG,QAAQ,GAAG,CAAC;gCACZ,OAAO;4BACT;wBACF;wBAEA,sDAAsD;wBACtD,IAAI,SAAS,MAAM,KAAK,KAAK,CAAC,SAAS,EAAE,EAAE;4BACzC,QAAQ,GAAG,CAAC;4BACZ,+DAA+D;4BAC/D,OAAO;wBACT;wBAEA,OAAO;oBACT,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,4BAA4B;wBAC1C,OAAO,iBAAiB;oBAC1B;gBACF;;YAEA,mBAAmB;YACnB;iDAAO;oBACL,OAAO,KAAK,GAAG;gBACjB;;QACF;wCAAG;QAAC;QAAU;KAAiB;AACjC;GA5EgB;;QACG,8JAAc;QACF,iMAAoB"}},
    {"offset": {"line": 507, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useDeploymentReload.ts"],"sourcesContent":["'use client'\n\nimport { useEffect, useRef, useState } from 'react'\n\ninterface DeploymentInfo {\n  deploymentId: string\n  deploymentUrl: string\n  createdAt: string\n}\n\n/**\n * Hook to automatically hard refresh the page when a new Vercel deployment is detected\n * \n * This hook:\n * 1. Polls the deployment check endpoint to detect new deployments\n * 2. Uses BroadcastChannel for cross-tab communication\n * 3. Triggers a hard refresh (cache bypass) when new deployment is detected\n * 4. Only runs in production/browser environment\n */\nexport const useDeploymentReload = () => {\n  const [isChecking, setIsChecking] = useState(false)\n  const lastDeploymentIdRef = useRef<string | null>(null)\n  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null)\n  const broadcastChannelRef = useRef<BroadcastChannel | null>(null)\n  const isReloadingRef = useRef(false)\n\n  useEffect(() => {\n    // Only run in browser environment\n    if (typeof window === 'undefined') {\n      console.log('ðŸ”„ Deployment reload: Skipping (server-side)')\n      return\n    }\n\n    console.log('ðŸ”„ Deployment reload: Hook initialized', {\n      hostname: window.location.hostname,\n      nodeEnv: process.env.NODE_ENV,\n      timestamp: new Date().toISOString()\n    })\n\n    // Only run in production (Vercel deployments)\n    const isProduction = process.env.NODE_ENV === 'production' || \n                         window.location.hostname.includes('vercel.app') ||\n                         window.location.hostname.includes('edgeairealty.com')\n\n    if (!isProduction) {\n      console.log('ðŸ”„ Deployment reload: Skipping in development', {\n        reason: 'Not in production environment',\n        hostname: window.location.hostname,\n        nodeEnv: process.env.NODE_ENV\n      })\n      return\n    }\n\n    console.log('ðŸ”„ Deployment reload: Production mode detected - Starting deployment monitoring', {\n      hostname: window.location.hostname,\n      timestamp: new Date().toISOString()\n    })\n\n    // Initialize BroadcastChannel for cross-tab communication\n    try {\n      broadcastChannelRef.current = new BroadcastChannel('deployment-reload')\n      console.log('ðŸ”„ Deployment reload: BroadcastChannel initialized for cross-tab communication')\n      \n      broadcastChannelRef.current.onmessage = (event) => {\n        console.log('ðŸ”„ Deployment reload: Message received from another tab', event.data)\n        if (event.data.type === 'new-deployment' && !isReloadingRef.current) {\n          console.log('ðŸ”„ Deployment reload: New deployment detected from another tab, reloading...', {\n            deploymentId: event.data.deploymentId,\n            timestamp: new Date().toISOString()\n          })\n          isReloadingRef.current = true\n          // Hard refresh with cache bypass\n          console.log('ðŸ”„ Deployment reload: Executing hard reload from cross-tab message...')\n          window.location.reload()\n        }\n      }\n    } catch (error) {\n      console.warn('ðŸ”„ Deployment reload: BroadcastChannel not supported', error)\n    }\n\n    // Function to check for new deployments\n    const checkDeployment = async () => {\n      if (isReloadingRef.current) {\n        console.log('ðŸ”„ Deployment reload: Check skipped (reload already in progress)')\n        return\n      }\n\n      console.log('ðŸ”„ Deployment reload: Checking for new deployment...', {\n        timestamp: new Date().toISOString(),\n        lastDeploymentId: lastDeploymentIdRef.current\n      })\n\n      try {\n        setIsChecking(true)\n        \n        // Call deployment check API\n        console.log('ðŸ”„ Deployment reload: Calling /api/deployment/check endpoint...')\n        const response = await fetch('/api/deployment/check', {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          cache: 'no-store', // Always fetch fresh data\n        })\n\n        console.log('ðŸ”„ Deployment reload: API response received', {\n          status: response.status,\n          ok: response.ok,\n          timestamp: new Date().toISOString()\n        })\n\n        if (!response.ok) {\n          console.warn('ðŸ”„ Deployment reload: Check endpoint returned error', {\n            status: response.status,\n            statusText: response.statusText,\n            timestamp: new Date().toISOString()\n          })\n          return\n        }\n\n        const data = await response.json()\n        console.log('ðŸ”„ Deployment reload: API response data', {\n          success: data.success,\n          hasDeployment: !!data.deployment,\n          deploymentId: data.deployment?.deploymentId || data.deployment?.id,\n          timestamp: new Date().toISOString()\n        })\n        \n        if (data.success && data.deployment) {\n          // Use deploymentId, id, or buildTime as identifier\n          const currentDeploymentId = data.deployment.deploymentId || \n                                     data.deployment.id || \n                                     data.deployment.buildTime ||\n                                     null\n          \n          if (!currentDeploymentId) {\n            console.warn('ðŸ”„ Deployment reload: No deployment identifier found in response')\n            return\n          }\n          \n          // First check - just store the deployment ID\n          if (!lastDeploymentIdRef.current) {\n            lastDeploymentIdRef.current = currentDeploymentId\n            console.log('ðŸ”„ Deployment reload: âœ… Initial deployment ID stored', {\n              deploymentId: currentDeploymentId,\n              timestamp: new Date().toISOString(),\n              message: 'No reload needed - this is the first check'\n            })\n            return\n          }\n\n          console.log('ðŸ”„ Deployment reload: Comparing deployment IDs', {\n            stored: lastDeploymentIdRef.current,\n            current: currentDeploymentId,\n            match: currentDeploymentId === lastDeploymentIdRef.current,\n            timestamp: new Date().toISOString()\n          })\n\n          // Check if deployment ID has changed (new deployment)\n          if (currentDeploymentId !== lastDeploymentIdRef.current) {\n            console.log('ðŸ”„ Deployment reload: ðŸš¨ NEW DEPLOYMENT DETECTED!', {\n              oldDeploymentId: lastDeploymentIdRef.current,\n              newDeploymentId: currentDeploymentId,\n              timestamp: new Date().toISOString(),\n              action: 'Will reload page in 2 seconds'\n            })\n            \n            // Update stored deployment ID\n            lastDeploymentIdRef.current = currentDeploymentId\n            \n            // Broadcast to other tabs\n            if (broadcastChannelRef.current) {\n              try {\n                console.log('ðŸ”„ Deployment reload: Broadcasting to other tabs...', {\n                  deploymentId: currentDeploymentId,\n                  timestamp: new Date().toISOString()\n                })\n                broadcastChannelRef.current.postMessage({ \n                  type: 'new-deployment', \n                  deploymentId: currentDeploymentId \n                })\n                console.log('ðŸ”„ Deployment reload: âœ… Broadcast sent to other tabs')\n              } catch (error) {\n                console.warn('ðŸ”„ Deployment reload: âŒ Failed to broadcast to other tabs', error)\n              }\n            } else {\n              console.log('ðŸ”„ Deployment reload: âš ï¸ BroadcastChannel not available - skipping cross-tab notification')\n            }\n\n            // Set flag to prevent multiple reloads\n            isReloadingRef.current = true\n            console.log('ðŸ”„ Deployment reload: Reload flag set to prevent multiple reloads')\n\n            // Show a brief message to user\n            if (typeof window !== 'undefined' && window.document) {\n              console.log('ðŸ”„ Deployment reload: Creating user notification...')\n              const notification = document.createElement('div')\n              notification.textContent = 'New version available. Reloading...'\n              notification.style.cssText = `\n                position: fixed;\n                top: 20px;\n                right: 20px;\n                background: #5046E5;\n                color: white;\n                padding: 12px 24px;\n                border-radius: 8px;\n                z-index: 9999;\n                font-family: system-ui, -apple-system, sans-serif;\n                font-size: 14px;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n                animation: slideIn 0.3s ease-out;\n              `\n              \n              // Add animation\n              const style = document.createElement('style')\n              style.textContent = `\n                @keyframes slideIn {\n                  from {\n                    transform: translateX(100%);\n                    opacity: 0;\n                  }\n                  to {\n                    transform: translateX(0);\n                    opacity: 1;\n                  }\n                }\n              `\n              document.head.appendChild(style)\n              document.body.appendChild(notification)\n\n              // Remove notification after 2 seconds and reload\n              console.log('ðŸ”„ Deployment reload: â±ï¸ Setting 2-second delay before reload...', {\n                timestamp: new Date().toISOString(),\n                reloadTime: new Date(Date.now() + 2000).toISOString()\n              })\n              \n              const reloadTimeout = setTimeout(() => {\n                console.log('ðŸ”„ Deployment reload: ðŸ”„ EXECUTING HARD RELOAD NOW!', {\n                  timestamp: new Date().toISOString(),\n                  deploymentId: currentDeploymentId\n                })\n                \n                try {\n                  if (notification.parentNode) {\n                    notification.parentNode.removeChild(notification)\n                    console.log('ðŸ”„ Deployment reload: âœ… Notification removed')\n                  }\n                  if (style.parentNode) {\n                    style.parentNode.removeChild(style)\n                    console.log('ðŸ”„ Deployment reload: âœ… Style removed')\n                  }\n                  // Hard refresh with cache bypass\n                  // Note: reload() bypasses cache in modern browsers\n                  console.log('ðŸ”„ Deployment reload: ðŸš€ Calling window.location.reload()...')\n                  window.location.reload()\n                } catch (error) {\n                  console.warn('ðŸ”„ Deployment reload: âŒ Error during reload', error)\n                  // Fallback: try direct navigation\n                  console.log('ðŸ”„ Deployment reload: ðŸ”„ Trying fallback reload method...')\n                  window.location.href = window.location.href\n                }\n              }, 2000)\n\n              // Store timeout for potential cleanup\n              // Note: This will be cleared on page reload anyway\n            } else {\n              // Fallback: immediate reload\n              console.log('ðŸ”„ Deployment reload: ðŸ”„ Executing immediate reload (fallback)...', {\n                timestamp: new Date().toISOString(),\n                deploymentId: currentDeploymentId\n              })\n              window.location.reload()\n            }\n          } else {\n            console.log('ðŸ”„ Deployment reload: âœ… Same deployment ID - no reload needed', {\n              deploymentId: currentDeploymentId,\n              timestamp: new Date().toISOString()\n            })\n          }\n        } else {\n          console.warn('ðŸ”„ Deployment reload: âš ï¸ Invalid API response structure', {\n            hasSuccess: 'success' in data,\n            hasDeployment: 'deployment' in data,\n            data: data\n          })\n        }\n      } catch (error) {\n        console.warn('ðŸ”„ Deployment reload: âŒ Error checking deployment', {\n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined,\n          timestamp: new Date().toISOString()\n        })\n      } finally {\n        setIsChecking(false)\n        console.log('ðŸ”„ Deployment reload: Check completed', {\n          isChecking: false,\n          timestamp: new Date().toISOString()\n        })\n      }\n    }\n\n    // Initial check after a short delay\n    console.log('ðŸ”„ Deployment reload: â±ï¸ Scheduling initial check in 5 seconds...', {\n      timestamp: new Date().toISOString(),\n      checkTime: new Date(Date.now() + 5000).toISOString()\n    })\n    \n    const initialTimeout = setTimeout(() => {\n      console.log('ðŸ”„ Deployment reload: ðŸ• Initial check triggered (5 seconds after page load)')\n      checkDeployment()\n    }, 5000) // Wait 5 seconds after page load\n\n    // Set up polling interval (check every 2 minutes)\n    console.log('ðŸ”„ Deployment reload: â±ï¸ Setting up polling interval (every 2 minutes)...', {\n      interval: '2 minutes',\n      timestamp: new Date().toISOString()\n    })\n    \n    checkIntervalRef.current = setInterval(() => {\n      console.log('ðŸ”„ Deployment reload: ðŸ• Polling interval triggered (2 minutes elapsed)')\n      checkDeployment()\n    }, 2 * 60 * 1000) // 2 minutes\n\n    // Also check when page becomes visible (user returns to tab)\n    const handleVisibilityChange = () => {\n      if (!document.hidden && !isReloadingRef.current) {\n        console.log('ðŸ”„ Deployment reload: ðŸ‘ï¸ Page became visible - checking for new deployment...', {\n          timestamp: new Date().toISOString(),\n          wasHidden: document.hidden\n        })\n        checkDeployment()\n      } else if (document.hidden) {\n        console.log('ðŸ”„ Deployment reload: ðŸ‘ï¸ Page hidden - skipping check', {\n          timestamp: new Date().toISOString()\n        })\n      }\n    }\n\n    document.addEventListener('visibilitychange', handleVisibilityChange)\n    console.log('ðŸ”„ Deployment reload: âœ… Visibility change listener added')\n\n    console.log('ðŸ”„ Deployment reload: âœ… All setup complete!', {\n      initialCheckDelay: '5 seconds',\n      pollingInterval: '2 minutes',\n      broadcastChannel: broadcastChannelRef.current ? 'enabled' : 'disabled',\n      timestamp: new Date().toISOString()\n    })\n\n    // Cleanup\n    return () => {\n      console.log('ðŸ”„ Deployment reload: ðŸ§¹ Cleaning up...', {\n        timestamp: new Date().toISOString()\n      })\n      \n      clearTimeout(initialTimeout)\n      console.log('ðŸ”„ Deployment reload: âœ… Initial timeout cleared')\n      \n      if (checkIntervalRef.current) {\n        clearInterval(checkIntervalRef.current)\n        console.log('ðŸ”„ Deployment reload: âœ… Polling interval cleared')\n      }\n      \n      if (broadcastChannelRef.current) {\n        broadcastChannelRef.current.close()\n        console.log('ðŸ”„ Deployment reload: âœ… BroadcastChannel closed')\n      }\n      \n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n      console.log('ðŸ”„ Deployment reload: âœ… Visibility change listener removed')\n      \n      console.log('ðŸ”„ Deployment reload: âœ… Cleanup complete')\n    }\n  }, [])\n\n  return { isChecking }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 852, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useUnifiedSocket.ts"],"sourcesContent":["import { useEffect, useState, useCallback, useRef } from 'react'\nimport { io, Socket } from 'socket.io-client'\nimport { getApiUrl } from '@/lib/config'\nimport { apiService, PendingWorkflow } from '@/lib/api-service'\nimport { useNotificationStore } from '@/components/ui/global-notification'\n\nexport interface VideoStatusUpdate {\n  videoId: string\n  status: 'pending' | 'processing' | 'completed' | 'success' | 'failed'\n  message: string\n  downloadUrl?: string\n  timestamp: string\n}\n\nexport interface AvatarStatusUpdate {\n  step: string\n  status: 'progress' | 'success' | 'error'\n  data?: {\n    message: string\n    error?: string\n    avatarId?: string\n    previewImageUrl?: string\n  }\n  timestamp: string\n}\n\nexport interface VideoAvatarStatusUpdate {\n  notificationId: string\n  avatarId: string\n  step: string\n  status: 'progress' | 'completed' | 'error'\n  data?: {\n    message: string\n    error?: string\n    avatarId?: string\n    progress?: number\n    avatar_name?: string\n    preview_image_url?: string\n    preview_video_url?: string\n    default_voice_id?: string\n  }\n  timestamp: string\n}\n\nexport interface ScheduleStatusUpdate {\n  scheduleId: string\n  status: 'processing' | 'ready' | 'failed'\n  message: string\n  data?: {\n    scheduleId?: string\n    error?: string\n    generationTime?: number\n  }\n  timestamp: string\n}\n\nexport interface VideoInProgress {\n  id: string\n  title: string\n  status: 'processing'\n  timestamp: string\n  message: string\n}\n\nexport interface UnifiedSocketState {\n  socket: Socket | null\n  isConnected: boolean\n  videoUpdates: VideoStatusUpdate[]\n  avatarUpdates: AvatarStatusUpdate[]\n  videoAvatarUpdates: VideoAvatarStatusUpdate[]\n  scheduleUpdates: ScheduleStatusUpdate[]\n  latestVideoUpdate: VideoStatusUpdate | null\n  latestAvatarUpdate: AvatarStatusUpdate | null\n  latestVideoAvatarUpdate: VideoAvatarStatusUpdate | null\n  latestScheduleUpdate: ScheduleStatusUpdate | null\n  isVideoProcessing: boolean\n  isAvatarProcessing: boolean\n  isVideoAvatarProcessing: boolean\n  isScheduleProcessing: boolean\n  pendingVideos: VideoInProgress[]\n  addPendingVideo: (video: VideoInProgress) => void\n  removePendingVideo: () => void\n  clearVideoUpdates: () => void\n  clearCompletedVideoUpdates: () => void\n  clearAvatarUpdates: () => void\n  clearVideoAvatarUpdates: () => void\n  clearScheduleUpdates: () => void\n  syncPendingVideos: (userId: string) => Promise<void>\n}\n\nconst PENDING_VIDEOS_KEY = 'pendingVideos'\n\nexport const useUnifiedSocket = (userId: string | null): UnifiedSocketState => {\n  const [socket, setSocket] = useState<Socket | null>(null)\n  const [isConnected, setIsConnected] = useState(false)\n  const [videoUpdates, setVideoUpdates] = useState<VideoStatusUpdate[]>([])\n  const [avatarUpdates, setAvatarUpdates] = useState<AvatarStatusUpdate[]>([])\n  const [videoAvatarUpdates, setVideoAvatarUpdates] = useState<VideoAvatarStatusUpdate[]>([])\n  const [scheduleUpdates, setScheduleUpdates] = useState<ScheduleStatusUpdate[]>([])\n  const [pendingVideos, setPendingVideos] = useState<VideoInProgress[]>([])\n  const { showNotification } = useNotificationStore()\n  \n  // Track processed events to prevent duplicates\n  const processedEvents = useRef(new Set<string>())\n  const socketConnectedHandlers = useRef<Set<() => void>>(new Set())\n  // Track if we've synced with DB to avoid duplicate syncing\n  const hasSyncedWithDB = useRef(false)\n  // Track if we should skip saving to localStorage (to prevent overwriting after DB sync)\n  const skipSaveToLocalStorage = useRef(false)\n  // Track failed videos to avoid duplicate notifications\n  const notifiedFailedVideos = useRef(new Set<string>())\n  // Track completed videos to avoid duplicate notifications\n  const notifiedCompletedVideos = useRef(new Set<string>())\n\n  const clearVideoUpdates = useCallback(() => {\n    setVideoUpdates([])\n  }, [])\n\n  const clearCompletedVideoUpdates = useCallback(() => {\n    setVideoUpdates(prev => prev.filter(update => \n      update.status !== 'completed' && update.status !== 'success' && update.status !== 'failed'\n    ))\n  }, [])\n\n  const clearAvatarUpdates = useCallback(() => {\n    setAvatarUpdates([])\n  }, [])\n\n  const clearVideoAvatarUpdates = useCallback(() => {\n    setVideoAvatarUpdates([])\n  }, [])\n\n  const clearScheduleUpdates = useCallback(() => {\n    setScheduleUpdates([])\n  }, [])\n\n  const addPendingVideo = useCallback((video: VideoInProgress) => {\n    setPendingVideos(prev => [...prev, video])\n    console.log('âž• Added pending video:', video)\n  }, [])\n\n  const removePendingVideo = useCallback(() => {\n    setPendingVideos(prev => {\n      if (prev.length === 0) {\n        console.log('âš ï¸ No pending videos to remove')\n        return prev\n      }\n      const removed = prev[0]\n      const remaining = prev.slice(1)\n      console.log('âž– Removed pending video (FIFO):', removed)\n      return remaining\n    })\n  }, [])\n\n  // Sync pending videos with database - DB is the source of truth\n  const syncPendingVideos = useCallback(async (userId: string) => {\n    try {\n      console.log('ðŸ” Syncing pending videos with DB for user:', userId)\n      const result = await apiService.checkPendingWorkflows(userId)\n      \n      if (result.success && result.data) {\n        const { workflows } = result.data\n        \n        // Log all workflows to debug status values\n        console.log('ðŸ“Š All workflows from DB:', workflows.map((w: PendingWorkflow) => ({ \n          id: w._id, \n          status: w.status, \n          title: w.title \n        })))\n        \n        // Check for failed workflows and show notifications\n        // Collect notifications to show after state update (to avoid React warning)\n        const notificationsToShow: Array<{ message: string; type: 'error' | 'success' }> = []\n        \n        // Use functional update to access current pending videos\n        setPendingVideos(prev => {\n          // Create a map of current video IDs (both DB format and temporary format)\n          const currentVideoIds = new Set<string>()\n          const currentVideoTitles = new Map<string, string>() // Map title to video ID\n          \n          prev.forEach(v => {\n            currentVideoIds.add(v.id)\n            currentVideoTitles.set(v.title, v.id)\n            \n            // Also extract workflow ID if it's in DB format (video-{_id}-{executionId})\n            const match = v.id.match(/^video-(.+)-(.+)$/)\n            if (match) {\n              currentVideoIds.add(match[1]) // Add workflow _id\n            }\n          })\n          \n          // Find failed workflows\n          const failedWorkflows = workflows.filter(\n            (workflow: PendingWorkflow) => workflow.status === 'failed'\n          )\n          \n          // Collect failed video notifications (only once per video)\n          failedWorkflows.forEach((workflow: PendingWorkflow) => {\n            const workflowId = workflow._id\n            const videoId = `video-${workflow._id}-${workflow.executionId}`\n            const videoTitle = workflow.title || 'Video'\n            \n            // Check if this failed workflow matches any current pending video\n            // Match by: workflow _id, video ID format, or title\n            const matchesCurrentVideo = \n              currentVideoIds.has(workflowId) || \n              currentVideoIds.has(videoId) ||\n              currentVideoTitles.has(videoTitle)\n            \n            if (matchesCurrentVideo && !notifiedFailedVideos.current.has(videoId)) {\n              notifiedFailedVideos.current.add(videoId)\n              notificationsToShow.push({\n                message: `Video \"${videoTitle}\" creation failed. Please try creating it again.`,\n                type: 'error'\n              })\n              console.log('âŒ Video failed:', videoTitle, workflow._id)\n            }\n          })\n          \n          // Find completed workflows\n          const completedWorkflows = workflows.filter(\n            (workflow: PendingWorkflow) => workflow.status === 'completed'\n          )\n          \n          // Collect completed video notifications (only once per video)\n          completedWorkflows.forEach((workflow: PendingWorkflow) => {\n            const workflowId = workflow._id\n            const videoId = `video-${workflow._id}-${workflow.executionId}`\n            const videoTitle = workflow.title || 'Video'\n            \n            // Check if this completed workflow matches any current pending video\n            // Match by: workflow _id, video ID format, or title\n            const matchesCurrentVideo = \n              currentVideoIds.has(workflowId) || \n              currentVideoIds.has(videoId) ||\n              currentVideoTitles.has(videoTitle)\n            \n            if (matchesCurrentVideo && !notifiedCompletedVideos.current.has(videoId)) {\n              notifiedCompletedVideos.current.add(videoId)\n              notificationsToShow.push({\n                message: `Video \"${videoTitle}\" is ready! You can view it in your gallery.`,\n                type: 'success'\n              })\n              console.log('âœ… Video completed:', videoTitle, workflow._id)\n            }\n          })\n          \n          return prev // Return unchanged for now, we'll update below\n        })\n        \n        // Show notifications after state update (defer to avoid React warning)\n        if (notificationsToShow.length > 0) {\n          setTimeout(() => {\n            notificationsToShow.forEach(({ message, type }) => {\n              showNotification(message, type, type === 'error' ? 15000 : undefined)\n            })\n          }, 0)\n        }\n        \n        // Filter workflows that are not completed or failed (include all active states)\n        const pendingWorkflows = workflows.filter(\n          (workflow: PendingWorkflow) => \n            workflow.status !== 'completed' && workflow.status !== 'failed'\n        )\n        \n        console.log('ðŸ“Š Found pending workflows from DB:', pendingWorkflows.length, 'workflows')\n        \n        // DB is the source of truth - always sync with DB\n        if (typeof window !== 'undefined') {\n          // Create videos from DB workflows\n          const videosFromDB: VideoInProgress[] = pendingWorkflows.map((workflow: PendingWorkflow, index: number) => ({\n            id: `video-${workflow._id}-${workflow.executionId}`,\n            title: workflow.title || `Video ${index + 1}`,\n            status: 'processing',\n            timestamp: workflow.createdAt || new Date().toISOString(),\n            message: 'Your video creation is in progress'\n          }))\n          \n          // Remove failed videos from pending list (they're already filtered out above)\n          // This will automatically remove them from toasts and tiles\n          skipSaveToLocalStorage.current = true\n          setPendingVideos(videosFromDB)\n          hasSyncedWithDB.current = true\n          console.log('âœ… Synced pending videos with DB (source of truth):', videosFromDB.length, 'videos')\n          \n          // Clean up notified failed/completed videos that are no longer in the system\n          const currentVideoIds = new Set(videosFromDB.map(v => v.id))\n          notifiedFailedVideos.current.forEach(videoId => {\n            if (!currentVideoIds.has(videoId)) {\n              // Keep in set for a while to avoid duplicate notifications if user creates same video again\n              // Will be cleaned up on logout or after some time\n            }\n          })\n          notifiedCompletedVideos.current.forEach(videoId => {\n            if (!currentVideoIds.has(videoId)) {\n              // Keep in set for a while to avoid duplicate notifications if user creates same video again\n              // Will be cleaned up on logout or after some time\n            }\n          })\n          \n          // Reset skip flag after a short delay\n          setTimeout(() => {\n            skipSaveToLocalStorage.current = false\n          }, 100)\n        }\n      } else {\n        // If DB check fails, try to load from localStorage as fallback\n        if (typeof window !== 'undefined' && !hasSyncedWithDB.current) {\n          try {\n            const saved = localStorage.getItem(PENDING_VIDEOS_KEY)\n            if (saved) {\n              const parsed = JSON.parse(saved) as VideoInProgress[]\n              if (Array.isArray(parsed) && parsed.length > 0) {\n                skipSaveToLocalStorage.current = true\n                setPendingVideos(parsed)\n                console.log('ðŸ“¦ Loaded pending videos from localStorage (DB unavailable):', parsed.length, 'videos')\n                setTimeout(() => {\n                  skipSaveToLocalStorage.current = false\n                }, 100)\n              }\n            }\n          } catch (error) {\n            console.warn('Failed to load pending videos from localStorage:', error)\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to sync pending videos:', error)\n      // Fallback to localStorage if DB sync fails\n      if (typeof window !== 'undefined' && !hasSyncedWithDB.current) {\n        try {\n          const saved = localStorage.getItem(PENDING_VIDEOS_KEY)\n          if (saved) {\n            const parsed = JSON.parse(saved) as VideoInProgress[]\n            if (Array.isArray(parsed) && parsed.length > 0) {\n              skipSaveToLocalStorage.current = true\n              setPendingVideos(parsed)\n              console.log('ðŸ“¦ Loaded pending videos from localStorage (fallback):', parsed.length, 'videos')\n              setTimeout(() => {\n                skipSaveToLocalStorage.current = false\n              }, 100)\n            }\n          }\n        } catch (err) {\n          console.warn('Failed to load pending videos from localStorage:', err)\n        }\n      }\n    }\n  }, [showNotification])\n\n  // Initial sync with DB on mount if userId is available\n  useEffect(() => {\n    if (userId && !hasSyncedWithDB.current) {\n      console.log('ðŸ”„ Initial sync with DB on mount')\n      syncPendingVideos(userId)\n    }\n  }, [userId, syncPendingVideos])\n\n  // Continuous polling every 20 seconds regardless of connection status\n  useEffect(() => {\n    if (!userId) return\n\n    const pollInterval = setInterval(() => {\n      console.log('ðŸ”„ Periodic polling: syncing pending videos with DB (every 20s)')\n      syncPendingVideos(userId)\n    }, 60000) // Poll every 60 seconds continuously\n\n    return () => clearInterval(pollInterval)\n  }, [userId, syncPendingVideos])\n\n  // Save pending videos to localStorage whenever they change\n  useEffect(() => {\n    if (userId && typeof window !== 'undefined' && !skipSaveToLocalStorage.current) {\n      try {\n        if (pendingVideos.length > 0) {\n          localStorage.setItem(PENDING_VIDEOS_KEY, JSON.stringify(pendingVideos))\n          console.log('ðŸ’¾ Saved pending videos to localStorage:', pendingVideos.length, 'videos')\n        } else {\n          localStorage.removeItem(PENDING_VIDEOS_KEY)\n          console.log('ðŸ§¹ Cleared pending videos from localStorage')\n        }\n      } catch (error) {\n        console.warn('Failed to save pending videos to localStorage:', error)\n      }\n    } else if (skipSaveToLocalStorage.current) {\n      console.log('â­ï¸ Skipping save to localStorage (just synced with DB)')\n    }\n  }, [pendingVideos, userId])\n\n  // Get latest updates\n  const latestVideoUpdate = videoUpdates.length > 0 ? videoUpdates[videoUpdates.length - 1] : null\n  const latestAvatarUpdate = avatarUpdates.length > 0 ? avatarUpdates[avatarUpdates.length - 1] : null\n  const latestVideoAvatarUpdate = videoAvatarUpdates.length > 0 ? videoAvatarUpdates[videoAvatarUpdates.length - 1] : null\n  const latestScheduleUpdate = scheduleUpdates.length > 0 ? scheduleUpdates[scheduleUpdates.length - 1] : null\n\n  // Check processing states\n  const isVideoProcessing = videoUpdates.some(update => \n    update.status === 'pending' || update.status === 'processing'\n  )\n  const isAvatarProcessing = avatarUpdates.some(update => \n    update.status === 'progress' && update.step !== 'ready'\n  )\n  const isVideoAvatarProcessing = videoAvatarUpdates.some(update => \n    update.status === 'progress'\n  )\n  const isScheduleProcessing = scheduleUpdates.some(update => \n    update.status === 'processing'\n  )\n\n  useEffect(() => {\n    if (!userId) {\n      // Clean up socket and clear all data if no user\n      if (socket) {\n        socket.close()\n        setSocket(null)\n        setIsConnected(false)\n      }\n      setVideoUpdates([])\n      setAvatarUpdates([])\n      setVideoAvatarUpdates([])\n      setScheduleUpdates([])\n      \n      // Only clear pendingVideos if this is a real logout (socket exists)\n      // Don't clear on initial mount when userId is temporarily null\n      if (socket) {\n        // This is a real logout (socket exists), clear everything\n        setPendingVideos([])\n        if (typeof window !== 'undefined') {\n          try {\n            localStorage.removeItem(PENDING_VIDEOS_KEY)\n            console.log('ðŸ§¹ Cleared pending videos from localStorage on logout')\n          } catch (error) {\n            console.warn('Failed to clear pending videos from localStorage:', error)\n          }\n        }\n        hasSyncedWithDB.current = false\n        notifiedFailedVideos.current.clear()\n        notifiedCompletedVideos.current.clear()\n        console.log('ðŸ§¹ User logged out - cleared all socket data')\n      } else {\n        // This is initial mount (no socket yet), sync with DB instead of clearing\n        console.log('â­ï¸ Initial mount - will sync pending videos with DB on connection')\n      }\n      \n      processedEvents.current.clear()\n      socketConnectedHandlers.current.clear()\n      return\n    }\n\n    // Get backend URL from config\n    const backendUrl = getApiUrl('').replace('/api', '')\n    console.log('ðŸ”Œ Unified WebSocket connecting to:', backendUrl)\n    \n    // Create new socket connection\n    const newSocket = io(backendUrl, {\n      transports: ['websocket'],\n      autoConnect: true,\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n    })\n\n    // Connection event handlers\n    newSocket.on('connect', () => {\n      console.log('ðŸ”Œ Unified WebSocket connected')\n      setIsConnected(true)\n      \n      // Join user-specific room\n      newSocket.emit('join-room', userId)\n      console.log(`ðŸ  Joined room for user: ${userId}`)\n      \n      // Emit test connection\n      newSocket.emit('test-connection', { userId, timestamp: new Date().toISOString() })\n      \n      // Trigger socket connected event for any registered handlers\n      socketConnectedHandlers.current.forEach(handler => {\n        try {\n          handler()\n        } catch (error) {\n          console.error('Error in socket connected handler:', error)\n        }\n      })\n      \n      // Sync pending videos with DB after connection (DB is source of truth)\n      syncPendingVideos(userId)\n    })\n\n    newSocket.on('disconnect', (reason: any) => {\n      console.log('ðŸ”Œ Unified WebSocket disconnected:', reason)\n      setIsConnected(false)\n    })\n\n    newSocket.on('connect_error', (error: any) => {\n      console.error('ðŸ”Œ Unified WebSocket connection error:', error)\n      setIsConnected(false)\n    })\n\n    newSocket.on('reconnect', (attemptNumber: number) => {\n      console.log(`ðŸ”Œ Unified WebSocket reconnected after ${attemptNumber} attempts`)\n      setIsConnected(true)\n      newSocket.emit('join-room', userId)\n      \n      // Trigger socket connected event for reconnection\n      socketConnectedHandlers.current.forEach(handler => {\n        try {\n          handler()\n        } catch (error) {\n          console.error('Error in socket reconnected handler:', error)\n        }\n      })\n      \n      // Sync pending videos with DB after reconnection (DB is source of truth)\n      syncPendingVideos(userId)\n    })\n\n    // Video status updates\n    newSocket.on('video-download-update', (update: any) => {\n      console.log('ðŸŽ¥ Video update received:', update)\n      \n      // Handle both videoId and id fields, and allow processing without strict videoId validation\n      const videoId = update.videoId || update.id || 'processing-video'\n      \n      const eventKey = `video-${videoId}-${update.timestamp || Date.now()}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸŽ¥ Duplicate video event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      \n      // Map the socket event format to our internal format\n      let status = update.status || update.type || 'pending'\n      \n      // Handle the specific case where type: 'progress' should map to status: 'processing'\n      if (update.type === 'progress' && update.status === 'processing') {\n        status = 'processing'\n      } else if (update.type === 'progress') {\n        status = 'processing'\n      }\n      \n      const videoUpdate: VideoStatusUpdate = {\n        videoId: videoId,\n        status: status as 'pending' | 'processing' | 'completed' | 'success' | 'failed',\n        message: update.message || update.data?.message || 'Video processing update',\n        downloadUrl: update.downloadUrl || update.data?.downloadUrl,\n        timestamp: update.timestamp || new Date().toISOString()\n      }\n      \n      console.log('ðŸŽ¥ Processed video update:', videoUpdate)\n      setVideoUpdates(prev => [...prev, videoUpdate])\n\n      // Add video to progress tracking when processing status arrives\n      // Only add if we don't have videos from DB sync (to avoid duplicates)\n      if (status === 'processing' || status === 'pending') {\n        // If we synced with DB, don't add from socket events - DB is source of truth\n        if (hasSyncedWithDB.current) {\n          console.log('ðŸ“¦ Already synced with DB, skipping socket event addition (DB is source of truth)')\n          return\n        }\n        \n        setPendingVideos(prev => {\n          // If we already have videos, don't add duplicates\n          if (prev.length > 0) {\n            console.log('ðŸ“¦ Already have pending videos, skipping socket event addition')\n            return prev\n          }\n          \n          // Only add one video if we have no videos at all\n          const newVideo: VideoInProgress = {\n            id: `video-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n            title: update.title || update.data?.title || 'Processing Video...',\n            status: 'processing',\n            timestamp: update.timestamp || new Date().toISOString(),\n            message: update.message || update.data?.message || 'Your video creation is in progress'\n          }\n          \n          console.log('âž• Added pending video from socket event:', newVideo)\n          return [...prev, newVideo]\n        })\n      }\n\n      // Remove one video from progress tracking when success/completed arrives (FIFO)\n      // Verify in DB first before removing\n      if (status === 'completed' || status === 'success') {\n        console.log('âœ… Video completed/success - verifying in DB before removing (FIFO)')\n        \n        // Helper function to show notification and remove video\n        const showNotificationAndRemove = (prev: VideoInProgress[], context: string) => {\n          if (prev.length === 0) {\n            return prev\n          }\n          const removed = prev[0]\n          const videoId = removed.id\n          const videoTitle = removed.title || 'Video'\n          \n          // Show notification if not already notified\n          if (!notifiedCompletedVideos.current.has(videoId)) {\n            notifiedCompletedVideos.current.add(videoId)\n            showNotification(\n              `Video \"${videoTitle}\" is ready! You can view it in your gallery.`,\n              'success'\n            )\n            console.log('âœ… Video completed notification shown:', videoTitle, videoId)\n          }\n          \n          const remaining = prev.slice(1)\n          console.log(`âž– Removed pending video (FIFO, ${context}):`, removed)\n          return remaining\n        }\n        \n        // Verify completion in DB before removing\n        if (userId) {\n          // First sync with DB to get latest state\n          syncPendingVideos(userId).then(() => {\n            // After DB sync, check if we should remove one video\n            // DB sync already updated the state, so we just need to verify count\n            apiService.checkPendingWorkflows(userId).then(result => {\n              if (result.success && result.data) {\n                const pendingWorkflows = result.data.workflows.filter(\n                  (workflow: PendingWorkflow) => \n                    workflow.status !== 'completed' && workflow.status !== 'failed'\n                )\n                \n                // Get current local state count\n                setPendingVideos(prev => {\n                  // Only remove if DB has fewer pending items than our local state\n                  if (pendingWorkflows.length < prev.length) {\n                    return showNotificationAndRemove(prev, 'DB verified')\n                  } else {\n                    console.log('â¸ï¸ DB verification: keeping pending videos (count matches)')\n                    return prev\n                  }\n                })\n              } else {\n                // If DB check fails, still remove (FIFO assumption)\n                setPendingVideos(prev => showNotificationAndRemove(prev, 'DB check failed'))\n              }\n            }).catch(() => {\n              // If DB check fails, still remove (FIFO assumption)\n              setPendingVideos(prev => showNotificationAndRemove(prev, 'DB error'))\n            })\n          }).catch(() => {\n            // If sync fails, still remove (FIFO assumption)\n            setPendingVideos(prev => showNotificationAndRemove(prev, 'sync failed'))\n          })\n        } else {\n          // No userId, just remove (FIFO)\n          setPendingVideos(prev => {\n            if (prev.length === 0) {\n              console.log('âš ï¸ No pending videos to remove')\n              return prev\n            }\n            return showNotificationAndRemove(prev, 'no userId')\n          })\n        }\n      }\n\n      // Remove one video from progress tracking when error/failed arrives (FIFO)\n      // Verify in DB first before removing\n      if (status === 'error' || status === 'failed') {\n        console.log('âŒ Video error/failed - verifying in DB before removing (FIFO)')\n        \n        // Helper function to show error notification and remove video\n        const showErrorNotificationAndRemove = (prev: VideoInProgress[], context: string, errorMessage?: string) => {\n          if (prev.length === 0) {\n            return prev\n          }\n          const removed = prev[0]\n          const videoId = removed.id\n          const videoTitle = removed.title || 'Video'\n          \n          // Show notification if not already notified\n          if (!notifiedFailedVideos.current.has(videoId)) {\n            notifiedFailedVideos.current.add(videoId)\n            // Use socket message if available, otherwise use user-friendly fallback\n            const message = errorMessage || `Video \"${videoTitle}\" creation failed. Please try creating it again.`\n            showNotification(message, 'error', 15000)\n            console.log('âŒ Video failed notification shown:', videoTitle, videoId, message)\n          }\n          \n          const remaining = prev.slice(1)\n          console.log(`âž– Removed pending video (FIFO, ${context}):`, removed)\n          return remaining\n        }\n        \n        // Get error message from socket update\n        const errorMessage = update.message || update.data?.message || undefined\n        \n        // Verify failure in DB before removing\n        if (userId) {\n          // First sync with DB to get latest state\n          syncPendingVideos(userId).then(() => {\n            // After DB sync, check if we should remove one video\n            // DB sync already updated the state, so we just need to verify count\n            apiService.checkPendingWorkflows(userId).then(result => {\n              if (result.success && result.data) {\n                const pendingWorkflows = result.data.workflows.filter(\n                  (workflow: PendingWorkflow) => \n                    workflow.status !== 'completed' && workflow.status !== 'failed'\n                )\n                \n                // Get current local state count\n                setPendingVideos(prev => {\n                  // Only remove if DB has fewer pending items than our local state\n                  if (pendingWorkflows.length < prev.length) {\n                    return showErrorNotificationAndRemove(prev, 'DB verified', errorMessage)\n                  } else {\n                    console.log('â¸ï¸ DB verification: keeping pending videos (count matches)')\n                    return prev\n                  }\n                })\n              } else {\n                // If DB check fails, still remove (FIFO assumption)\n                setPendingVideos(prev => showErrorNotificationAndRemove(prev, 'DB check failed', errorMessage))\n              }\n            }).catch(() => {\n              // If DB check fails, still remove (FIFO assumption)\n              setPendingVideos(prev => showErrorNotificationAndRemove(prev, 'DB error', errorMessage))\n            })\n          }).catch(() => {\n            // If sync fails, still remove (FIFO assumption)\n            setPendingVideos(prev => showErrorNotificationAndRemove(prev, 'sync failed', errorMessage))\n          })\n        } else {\n          // No userId, just remove (FIFO)\n          setPendingVideos(prev => {\n            if (prev.length === 0) {\n              console.log('âš ï¸ No pending videos to remove')\n              return prev\n            }\n            return showErrorNotificationAndRemove(prev, 'no userId', errorMessage)\n          })\n        }\n      }\n    })\n\n    // Avatar status updates\n    newSocket.on('photo-avatar-update', (update: AvatarStatusUpdate) => {\n      console.log('ðŸ“¸ Avatar update received:', update)\n      \n      const eventKey = `avatar-${update.step}-${update.timestamp}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸ“¸ Duplicate avatar event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      setAvatarUpdates(prev => [...prev, update])\n    })\n\n    // Avatar completion\n    newSocket.on('avatar-ready', (data: { avatarId: string; previewImageUrl?: string }) => {\n      console.log('âœ… Avatar ready:', data)\n      \n      const timestamp = new Date().toISOString()\n      const eventKey = `avatar-ready-${data.avatarId}-${timestamp}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸ“¸ Duplicate avatar-ready event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      \n      const completionUpdate: AvatarStatusUpdate = {\n        step: 'complete',\n        status: 'success',\n        data: {\n          message: 'Your avatar is ready!',\n          avatarId: data.avatarId,\n          previewImageUrl: data.previewImageUrl\n        },\n        timestamp: timestamp\n      }\n      \n      setAvatarUpdates(prev => [...prev, completionUpdate])\n    })\n\n    // Video Avatar status updates\n    newSocket.on('video-avatar-update', (update: VideoAvatarStatusUpdate) => {\n      console.log('ðŸŽ¬ Video Avatar update received:', update)\n      \n      const eventKey = `video-avatar-${update.step}-${update.timestamp}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸŽ¬ Duplicate video avatar event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n      setVideoAvatarUpdates(prev => [...prev, update])\n      \n      // Auto-disconnect on completion or error as requested\n      if (update.status === 'completed' || update.status === 'error') {\n        console.log('ðŸŽ¬ Video avatar process finished, disconnecting socket')\n        setTimeout(() => {\n          newSocket.disconnect()\n        }, 1000) // Small delay to ensure final update is processed\n      }\n    })\n\n    // Schedule status updates\n    newSocket.on('schedule-status', (data: any) => {\n      console.log('ðŸ“… Schedule status update received:', data)\n      \n      const eventKey = `schedule-status-${data.scheduleId || 'unknown'}-${data.timestamp || Date.now()}`\n      \n      if (processedEvents.current.has(eventKey)) {\n        console.log('ðŸ“… Duplicate schedule status event ignored:', eventKey)\n        return\n      }\n      \n      processedEvents.current.add(eventKey)\n        console.log('data', data)\n      const scheduleUpdate: ScheduleStatusUpdate = {\n        scheduleId: data.data.scheduleId || 'unknown',\n        status: data.status === 'ready' ? 'ready' : data.status === 'failed' ? 'failed' : 'processing',\n        message: data.message || (data.status === 'ready' ? 'Your schedule is ready!' : data.status === 'failed' ? 'Schedule generation failed. Please try again.' : 'Schedule generation started.'),\n        data: {\n          scheduleId: data.data.scheduleId,\n          error: data.error,\n          generationTime: data.generationTime\n        },\n        timestamp: data.timestamp || new Date().toISOString()\n      }\n      \n      console.log('ðŸ“… Processed schedule status update:', scheduleUpdate)\n      setScheduleUpdates(prev => [...prev, scheduleUpdate])\n      \n      // Auto-disconnect on completion or failure as requested\n      if (data.status === 'ready' || data.status === 'failed') {\n        console.log('ðŸ“… Schedule generation finished, disconnecting socket')\n        setTimeout(() => {\n          newSocket.disconnect()\n        }, 1000) // Small delay to ensure final update is processed\n      }\n    })\n\n    setSocket(newSocket)\n\n    // Store references for cleanup\n    const currentProcessedEvents = processedEvents.current\n    const currentSocketHandlers = socketConnectedHandlers.current\n\n    // Cleanup function\n    return () => {\n      console.log('ðŸ§¹ Cleaning up unified WebSocket connection')\n      currentProcessedEvents.clear()\n      currentSocketHandlers.clear()\n      newSocket.close()\n    }\n  }, [userId, syncPendingVideos]) // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Expose method to register socket connected handlers\n  useEffect(() => {\n    if (socket) {\n      // Add method to socket for external handlers\n      (socket as any).onSocketConnected = (handler: () => void) => {\n        socketConnectedHandlers.current.add(handler)\n        return () => {\n          socketConnectedHandlers.current.delete(handler)\n        }\n      }\n    }\n  }, [socket])\n\n  return {\n    socket,\n    isConnected,\n    videoUpdates,\n    avatarUpdates,\n    videoAvatarUpdates,\n    scheduleUpdates,\n    latestVideoUpdate,\n    latestAvatarUpdate,\n    latestVideoAvatarUpdate,\n    latestScheduleUpdate,\n    isVideoProcessing,\n    isAvatarProcessing,\n    isVideoAvatarProcessing,\n    isScheduleProcessing,\n    pendingVideos,\n    addPendingVideo,\n    removePendingVideo,\n    clearVideoUpdates,\n    clearCompletedVideoUpdates,\n    clearAvatarUpdates,\n    clearVideoAvatarUpdates,\n    clearScheduleUpdates,\n    syncPendingVideos\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1751, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useProcessingToasts.ts"],"sourcesContent":["import { useState, useCallback, useMemo } from 'react'\nimport { VideoInProgress } from './useUnifiedSocket'\n\nexport interface ProcessingToast {\n  id: string\n  title: string\n  message: string\n  timestamp: string\n  minimized: boolean\n}\n\nexport interface UseProcessingToastsReturn {\n  toasts: ProcessingToast[]\n  minimizedCount: number\n  minimizeToast: (id: string) => void\n  restoreToast: (id: string) => void\n  updateToasts: (videos: VideoInProgress[]) => void\n}\n\nexport function useProcessingToasts(): UseProcessingToastsReturn {\n  const [toasts, setToasts] = useState<ProcessingToast[]>([])\n\n  // Convert VideoInProgress[] to ProcessingToast[] and merge with existing minimize states\n  const updateToasts = useCallback((videos: VideoInProgress[]) => {\n    setToasts(prev => {\n      // Create a map of existing minimize states by ID\n      const minimizedMap = new Map<string, boolean>()\n      prev.forEach(toast => {\n        minimizedMap.set(toast.id, toast.minimized)\n      })\n\n      // Convert videos to toasts, preserving minimize state if toast already exists\n      const newToasts: ProcessingToast[] = videos.map(video => ({\n        id: video.id,\n        title: video.title,\n        message: video.message,\n        timestamp: video.timestamp,\n        minimized: minimizedMap.get(video.id) ?? false // Preserve existing minimize state or default to false\n      }))\n\n      // Return only toasts for videos that are still pending\n      // All toasts (including minimized ones) are removed when their video completes/fails\n      return newToasts\n    })\n  }, [])\n\n  const minimizeToast = useCallback((id: string) => {\n    setToasts(prev => \n      prev.map(toast => \n        toast.id === id ? { ...toast, minimized: true } : toast\n      )\n    )\n  }, [])\n\n  const restoreToast = useCallback((id: string) => {\n    setToasts(prev => \n      prev.map(toast => \n        toast.id === id ? { ...toast, minimized: false } : toast\n      )\n    )\n  }, [])\n\n  const minimizedCount = useMemo(() => {\n    return toasts.filter(toast => toast.minimized).length\n  }, [toasts])\n\n  return {\n    toasts,\n    minimizedCount,\n    minimizeToast,\n    restoreToast,\n    updateToasts\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;;;AAmBO,SAAS;;IACd,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,6LAAQ,EAAoB,EAAE;IAE1D,yFAAyF;IACzF,MAAM,eAAe,IAAA,gMAAW;yDAAC,CAAC;YAChC;iEAAU,CAAA;oBACR,iDAAiD;oBACjD,MAAM,eAAe,IAAI;oBACzB,KAAK,OAAO;yEAAC,CAAA;4BACX,aAAa,GAAG,CAAC,MAAM,EAAE,EAAE,MAAM,SAAS;wBAC5C;;oBAEA,8EAA8E;oBAC9E,MAAM,YAA+B,OAAO,GAAG;mFAAC,CAAA,QAAS,CAAC;gCACxD,IAAI,MAAM,EAAE;gCACZ,OAAO,MAAM,KAAK;gCAClB,SAAS,MAAM,OAAO;gCACtB,WAAW,MAAM,SAAS;gCAC1B,WAAW,aAAa,GAAG,CAAC,MAAM,EAAE,KAAK,MAAM,uDAAuD;4BACxG,CAAC;;oBAED,uDAAuD;oBACvD,qFAAqF;oBACrF,OAAO;gBACT;;QACF;wDAAG,EAAE;IAEL,MAAM,gBAAgB,IAAA,gMAAW;0DAAC,CAAC;YACjC;kEAAU,CAAA,OACR,KAAK,GAAG;0EAAC,CAAA,QACP,MAAM,EAAE,KAAK,KAAK;gCAAE,GAAG,KAAK;gCAAE,WAAW;4BAAK,IAAI;;;QAGxD;yDAAG,EAAE;IAEL,MAAM,eAAe,IAAA,gMAAW;yDAAC,CAAC;YAChC;iEAAU,CAAA,OACR,KAAK,GAAG;yEAAC,CAAA,QACP,MAAM,EAAE,KAAK,KAAK;gCAAE,GAAG,KAAK;gCAAE,WAAW;4BAAM,IAAI;;;QAGzD;wDAAG,EAAE;IAEL,MAAM,iBAAiB,IAAA,4LAAO;uDAAC;YAC7B,OAAO,OAAO,MAAM;+DAAC,CAAA,QAAS,MAAM,SAAS;8DAAE,MAAM;QACvD;sDAAG;QAAC;KAAO;IAEX,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF;GAtDgB"}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useVideoUpload.ts"],"sourcesContent":["import { useRef, useState } from 'react';\n\nexport interface ValidationError {\n  type: string;\n  message: string;\n}\n\nexport interface VideoUploadState {\n  file: File | null;\n  preview: string | null;\n  isValidating: boolean;\n  isValid: boolean;\n  errors: ValidationError[];\n}\n\nexport const useVideoUpload = () => {\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const dragCounterRef = useRef<Map<string, number>>(new Map());\n\n  const [isDragging, setIsDragging] = useState<string | null>(null);\n  const [uploadState, setUploadState] = useState<VideoUploadState>({\n    file: null,\n    preview: null,\n    isValidating: false,\n    isValid: false,\n    errors: []\n  });\n\n  const validateVideo = (file: File, type: 'consent' | 'training'): Promise<boolean> => {\n    return new Promise((resolve) => {\n      const errors: ValidationError[] = [];\n\n      if (type === 'training') {\n        const maxSize = 1000 * 1024 * 1024;\n        if (file.size > maxSize) {\n          const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);\n          errors.push({\n            type: 'size',\n            message: `File size exceeds maximum limit of 1000MB (${fileSizeMB}MB)`\n          });\n          setUploadState(prev => ({\n            ...prev,\n            isValidating: false,\n            isValid: false,\n            errors\n          }));\n          resolve(false);\n          return;\n        }\n      }\n\n      if (file.type !== 'video/mp4' && file.type !== 'video/quicktime') {\n        errors.push({\n          type: 'format',\n          message: 'Only MP4 or MOV format is supported'\n        });\n      }\n\n      const video = document.createElement('video');\n      video.preload = 'metadata';\n\n      video.onloadedmetadata = () => {\n        window.URL.revokeObjectURL(video.src);\n\n        if (type === 'consent') {\n          if (video.duration > 20) {\n            errors.push({\n              type: 'duration',\n              message: `Consent video is too long (${Math.round(video.duration)}s). Maximum duration is 20 seconds`\n            });\n          }\n        } else if (type === 'training') {\n          if (video.duration < 30) {\n            errors.push({\n              type: 'duration',\n              message: `Training video is too short (${Math.round(video.duration)}s). Minimum duration is 30 seconds`\n            });\n          }\n          if (video.duration > 240) {\n            errors.push({\n              type: 'duration',\n              message: `Training video is too long (${Math.round(video.duration)}s). Maximum duration is 4 minutes`\n            });\n          }\n        }\n\n        if (video.videoHeight < 720) {\n          errors.push({\n            type: 'quality',\n            message: `Video quality is too low (${video.videoWidth}x${video.videoHeight}). Minimum height is 720px`\n          });\n        }\n\n        setUploadState(prev => ({\n          ...prev,\n          isValidating: false,\n          isValid: errors.length === 0,\n          errors\n        }));\n\n        resolve(errors.length === 0);\n      };\n\n      video.onerror = () => {\n        errors.push({\n          type: 'error',\n          message: 'Failed to load video file'\n        });\n        setUploadState(prev => ({\n          ...prev,\n          isValidating: false,\n          isValid: false,\n          errors\n        }));\n        resolve(false);\n      };\n\n      video.src = URL.createObjectURL(file);\n    });\n  };\n\n  const handleFileSelect = async (file: File, type: 'consent' | 'training') => {\n    setUploadState(prev => ({\n      ...prev,\n      isValidating: true,\n      isValid: false,\n      errors: []\n    }));\n\n    const preview = URL.createObjectURL(file);\n    setUploadState(prev => ({\n      ...prev,\n      file,\n      preview\n    }));\n\n    await validateVideo(file, type);\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>, type: 'consent' | 'training') => {\n    if (e.target.files && e.target.files[0]) {\n      handleFileSelect(e.target.files[0], type);\n    }\n  };\n\n  const handleDragEnter = (e: React.DragEvent, type: string) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const currentCount = dragCounterRef.current.get(type) || 0;\n    const newCount = currentCount + 1;\n    dragCounterRef.current.set(type, newCount);\n    \n    // Only set dragging state when entering the drop zone (counter goes from 0 to 1)\n    if (newCount === 1) {\n      setIsDragging(type);\n    }\n  };\n\n  const handleDragLeave = (e: React.DragEvent, type: string) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const currentCount = dragCounterRef.current.get(type) || 0;\n    const newCount = Math.max(0, currentCount - 1);\n    dragCounterRef.current.set(type, newCount);\n    \n    // Only clear dragging state when truly leaving the drop zone (counter reaches 0)\n    if (newCount === 0) {\n      setIsDragging(null);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  const handleDrop = (e: React.DragEvent, type: 'consent' | 'training') => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Reset counter and clear dragging state\n    dragCounterRef.current.set(type, 0);\n    setIsDragging(null);\n\n    const files = e.dataTransfer.files;\n    if (files && files[0]) {\n      console.log('ðŸ“ File selected from drop:', files[0]);\n      handleFileSelect(files[0], type);\n    } else {\n      console.log('âŒ No files in drop event');\n    }\n  };\n\n  const clearSelection = () => {\n    setUploadState({\n      file: null,\n      preview: null,\n      isValidating: false,\n      isValid: false,\n      errors: []\n    });\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  const getBorderClasses = (type: string) => {\n    if (isDragging === type) {\n      return 'border-[#6366F1] bg-[#6366F1]/5 border-2';\n    }\n    if (uploadState.errors.length > 0 && !uploadState.isValidating) {\n      return 'border-red-500';\n    }\n    if (uploadState.isValid && !uploadState.isValidating) {\n      return 'border-green-500';\n    }\n    return 'border-[#D1D5DB]';\n  };\n\n  return {\n    fileInputRef,\n    videoRef,\n    uploadState,\n    isDragging,\n    handleFileSelect,\n    handleInputChange,\n    handleDragEnter,\n    handleDragLeave,\n    handleDragOver,\n    handleDrop,\n    clearSelection,\n    getBorderClasses\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useSubscription.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { apiService, type SubscriptionData } from '@/lib/api-service'\n\nexport interface SubscriptionUsage {\n  videoCount: number\n  videoLimit: number\n  isLimitReached: boolean\n  remainingVideos: number\n  usagePercentage: number\n}\n\nexport const useSubscription = () => {\n  const [subscription, setSubscription] = useState<SubscriptionData | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const fetchSubscription = useCallback(async (): Promise<SubscriptionData | null> => {\n    try {\n      setLoading(true)\n      setError(null)\n      \n      const response = await apiService.getCurrentSubscription()\n      \n      if (response.success && response.data?.subscription) {\n        const subscriptionData = response.data.subscription\n        setSubscription(subscriptionData)\n        return subscriptionData\n      } else {\n        setError(response.message || 'Failed to fetch subscription details')\n        return null\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to load subscription details'\n      setError(errorMessage)\n      return null\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const getUsageInfo = useCallback((subscriptionData?: SubscriptionData): SubscriptionUsage => {\n    const data = subscriptionData || subscription\n    if (!data) {\n      return {\n        videoCount: 0,\n        videoLimit: 0,\n        isLimitReached: true,\n        remainingVideos: 0,\n        usagePercentage: 100\n      }\n    }\n\n    const videoCount = data.videoCount || 0\n    const videoLimit = data.videoLimit || 0\n    const remainingVideos = Math.max(0, videoLimit - videoCount)\n    const isLimitReached = videoCount >= videoLimit\n    const usagePercentage = videoLimit > 0 ? (videoCount / videoLimit) * 100 : 0\n\n    return {\n      videoCount,\n      videoLimit,\n      isLimitReached,\n      remainingVideos,\n      usagePercentage\n    }\n  }, [subscription])\n\n  const checkVideoUsageLimit = useCallback(async (): Promise<{\n    canCreateVideo: boolean\n    usageInfo: SubscriptionUsage\n    message?: string\n  }> => {\n    const subscriptionData = await fetchSubscription()\n    const usageInfo = getUsageInfo(subscriptionData || undefined)\n\n    if (!subscriptionData) {\n      return {\n        canCreateVideo: false,\n        usageInfo,\n        message: 'No active subscription found. Please subscribe to create content.'\n      }\n    }\n\n    // Check if subscription status is pending\n    if (subscriptionData.status === 'pending') {\n      return {\n        canCreateVideo: false,\n        usageInfo,\n        message: 'Your payment is still being processed. Please wait for payment confirmation before creating videos.'\n      }\n    }\n\n    if (usageInfo.isLimitReached) {\n      return {\n        canCreateVideo: false,\n        usageInfo,\n        message: `You've reached your video limit (${usageInfo.videoCount}/${usageInfo.videoLimit}). Upgrade your subscription to create more videos.`\n      }\n    }\n\n    return {\n      canCreateVideo: true,\n      usageInfo,\n      message: `You have ${usageInfo.remainingVideos} videos remaining this period.`\n    }\n  }, [fetchSubscription, getUsageInfo])\n\n  return {\n    subscription,\n    loading,\n    error,\n    fetchSubscription,\n    getUsageInfo,\n    checkVideoUsageLimit\n  }\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;;AAHA;;;AAaO,MAAM,kBAAkB;;IAC7B,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,6LAAQ,EAA0B;IAC1E,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,6LAAQ,EAAC;IACvC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,6LAAQ,EAAgB;IAElD,MAAM,oBAAoB,IAAA,gMAAW;0DAAC;YACpC,IAAI;gBACF,WAAW;gBACX,SAAS;gBAET,MAAM,WAAW,MAAM,iKAAU,CAAC,sBAAsB;gBAExD,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE,cAAc;oBACnD,MAAM,mBAAmB,SAAS,IAAI,CAAC,YAAY;oBACnD,gBAAgB;oBAChB,OAAO;gBACT,OAAO;oBACL,SAAS,SAAS,OAAO,IAAI;oBAC7B,OAAO;gBACT;YACF,EAAE,OAAO,KAAK;gBACZ,MAAM,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;gBAC1D,SAAS;gBACT,OAAO;YACT,SAAU;gBACR,WAAW;YACb;QACF;yDAAG,EAAE;IAEL,MAAM,eAAe,IAAA,gMAAW;qDAAC,CAAC;YAChC,MAAM,OAAO,oBAAoB;YACjC,IAAI,CAAC,MAAM;gBACT,OAAO;oBACL,YAAY;oBACZ,YAAY;oBACZ,gBAAgB;oBAChB,iBAAiB;oBACjB,iBAAiB;gBACnB;YACF;YAEA,MAAM,aAAa,KAAK,UAAU,IAAI;YACtC,MAAM,aAAa,KAAK,UAAU,IAAI;YACtC,MAAM,kBAAkB,KAAK,GAAG,CAAC,GAAG,aAAa;YACjD,MAAM,iBAAiB,cAAc;YACrC,MAAM,kBAAkB,aAAa,IAAI,AAAC,aAAa,aAAc,MAAM;YAE3E,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;YACF;QACF;oDAAG;QAAC;KAAa;IAEjB,MAAM,uBAAuB,IAAA,gMAAW;6DAAC;YAKvC,MAAM,mBAAmB,MAAM;YAC/B,MAAM,YAAY,aAAa,oBAAoB;YAEnD,IAAI,CAAC,kBAAkB;gBACrB,OAAO;oBACL,gBAAgB;oBAChB;oBACA,SAAS;gBACX;YACF;YAEA,0CAA0C;YAC1C,IAAI,iBAAiB,MAAM,KAAK,WAAW;gBACzC,OAAO;oBACL,gBAAgB;oBAChB;oBACA,SAAS;gBACX;YACF;YAEA,IAAI,UAAU,cAAc,EAAE;gBAC5B,OAAO;oBACL,gBAAgB;oBAChB;oBACA,SAAS,CAAC,iCAAiC,EAAE,UAAU,UAAU,CAAC,CAAC,EAAE,UAAU,UAAU,CAAC,mDAAmD,CAAC;gBAChJ;YACF;YAEA,OAAO;gBACL,gBAAgB;gBAChB;gBACA,SAAS,CAAC,SAAS,EAAE,UAAU,eAAe,CAAC,8BAA8B,CAAC;YAChF;QACF;4DAAG;QAAC;QAAmB;KAAa;IAEpC,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GAxGa"}},
    {"offset": {"line": 2167, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useSchedule.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { apiService } from '@/lib/api-service'\n\ninterface UseScheduleReturn {\n  scheduleData: any\n  scheduleLoading: boolean\n  scheduleError: string | null\n  fetchSchedule: () => Promise<void>\n  deleteSchedule: (scheduleId: string) => Promise<boolean>\n  clearScheduleData: () => void\n}\n\nexport const useSchedule = (): UseScheduleReturn => {\n  const [scheduleData, setScheduleData] = useState<any>(null)\n  const [scheduleLoading, setScheduleLoading] = useState(false)\n  const [scheduleError, setScheduleError] = useState<string | null>(null)\n\n  // Fetch schedule data\n  const fetchSchedule = useCallback(async () => {\n    try {\n      setScheduleLoading(true)\n      setScheduleError(null)\n      \n      const response = await apiService.getSchedule()\n      \n      if (response.success && response.data) {\n        setScheduleData(response.data)\n        console.log('Schedule data fetched successfully:', response.data)\n      } else {\n        setScheduleData(null)\n        // setScheduleError(response.message || 'Failed to fetch schedule data')\n      }\n    } catch (error: any) {\n      console.error('âŒ Error fetching schedule data:', error)\n      setScheduleData(null)\n      // setScheduleError(error.message || 'Failed to fetch schedule data')\n    } finally {\n      setScheduleLoading(false)\n    }\n  }, [])\n\n  // Delete schedule\n  const deleteSchedule = useCallback(async (scheduleId: string): Promise<boolean> => {\n    try {\n      setScheduleLoading(true)\n      setScheduleError(null)\n      const response = await apiService.deleteSchedule(scheduleId)\n      \n      if (response.success) {\n        console.log('Schedule deleted successfully')\n        \n        // Show success notification\n        if ((window as any).showNotification) {\n          (window as any).showNotification({\n            type: 'success',\n            title: 'Schedule Deleted',\n            message: 'Your schedule has been deleted successfully!',\n            duration: 5000\n          })\n        }\n        \n        // Refresh schedule data after successful deletion\n        await fetchSchedule()\n        \n        return true\n      } else {\n        console.error('Failed to delete schedule:', response.message)\n        \n        // Show error notification\n        if ((window as any).showNotification) {\n          (window as any).showNotification({\n            type: 'error',\n            title: 'Delete Failed',\n            message: response.message || 'Failed to delete schedule',\n            duration: 5000\n          })\n        }\n        \n        // setScheduleError(response.message || 'Failed to delete schedule')\n        return false\n      }\n    } catch (error: any) {\n      console.error('Error deleting schedule:', error)\n      \n      // Show error notification\n      if ((window as any).showNotification) {\n        (window as any).showNotification({\n          type: 'error',\n          title: 'Network Error',\n          message: 'Failed to delete schedule. Please try again.',\n          duration: 5000\n        })\n      }\n      \n      // setScheduleError(error.message || 'Failed to delete schedule')\n      return false\n    } finally {\n      setScheduleLoading(false)\n    }\n  }, [fetchSchedule])\n\n  // Clear schedule data\n  const clearScheduleData = useCallback(() => {\n    setScheduleData(null)\n    setScheduleError(null)\n  }, [])\n\n  return {\n    // State\n    scheduleData,\n    scheduleLoading,\n    scheduleError,\n    \n    // Actions\n    fetchSchedule,\n    deleteSchedule,\n    \n    // Utilities\n    clearScheduleData\n  }\n}\n\nexport default useSchedule\n"],"names":[],"mappings":";;;;;;AAEA;AACA;;AAHA;;;AAcO,MAAM,cAAc;;IACzB,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,6LAAQ,EAAM;IACtD,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,6LAAQ,EAAC;IACvD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,6LAAQ,EAAgB;IAElE,sBAAsB;IACtB,MAAM,gBAAgB,IAAA,gMAAW;kDAAC;YAChC,IAAI;gBACF,mBAAmB;gBACnB,iBAAiB;gBAEjB,MAAM,WAAW,MAAM,iKAAU,CAAC,WAAW;gBAE7C,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;oBACrC,gBAAgB,SAAS,IAAI;oBAC7B,QAAQ,GAAG,CAAC,uCAAuC,SAAS,IAAI;gBAClE,OAAO;oBACL,gBAAgB;gBAChB,wEAAwE;gBAC1E;YACF,EAAE,OAAO,OAAY;gBACnB,QAAQ,KAAK,CAAC,mCAAmC;gBACjD,gBAAgB;YAChB,qEAAqE;YACvE,SAAU;gBACR,mBAAmB;YACrB;QACF;iDAAG,EAAE;IAEL,kBAAkB;IAClB,MAAM,iBAAiB,IAAA,gMAAW;mDAAC,OAAO;YACxC,IAAI;gBACF,mBAAmB;gBACnB,iBAAiB;gBACjB,MAAM,WAAW,MAAM,iKAAU,CAAC,cAAc,CAAC;gBAEjD,IAAI,SAAS,OAAO,EAAE;oBACpB,QAAQ,GAAG,CAAC;oBAEZ,4BAA4B;oBAC5B,IAAI,AAAC,OAAe,gBAAgB,EAAE;wBACnC,OAAe,gBAAgB,CAAC;4BAC/B,MAAM;4BACN,OAAO;4BACP,SAAS;4BACT,UAAU;wBACZ;oBACF;oBAEA,kDAAkD;oBAClD,MAAM;oBAEN,OAAO;gBACT,OAAO;oBACL,QAAQ,KAAK,CAAC,8BAA8B,SAAS,OAAO;oBAE5D,0BAA0B;oBAC1B,IAAI,AAAC,OAAe,gBAAgB,EAAE;wBACnC,OAAe,gBAAgB,CAAC;4BAC/B,MAAM;4BACN,OAAO;4BACP,SAAS,SAAS,OAAO,IAAI;4BAC7B,UAAU;wBACZ;oBACF;oBAEA,oEAAoE;oBACpE,OAAO;gBACT;YACF,EAAE,OAAO,OAAY;gBACnB,QAAQ,KAAK,CAAC,4BAA4B;gBAE1C,0BAA0B;gBAC1B,IAAI,AAAC,OAAe,gBAAgB,EAAE;oBACnC,OAAe,gBAAgB,CAAC;wBAC/B,MAAM;wBACN,OAAO;wBACP,SAAS;wBACT,UAAU;oBACZ;gBACF;gBAEA,iEAAiE;gBACjE,OAAO;YACT,SAAU;gBACR,mBAAmB;YACrB;QACF;kDAAG;QAAC;KAAc;IAElB,sBAAsB;IACtB,MAAM,oBAAoB,IAAA,gMAAW;sDAAC;YACpC,gBAAgB;YAChB,iBAAiB;QACnB;qDAAG,EAAE;IAEL,OAAO;QACL,QAAQ;QACR;QACA;QACA;QAEA,UAAU;QACV;QACA;QAEA,YAAY;QACZ;IACF;AACF;GA5Ga;uCA8GE"}},
    {"offset": {"line": 2290, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useAvatarStorage.ts"],"sourcesContent":["'use client'\n\nimport { useCallback } from 'react'\n\nexport interface SelectedAvatar {\n  avatar_id: string\n  avatar_name: string\n  preview_image_url: string\n  avatarType?: 'video_avatar' | 'photo_avatar'\n}\n\nexport interface SelectedAvatars {\n  title: SelectedAvatar\n  body: SelectedAvatar\n  conclusion: SelectedAvatar\n}\n\nexport interface AvatarIds {\n  avatar_title: string\n  avatar_body: string\n  avatar_conclusion: string\n}\n\nexport const useAvatarStorage = () => {\n  const getSelectedAvatars = useCallback((): SelectedAvatars | null => {\n    try {\n      const saved = localStorage.getItem('selectedAvatars')\n      if (!saved) return null\n      \n      const parsed = JSON.parse(saved)\n      \n      // Validate the structure\n      if (!parsed.title || !parsed.body || !parsed.conclusion) {\n        console.warn('Invalid avatar data structure in localStorage')\n        return null\n      }\n      \n      return parsed\n    } catch (error) {\n      console.warn('Failed to parse avatar data from localStorage:', error)\n      return null\n    }\n  }, [])\n\n  const saveSelectedAvatars = useCallback((avatars: SelectedAvatars): void => {\n    try {\n      localStorage.setItem('selectedAvatars', JSON.stringify(avatars))\n    } catch (error) {\n      throw new Error('Failed to save avatar selection to localStorage')\n    }\n  }, [])\n\n  const getAvatarIds = useCallback((): AvatarIds | null => {\n    const avatars = getSelectedAvatars()\n    if (!avatars) return null\n\n    return {\n      avatar_title: avatars.title.avatar_id,\n      avatar_body: avatars.body.avatar_id,\n      avatar_conclusion: avatars.conclusion.avatar_id\n    }\n  }, [getSelectedAvatars])\n\n  const validateAvatarSelection = useCallback((avatarIds: AvatarIds): void => {\n    const required = ['avatar_title', 'avatar_body', 'avatar_conclusion'] as const\n    const missing = required.filter(key => !avatarIds[key] || avatarIds[key].trim() === '')\n    \n    if (missing.length > 0) {\n      throw new Error(`Missing avatar selection: ${missing.join(', ')}`)\n    }\n  }, [])\n\n  const clearSelectedAvatars = useCallback((): void => {\n    try {\n      localStorage.removeItem('selectedAvatars')\n    } catch {\n      console.warn('Failed to clear avatar data from localStorage')\n    }\n  }, [])\n\n  return {\n    getSelectedAvatars,\n    saveSelectedAvatars,\n    getAvatarIds,\n    validateAvatarSelection,\n    clearSelectedAvatars\n  }\n}\n"],"names":[],"mappings":";;;;AAEA;;AAFA;;AAuBO,MAAM,mBAAmB;;IAC9B,MAAM,qBAAqB,IAAA,gMAAW;4DAAC;YACrC,IAAI;gBACF,MAAM,QAAQ,aAAa,OAAO,CAAC;gBACnC,IAAI,CAAC,OAAO,OAAO;gBAEnB,MAAM,SAAS,KAAK,KAAK,CAAC;gBAE1B,yBAAyB;gBACzB,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,UAAU,EAAE;oBACvD,QAAQ,IAAI,CAAC;oBACb,OAAO;gBACT;gBAEA,OAAO;YACT,EAAE,OAAO,OAAO;gBACd,QAAQ,IAAI,CAAC,kDAAkD;gBAC/D,OAAO;YACT;QACF;2DAAG,EAAE;IAEL,MAAM,sBAAsB,IAAA,gMAAW;6DAAC,CAAC;YACvC,IAAI;gBACF,aAAa,OAAO,CAAC,mBAAmB,KAAK,SAAS,CAAC;YACzD,EAAE,OAAO,OAAO;gBACd,MAAM,IAAI,MAAM;YAClB;QACF;4DAAG,EAAE;IAEL,MAAM,eAAe,IAAA,gMAAW;sDAAC;YAC/B,MAAM,UAAU;YAChB,IAAI,CAAC,SAAS,OAAO;YAErB,OAAO;gBACL,cAAc,QAAQ,KAAK,CAAC,SAAS;gBACrC,aAAa,QAAQ,IAAI,CAAC,SAAS;gBACnC,mBAAmB,QAAQ,UAAU,CAAC,SAAS;YACjD;QACF;qDAAG;QAAC;KAAmB;IAEvB,MAAM,0BAA0B,IAAA,gMAAW;iEAAC,CAAC;YAC3C,MAAM,WAAW;gBAAC;gBAAgB;gBAAe;aAAoB;YACrE,MAAM,UAAU,SAAS,MAAM;iFAAC,CAAA,MAAO,CAAC,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,OAAO;;YAEpF,IAAI,QAAQ,MAAM,GAAG,GAAG;gBACtB,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,QAAQ,IAAI,CAAC,OAAO;YACnE;QACF;gEAAG,EAAE;IAEL,MAAM,uBAAuB,IAAA,gMAAW;8DAAC;YACvC,IAAI;gBACF,aAAa,UAAU,CAAC;YAC1B,EAAE,OAAM;gBACN,QAAQ,IAAI,CAAC;YACf;QACF;6DAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF;GAhEa"}},
    {"offset": {"line": 2380, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useUserSettings.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { API_CONFIG, getApiUrl, getAuthenticatedHeaders } from '@/lib/config'\n\ninterface UserSettings {\n  prompt: string\n  avatar: string | string[]\n  titleAvatar?: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' }\n  bodyAvatar?: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' }\n  conclusionAvatar?: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' }\n  name: string\n  position: string\n  language?: string\n  companyName: string\n  license: string\n  tailoredFit: string\n  socialHandles: string\n  city: string\n  preferredTone: string\n  callToAction: string\n  email: string\n  gender?: string\n  preset?: string\n  selectedVoiceId?: string\n  selectedMusicTrackId?: string\n  selectedVoicePreset?: string\n  selectedMusicPreset?: string\n  videoCaption?: string\n}\n\ninterface UserSettingsResponse {\n  success: boolean\n  data: UserSettings\n  message?: string\n}\n\ninterface UseUserSettingsProps {\n  userEmail?: string\n  avatars: { custom: any[], default: any[] }\n  setSelectedAvatars: (avatars: { title: any, body: any, conclusion: any }) => void\n  setValue: (name: any, value: any) => void\n}\n\nexport const useUserSettings = ({ userEmail, avatars, setSelectedAvatars, setValue }: UseUserSettingsProps) => {\n  const [loadingUserSettings, setLoadingUserSettings] = useState(false)\n  const [savingUserSettings, setSavingUserSettings] = useState(false)\n\n  const fetchUserSettings = useCallback(async () => {\n    setLoadingUserSettings(true)\n    try {\n      if (!userEmail) {\n        console.error('User email is required to fetch settings')\n        return { success: false, data: null }\n      }\n\n      const response = await fetch(\n        `${getApiUrl(API_CONFIG.ENDPOINTS.USER_SETTINGS)}?email=${userEmail}`,\n        {\n          method: 'GET',\n          headers: getAuthenticatedHeaders()\n        }\n      )\n\n      if (!response.ok) {\n        // console.error('Failed to fetch user settings:', await response.text())\n        return { success: false, data: null }\n      }\n\n      const userSettings: UserSettingsResponse = await response.json()\n      console.log('Fetched user settings:', userSettings)\n\n      if (userSettings.success && userSettings.data) {\n        const settings = userSettings.data\n        setValue('prompt', settings.prompt || '')\n        // Set avatar field to first avatar ID for form validation\n        if (Array.isArray(settings.avatar) && settings.avatar.length > 0) {\n          setValue('avatar', settings.avatar[0])\n        } else if (typeof settings.avatar === 'string') {\n          setValue('avatar', settings.avatar)\n        } else {\n          setValue('avatar', '')\n        }\n        setValue('name', settings.name || '')\n        setValue('position', settings.position || '')\n        setValue('language', settings.language || '')\n        setValue('companyName', settings.companyName || '')\n        setValue('license', settings.license || '')\n        setValue('tailoredFit', settings.tailoredFit || '')\n        setValue('socialHandles', settings.socialHandles || '')\n        setValue('city', settings.city || '')\n        setValue('preferredTone', settings.preferredTone || '')\n        setValue('callToAction', settings.callToAction || '')\n        setValue('email', settings.email || '')\n        // Convert gender from lowercase (API format) to capitalized (form format)\n        const genderValue = settings.gender || ''\n        const capitalizedGender = genderValue ? genderValue.charAt(0).toUpperCase() + genderValue.slice(1).toLowerCase() : ''\n        setValue('gender', capitalizedGender)\n        setValue('preset', settings.preset || '')\n        setValue('videoCaption', settings.videoCaption || '')\n\n            // Handle avatar loading - prioritize avatar array from API response\n            if (settings.avatar && Array.isArray(settings.avatar)) {\n              // New format: avatar is an array of IDs from API response\n              const avatarIds = settings.avatar.filter(id => id && id.trim() !== '')\n              console.log('ðŸ” Loading avatars from API response array:', avatarIds)\n              \n              if (avatarIds.length > 0) {\n                const foundAvatars = avatarIds.map(id => \n                  [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === id)\n                ).filter(Boolean)\n                \n                if (foundAvatars.length > 0) {\n                  setSelectedAvatars({\n                    title: foundAvatars[0] || null,\n                    body: foundAvatars[1] || null,\n                    conclusion: foundAvatars[2] || null\n                  })\n                  \n                  // Update the form's avatar field to show the first avatar in the dropdown\n                  setValue('avatar', foundAvatars[0].avatar_id)\n                  \n                  console.log('ðŸŽ¯ Avatars loaded from API response array:', {\n                    avatar_ids: avatarIds,\n                    loaded_avatars: foundAvatars.map(avatar => ({\n                      avatar_id: avatar.avatar_id,\n                      avatar_name: avatar.avatar_name || avatar.name,\n                      avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === avatar.avatar_id) ? 'custom' : 'default'\n                    })),\n                    assigned_to_slots: ['title', 'body', 'conclusion'],\n                    form_avatar_field_updated: foundAvatars[0].avatar_id\n                  })\n                }\n              }\n            } else if (settings.titleAvatar || settings.bodyAvatar || settings.conclusionAvatar) {\n              // Fallback: individual avatar IDs (legacy support) or new structure with avatar_id and avatarType\n              const getAvatarId = (avatar: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' } | undefined): string => {\n                if (!avatar) return ''\n                if (typeof avatar === 'string') return avatar\n                return avatar.avatar_id || ''\n              }\n              \n              const titleAvatarId = getAvatarId(settings.titleAvatar)\n              const bodyAvatarId = getAvatarId(settings.bodyAvatar)\n              const conclusionAvatarId = getAvatarId(settings.conclusionAvatar)\n              \n              const titleAvatar = titleAvatarId ? \n                [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === titleAvatarId) : null\n              const bodyAvatar = bodyAvatarId ? \n                [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === bodyAvatarId) : null\n              const conclusionAvatar = conclusionAvatarId ? \n                [...avatars.custom, ...avatars.default].find(avatar => avatar.avatar_id === conclusionAvatarId) : null\n\n              setSelectedAvatars({\n                title: titleAvatar,\n                body: bodyAvatar,\n                conclusion: conclusionAvatar\n              })\n              \n              // Update the form's avatar field to show the first avatar in the dropdown\n              if (titleAvatar) {\n                setValue('avatar', titleAvatar.avatar_id)\n              }\n              \n              console.log('ðŸŽ¯ Individual avatars loaded from user settings (legacy):', {\n                title: titleAvatar ? {\n                  avatar_id: titleAvatar.avatar_id,\n                  avatar_name: titleAvatar.avatar_name || titleAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === titleAvatar.avatar_id) ? 'custom' : 'default'\n                } : null,\n                body: bodyAvatar ? {\n                  avatar_id: bodyAvatar.avatar_id,\n                  avatar_name: bodyAvatar.avatar_name || bodyAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === bodyAvatar.avatar_id) ? 'custom' : 'default'\n                } : null,\n                conclusion: conclusionAvatar ? {\n                  avatar_id: conclusionAvatar.avatar_id,\n                  avatar_name: conclusionAvatar.avatar_name || conclusionAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === conclusionAvatar.avatar_id) ? 'custom' : 'default'\n                } : null,\n                form_avatar_field_updated: titleAvatar?.avatar_id || 'none'\n              })\n            } else if (settings.avatar && typeof settings.avatar === 'string') {\n              // Legacy format: avatar is a single string\n              const foundAvatar = [...avatars.custom, ...avatars.default].find(avatar =>\n                avatar.avatar_id === settings.avatar\n              )\n              if (foundAvatar) {\n                setSelectedAvatars({\n                  title: foundAvatar,\n                  body: foundAvatar,\n                  conclusion: foundAvatar\n                })\n                \n                // Update the form's avatar field to show the avatar in the dropdown\n                setValue('avatar', foundAvatar.avatar_id)\n                \n                console.log('ðŸŽ¯ Single avatar loaded from user settings (legacy):', {\n                  avatar_id: foundAvatar.avatar_id,\n                  avatar_name: foundAvatar.avatar_name || foundAvatar.name,\n                  avatar_type: avatars.custom.some(customAvatar => customAvatar.avatar_id === foundAvatar.avatar_id) ? 'custom' : 'default',\n                  assigned_to_slots: ['title', 'body', 'conclusion'],\n                  form_avatar_field_updated: foundAvatar.avatar_id\n                })\n              } else {\n                console.log('âŒ Avatar not found in available avatars:', {\n                  requested_avatar_id: settings.avatar,\n                  available_custom_avatars: avatars.custom.map(a => a.avatar_id),\n                  available_default_avatars: avatars.default.map(a => a.avatar_id)\n                })\n              }\n            }\n        console.log('Form populated with user settings')\n        // Note: Removed automatic validation trigger to prevent validation errors on empty fields\n        return { success: true, data: userSettings.data }\n      }\n      return { success: false, data: null }\n    } catch (error) {\n      console.error('Error fetching user settings:', error)\n      return { success: false, data: null }\n    } finally {\n      setLoadingUserSettings(false)\n    }\n  }, [userEmail, avatars, setSelectedAvatars, setValue])\n\n  const saveUserSettings = useCallback(async (userSettingsData: UserSettings) => {\n    setSavingUserSettings(true)\n    try {\n      // Create a clean payload with proper array (matching curl request format)\n      // Handle new structure: avatar fields can be objects with avatar_id and avatarType\n      const getAvatarId = (avatar: string | { avatar_id: string; avatarType?: 'video_avatar' | 'photo_avatar' } | undefined): string => {\n        if (!avatar) return ''\n        if (typeof avatar === 'string') return avatar\n        return avatar.avatar_id || ''\n      }\n      const cleanPayload = {\n        prompt: userSettingsData.prompt,\n        avatar: Array.isArray(userSettingsData.avatar) ? userSettingsData.avatar : [],\n        titleAvatar: typeof userSettingsData.titleAvatar === 'object' && userSettingsData.titleAvatar !== null\n          ? userSettingsData.titleAvatar\n          : getAvatarId(userSettingsData.titleAvatar),\n        bodyAvatar: typeof userSettingsData.bodyAvatar === 'object' && userSettingsData.bodyAvatar !== null\n          ? userSettingsData.bodyAvatar\n          : getAvatarId(userSettingsData.bodyAvatar),\n        conclusionAvatar: typeof userSettingsData.conclusionAvatar === 'object' && userSettingsData.conclusionAvatar !== null\n          ? userSettingsData.conclusionAvatar\n          : getAvatarId(userSettingsData.conclusionAvatar),\n        name: userSettingsData.name,\n        position: userSettingsData.position,\n        language: userSettingsData.language || '',\n        companyName: userSettingsData.companyName,\n        license: userSettingsData.license,\n        tailoredFit: userSettingsData.tailoredFit,\n        socialHandles: userSettingsData.socialHandles,\n        city: userSettingsData.city,\n        preferredTone: userSettingsData.preferredTone,\n        callToAction: userSettingsData.callToAction,\n        email: userSettingsData.email,\n        gender: userSettingsData.gender ? userSettingsData.gender.toLowerCase() : '',\n        preset: userSettingsData.preset || '',\n        selectedVoiceId: userSettingsData.selectedVoiceId || '',\n        selectedMusicTrackId: userSettingsData.selectedMusicTrackId || '',\n        selectedVoicePreset: userSettingsData.selectedVoicePreset || '',\n        selectedMusicPreset: userSettingsData.selectedMusicPreset || '',\n        videoCaption: userSettingsData.videoCaption || ''\n      }\n      \n      const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.USER_SETTINGS), {\n        method: 'POST',\n        headers: getAuthenticatedHeaders(),\n        body: JSON.stringify(cleanPayload)\n      })\n\n      if (!response.ok) {\n        console.error('Failed to store user settings:', await response.text())\n        return { success: false, error: 'Failed to store user settings' }\n      }\n\n      const result = await response.json()\n      console.log('User settings stored successfully:', result)\n      return { success: true, data: result }\n    } catch (error) {\n      console.error('Error storing user settings:', error)\n      return { success: false, error: 'Error storing user settings' }\n    } finally {\n      setSavingUserSettings(false)\n    }\n  }, [])\n\n  return {\n    loadingUserSettings,\n    savingUserSettings,\n    fetchUserSettings,\n    saveUserSettings\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2703, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useScheduleValidation.ts"],"sourcesContent":["'use client'\n\nimport { useState, useCallback } from 'react'\nimport { ScheduleData, ValidationError, ValidationResult } from '@/types/post-types'\n\nexport const useScheduleValidation = () => {\n  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([])\n\n  const validateScheduleData = useCallback((scheduleData: ScheduleData): ValidationResult => {\n    const errors: ValidationError[] = []\n\n    // Validate frequency\n    if (!scheduleData.frequency || scheduleData.frequency.trim() === '') {\n      errors.push({\n        field: 'frequency',\n        message: 'Please select a posting frequency'\n      })\n    }\n\n    // Validate posts based on frequency\n    const expectedPostCount = getExpectedPostCount(scheduleData.frequency)\n\n    let validPosts\n    if (scheduleData.frequency === 'Daily') {\n      validPosts = scheduleData.posts.filter(post => post.time && post.time.trim() !== '')\n    } else {\n      validPosts = scheduleData.posts.filter(post => (post.day || post.date) && post.time)\n    }\n\n    if (validPosts.length === 0) {\n      if (scheduleData.frequency === 'Daily') {\n        errors.push({\n          field: 'posts',\n          message: 'Please select at least one time'\n        })\n      } else {\n        errors.push({\n          field: 'posts',\n          message: 'Please select at least one day/date and time'\n        })\n      }\n    } else if (scheduleData.frequency !== 'Custom' && validPosts.length < expectedPostCount) {\n      errors.push({\n        field: 'posts',\n        message: `Please select ${expectedPostCount} ${scheduleData.frequency.toLowerCase()} as specified`\n      })\n    }\n\n    // Enhanced validation for individual posts\n    scheduleData.posts.forEach((post, index) => {\n      const postNumber = index + 1\n      \n      // For Daily frequency, only validate time\n      if (scheduleData.frequency === 'Daily') {\n        if (!post.time || post.time.trim() === '') {\n          errors.push({\n            field: `time_${index}`,\n            message: `Please select a time for Day ${postNumber}`\n          })\n        }\n      } else {\n        // For non-Daily frequencies, validate both day/date and time\n        if ((post.day || post.date) && (!post.time || post.time.trim() === '')) {\n          errors.push({\n            field: `time_${index}`,\n            message: `Please select a time for Day ${postNumber}`\n          })\n        }\n        \n        if (post.time && post.time.trim() !== '' && !post.day && !post.date) {\n          errors.push({\n            field: `day_${index}`,\n            message: `Please select a day or date for Time ${postNumber}`\n          })\n        }\n      }\n      \n      // For non-Daily frequencies, check if day is missing\n      if (scheduleData.frequency !== 'Daily' && scheduleData.frequency !== 'Custom' && (!post.day || post.day.trim() === '')) {\n        errors.push({\n          field: `day_${index}`,\n          message: `Please select a day for Day ${postNumber}`\n        })\n      }\n    })\n\n    // Date validation removed - allow past dates to hit the API\n\n    // Enhanced time validation\n    validPosts.forEach((post, index) => {\n      if (post.time && post.time.trim() !== '') {\n        const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/\n        if (!timeRegex.test(post.time)) {\n          errors.push({\n            field: `time_${index}`,\n            message: `Invalid time format for Time ${index + 1}. Use HH:MM format`\n          })\n        } else {\n          const [hours, minutes] = post.time.split(':').map(Number)\n          if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {\n            errors.push({\n              field: `time_${index}`,\n              message: `Invalid time for Time ${index + 1}. Hours must be 0-23, minutes 0-59`\n            })\n          }\n        }\n      }\n    })\n\n    // Check for duplicate days (for day-based frequencies)\n    if (scheduleData.frequency !== 'Daily' && scheduleData.frequency !== 'Custom') {\n      const selectedDays = scheduleData.posts\n        .filter(post => post.day && post.day.trim() !== '')\n        .map(post => post.day)\n      \n      const duplicateDays = selectedDays.filter((day, index) => \n        selectedDays.indexOf(day) !== index\n      )\n      \n      if (duplicateDays.length > 0) {\n        errors.push({\n          field: 'posts',\n          message: `Duplicate days selected: ${duplicateDays.join(', ')}. Please select different days.`\n        })\n      }\n    }\n\n    setValidationErrors(errors)\n    return {\n      isValid: errors.length === 0,\n      errors\n    }\n  }, [])\n\n  const getExpectedPostCount = (frequency: string): number => {\n    switch (frequency) {\n      case 'Once a Week':\n        return 1\n      case 'Twice a Week':\n        return 2\n      case 'Three Times a Week':\n        return 3\n      case 'Daily':\n        return 1\n      default:\n        return 2\n    }\n  }\n\n  const clearValidationErrors = useCallback(() => {\n    setValidationErrors([])\n  }, [])\n\n  const getFieldError = useCallback((field: string): string | null => {\n    const error = validationErrors.find(err => err.field === field)\n    return error ? error.message : null\n  }, [validationErrors])\n\n  // Validate individual field in real-time\n  const validateField = useCallback((field: string, value: string, postIndex?: number): string | null => {\n    if (!value || value.trim() === '') {\n      if (field === 'frequency') {\n        return 'Please select a posting frequency'\n      } else if (field === 'day' && postIndex !== undefined) {\n        return `Please select a day for Day ${postIndex + 1}`\n      } else if (field === 'time' && postIndex !== undefined) {\n        return `Please select a time for Time ${postIndex + 1}`\n      }\n      return 'This field is required'\n    }\n\n    // Time format validation\n    if (field === 'time' && value.trim() !== '') {\n      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/\n      if (!timeRegex.test(value)) {\n        return 'Invalid time format. Use HH:MM format'\n      }\n    }\n\n    return null\n  }, [])\n\n  // Check if all required fields are filled\n  const isFormComplete = useCallback((scheduleData: ScheduleData): boolean => {\n    if (!scheduleData.frequency || scheduleData.frequency.trim() === '') {\n      return false\n    }\n\n    const expectedPostCount = getExpectedPostCount(scheduleData.frequency)\n    const validPosts = scheduleData.posts.filter(post => {\n      if (scheduleData.frequency === 'Daily') {\n        return post.time && post.time.trim() !== ''\n      } else {\n        return (post.day || post.date) && post.time && post.time.trim() !== ''\n      }\n    })\n\n    return validPosts.length >= expectedPostCount\n  }, [])\n\n  // Get validation summary\n  const getValidationSummary = useCallback((): { totalErrors: number; fieldErrors: string[] } => {\n    const fieldErrors = validationErrors.map(error => error.message)\n    return {\n      totalErrors: validationErrors.length,\n      fieldErrors\n    }\n  }, [validationErrors])\n\n  return {\n    validateScheduleData,\n    clearValidationErrors,\n    getFieldError,\n    validateField,\n    isFormComplete,\n    getValidationSummary,\n    validationErrors,\n    hasErrors: validationErrors.length > 0\n  }\n}\n\n"],"names":[],"mappings":";;;;AAEA;;AAFA;;AAKO,MAAM,wBAAwB;;IACnC,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,6LAAQ,EAAoB,EAAE;IAE9E,MAAM,uBAAuB,IAAA,gMAAW;mEAAC,CAAC;YACxC,MAAM,SAA4B,EAAE;YAEpC,qBAAqB;YACrB,IAAI,CAAC,aAAa,SAAS,IAAI,aAAa,SAAS,CAAC,IAAI,OAAO,IAAI;gBACnE,OAAO,IAAI,CAAC;oBACV,OAAO;oBACP,SAAS;gBACX;YACF;YAEA,oCAAoC;YACpC,MAAM,oBAAoB,qBAAqB,aAAa,SAAS;YAErE,IAAI;YACJ,IAAI,aAAa,SAAS,KAAK,SAAS;gBACtC,aAAa,aAAa,KAAK,CAAC,MAAM;+EAAC,CAAA,OAAQ,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO;;YACnF,OAAO;gBACL,aAAa,aAAa,KAAK,CAAC,MAAM;+EAAC,CAAA,OAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI;;YACrF;YAEA,IAAI,WAAW,MAAM,KAAK,GAAG;gBAC3B,IAAI,aAAa,SAAS,KAAK,SAAS;oBACtC,OAAO,IAAI,CAAC;wBACV,OAAO;wBACP,SAAS;oBACX;gBACF,OAAO;oBACL,OAAO,IAAI,CAAC;wBACV,OAAO;wBACP,SAAS;oBACX;gBACF;YACF,OAAO,IAAI,aAAa,SAAS,KAAK,YAAY,WAAW,MAAM,GAAG,mBAAmB;gBACvF,OAAO,IAAI,CAAC;oBACV,OAAO;oBACP,SAAS,CAAC,cAAc,EAAE,kBAAkB,CAAC,EAAE,aAAa,SAAS,CAAC,WAAW,GAAG,aAAa,CAAC;gBACpG;YACF;YAEA,2CAA2C;YAC3C,aAAa,KAAK,CAAC,OAAO;2EAAC,CAAC,MAAM;oBAChC,MAAM,aAAa,QAAQ;oBAE3B,0CAA0C;oBAC1C,IAAI,aAAa,SAAS,KAAK,SAAS;wBACtC,IAAI,CAAC,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO,IAAI;4BACzC,OAAO,IAAI,CAAC;gCACV,OAAO,CAAC,KAAK,EAAE,OAAO;gCACtB,SAAS,CAAC,6BAA6B,EAAE,YAAY;4BACvD;wBACF;oBACF,OAAO;wBACL,6DAA6D;wBAC7D,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI,KAAK,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO,EAAE,GAAG;4BACtE,OAAO,IAAI,CAAC;gCACV,OAAO,CAAC,KAAK,EAAE,OAAO;gCACtB,SAAS,CAAC,6BAA6B,EAAE,YAAY;4BACvD;wBACF;wBAEA,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE;4BACnE,OAAO,IAAI,CAAC;gCACV,OAAO,CAAC,IAAI,EAAE,OAAO;gCACrB,SAAS,CAAC,qCAAqC,EAAE,YAAY;4BAC/D;wBACF;oBACF;oBAEA,qDAAqD;oBACrD,IAAI,aAAa,SAAS,KAAK,WAAW,aAAa,SAAS,KAAK,YAAY,CAAC,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,OAAO,EAAE,GAAG;wBACtH,OAAO,IAAI,CAAC;4BACV,OAAO,CAAC,IAAI,EAAE,OAAO;4BACrB,SAAS,CAAC,4BAA4B,EAAE,YAAY;wBACtD;oBACF;gBACF;;YAEA,4DAA4D;YAE5D,2BAA2B;YAC3B,WAAW,OAAO;2EAAC,CAAC,MAAM;oBACxB,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO,IAAI;wBACxC,MAAM,YAAY;wBAClB,IAAI,CAAC,UAAU,IAAI,CAAC,KAAK,IAAI,GAAG;4BAC9B,OAAO,IAAI,CAAC;gCACV,OAAO,CAAC,KAAK,EAAE,OAAO;gCACtB,SAAS,CAAC,6BAA6B,EAAE,QAAQ,EAAE,kBAAkB,CAAC;4BACxE;wBACF,OAAO;4BACL,MAAM,CAAC,OAAO,QAAQ,GAAG,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC;4BAClD,IAAI,QAAQ,KAAK,QAAQ,MAAM,UAAU,KAAK,UAAU,IAAI;gCAC1D,OAAO,IAAI,CAAC;oCACV,OAAO,CAAC,KAAK,EAAE,OAAO;oCACtB,SAAS,CAAC,sBAAsB,EAAE,QAAQ,EAAE,kCAAkC,CAAC;gCACjF;4BACF;wBACF;oBACF;gBACF;;YAEA,uDAAuD;YACvD,IAAI,aAAa,SAAS,KAAK,WAAW,aAAa,SAAS,KAAK,UAAU;gBAC7E,MAAM,eAAe,aAAa,KAAK,CACpC,MAAM;4FAAC,CAAA,OAAQ,KAAK,GAAG,IAAI,KAAK,GAAG,CAAC,IAAI,OAAO;2FAC/C,GAAG;4FAAC,CAAA,OAAQ,KAAK,GAAG;;gBAEvB,MAAM,gBAAgB,aAAa,MAAM;6FAAC,CAAC,KAAK,QAC9C,aAAa,OAAO,CAAC,SAAS;;gBAGhC,IAAI,cAAc,MAAM,GAAG,GAAG;oBAC5B,OAAO,IAAI,CAAC;wBACV,OAAO;wBACP,SAAS,CAAC,yBAAyB,EAAE,cAAc,IAAI,CAAC,MAAM,+BAA+B,CAAC;oBAChG;gBACF;YACF;YAEA,oBAAoB;YACpB,OAAO;gBACL,SAAS,OAAO,MAAM,KAAK;gBAC3B;YACF;QACF;kEAAG,EAAE;IAEL,MAAM,uBAAuB,CAAC;QAC5B,OAAQ;YACN,KAAK;gBACH,OAAO;YACT,KAAK;gBACH,OAAO;YACT,KAAK;gBACH,OAAO;YACT,KAAK;gBACH,OAAO;YACT;gBACE,OAAO;QACX;IACF;IAEA,MAAM,wBAAwB,IAAA,gMAAW;oEAAC;YACxC,oBAAoB,EAAE;QACxB;mEAAG,EAAE;IAEL,MAAM,gBAAgB,IAAA,gMAAW;4DAAC,CAAC;YACjC,MAAM,QAAQ,iBAAiB,IAAI;0EAAC,CAAA,MAAO,IAAI,KAAK,KAAK;;YACzD,OAAO,QAAQ,MAAM,OAAO,GAAG;QACjC;2DAAG;QAAC;KAAiB;IAErB,yCAAyC;IACzC,MAAM,gBAAgB,IAAA,gMAAW;4DAAC,CAAC,OAAe,OAAe;YAC/D,IAAI,CAAC,SAAS,MAAM,IAAI,OAAO,IAAI;gBACjC,IAAI,UAAU,aAAa;oBACzB,OAAO;gBACT,OAAO,IAAI,UAAU,SAAS,cAAc,WAAW;oBACrD,OAAO,CAAC,4BAA4B,EAAE,YAAY,GAAG;gBACvD,OAAO,IAAI,UAAU,UAAU,cAAc,WAAW;oBACtD,OAAO,CAAC,8BAA8B,EAAE,YAAY,GAAG;gBACzD;gBACA,OAAO;YACT;YAEA,yBAAyB;YACzB,IAAI,UAAU,UAAU,MAAM,IAAI,OAAO,IAAI;gBAC3C,MAAM,YAAY;gBAClB,IAAI,CAAC,UAAU,IAAI,CAAC,QAAQ;oBAC1B,OAAO;gBACT;YACF;YAEA,OAAO;QACT;2DAAG,EAAE;IAEL,0CAA0C;IAC1C,MAAM,iBAAiB,IAAA,gMAAW;6DAAC,CAAC;YAClC,IAAI,CAAC,aAAa,SAAS,IAAI,aAAa,SAAS,CAAC,IAAI,OAAO,IAAI;gBACnE,OAAO;YACT;YAEA,MAAM,oBAAoB,qBAAqB,aAAa,SAAS;YACrE,MAAM,aAAa,aAAa,KAAK,CAAC,MAAM;gFAAC,CAAA;oBAC3C,IAAI,aAAa,SAAS,KAAK,SAAS;wBACtC,OAAO,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO;oBAC3C,OAAO;wBACL,OAAO,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,OAAO;oBACtE;gBACF;;YAEA,OAAO,WAAW,MAAM,IAAI;QAC9B;4DAAG,EAAE;IAEL,yBAAyB;IACzB,MAAM,uBAAuB,IAAA,gMAAW;mEAAC;YACvC,MAAM,cAAc,iBAAiB,GAAG;uFAAC,CAAA,QAAS,MAAM,OAAO;;YAC/D,OAAO;gBACL,aAAa,iBAAiB,MAAM;gBACpC;YACF;QACF;kEAAG;QAAC;KAAiB;IAErB,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA,WAAW,iBAAiB,MAAM,GAAG;IACvC;AACF;GAtNa"}},
    {"offset": {"line": 2941, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useSocialAccounts.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react'\nimport { useSelector } from 'react-redux'\nimport { RootState } from '@/store'\nimport { API_CONFIG, getApiUrl, getAuthenticatedHeaders } from '@/lib/config'\n\ninterface ConnectedAccount {\n  id: number\n  name: string\n  type: string\n  _type: string\n  active: boolean\n  image: string\n  post_maxlength: number\n  attachment_types: string[]\n  max_attachments: number\n  post_media_required: boolean\n  video_dimensions: {\n    min: [number, number | null]\n    max: [number | null, number | null]\n  }\n  video_duration: {\n    min: number\n    max: number\n  }\n  user_id: number\n  account_id: string\n  public_id: string\n  extra_data: any\n}\n\ninterface SocialBuResponse {\n  success: boolean\n  message: string\n  data: ConnectedAccount[]\n}\n\ninterface SocialPlatform {\n  id: string\n  name: string\n  type: string\n  _type: string\n  icon: string\n}\n\nexport const useSocialAccounts = () => {\n  const [connectedAccounts, setConnectedAccounts] = useState<ConnectedAccount[]>([])\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [disconnecting, setDisconnecting] = useState<number | null>(null)\n  const refetchTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Get access token from Redux store\n  const accessToken = useSelector((state: RootState) => state.user.accessToken)\n  const userId = useSelector((state: RootState) => state.user.user?.id)\n\n  // Available social media platforms\n  const availablePlatforms: SocialPlatform[] = [\n    {\n      id: 'instagram',\n      name: 'Instagram',\n      type: 'instagram.api',\n      _type: 'Instagram Business',\n      icon: 'instagram'\n    },\n    {\n      id: 'twitter',\n      name: 'X (Twitter)',\n      type: 'twitter.profile',\n      _type: 'X (Twitter) Account',\n      icon: 'twitter'\n    },\n    {\n      id: 'youtube',\n      name: 'YouTube',\n      type: 'google.youtube',\n      _type: 'YouTube Channel',\n      icon: 'youtube'\n    },\n    {\n      id: 'tiktok',\n      name: 'TikTok',\n      type: 'tiktok.profile',\n      _type: 'TikTok Account',\n      icon: 'tiktok'\n    },\n    {\n      id: 'facebook',\n      name: 'Facebook',\n      type: 'facebook.page',\n      _type: 'Facebook Page',\n      icon: 'facebook'\n    },\n    {\n      id: 'linkedin',\n      name: 'LinkedIn',\n      type: 'linkedin.profile',\n      _type: 'LinkedIn Profile',\n      icon: 'linkedin'\n    }\n  ]\n\n// Fetch connected accounts\nconst fetchConnectedAccounts = useCallback(async () => {\n  if (!accessToken) {\n    setError('Authentication required')\n    setLoading(false)\n    return\n  }\n\n  try {\n    setLoading(true)\n    setError(null)\n\n    const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.SOCIALBU.ACCOUNTS_PUBLIC), {\n      method: 'GET',\n      headers: getAuthenticatedHeaders()\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to fetch connected accounts')\n    }\n\n    const data: SocialBuResponse = await response.json()\n\n    if (data.success) {\n      setConnectedAccounts(data.data)\n    } else {\n      throw new Error(data.message || 'Failed to fetch accounts')\n    }\n  } catch (err: any) {\n    console.error('Error fetching connected accounts:', err)\n    setError(err.message || 'Failed to fetch connected accounts')\n  } finally {\n    setLoading(false)\n  }\n}, [accessToken])\n\n// Disconnect/Delete an account\nconst disconnectAccount = useCallback(async (accountId: number) => {\n  if (!accessToken) {\n    setError('Authentication required')\n    return\n  }\n\n  try {\n    setDisconnecting(accountId)\n    setError(null)\n\n    const response = await fetch(getApiUrl(`${API_CONFIG.ENDPOINTS.SOCIALBU.ACCOUNT_DELETE}/${accountId}`), {\n      method: 'DELETE',\n      headers: getAuthenticatedHeaders()\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to disconnect account')\n    }\n\n    const data = await response.json()\n\n    if (data.success) {\n      // Refetch connected accounts to get fresh data from server\n      await fetchConnectedAccounts()\n    } else {\n      throw new Error(data.message || 'Failed to disconnect account')\n    }\n  } catch (err: any) {\n    console.error('Error disconnecting account:', err)\n    setError(err.message || 'Failed to disconnect account')\n  } finally {\n    setDisconnecting(null)\n  }\n}, [accessToken, fetchConnectedAccounts])\n\n// Connect a new platform\nconst connectPlatform = useCallback(async (platformId: string) => {\n  if (!accessToken) {\n    setError('Authentication required')\n    return\n  }\n\n  try {\n    setLoading(true)\n    setError(null)\n\n    // Map platform IDs to provider names\n    const providerMap: { [key: string]: string } = {\n      'instagram': 'instagram',\n      'twitter': 'twitter',\n      'youtube': 'youtube',\n      'tiktok': 'tiktok',\n      'facebook': 'facebook',\n        'linkedin': 'linkedin'\n    }\n\n    const provider = providerMap[platformId]\n    if (!provider) {\n      throw new Error('Invalid platform')\n    }\n    const response = await fetch(getApiUrl(API_CONFIG.ENDPOINTS.SOCIALBU.ACCOUNTS_CONNECT), {\n      method: 'POST',\n      headers: getAuthenticatedHeaders(),\n      body: JSON.stringify({\n        provider: provider,\n        user_id: userId, // This should come from user data\n        postback_url: `${API_CONFIG.BACKEND_URL}/api/webhook/socialbu`\n      })\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to initiate connection')\n    }\n\n    const data = await response.json()\n\n    if (data.success && data.data?.connect_url) {\n      // Open the connect URL in a new tab\n      window.open(data.data.connect_url, '_blank')\n    } else {\n      throw new Error(data.message || 'Failed to get connection URL')\n    }\n  } catch (err: any) {\n    console.error('Error connecting platform:', err)\n    setError(err.message || 'Failed to connect platform')\n  } finally {\n    setLoading(false)\n  }\n}, [accessToken])\n\n// Check if a platform is connected\nconst isPlatformConnected = useCallback((platformType: string) => {\n  return connectedAccounts.some(account => account.type === platformType)\n}, [connectedAccounts])\n\n// Get connected account for a platform\nconst getConnectedAccount = useCallback((platformType: string) => {\n  return connectedAccounts.find(account => account.type === platformType)\n}, [connectedAccounts])\n\n// Auto-fetch when access token is available\nuseEffect(() => {\n  if (accessToken) {\n    fetchConnectedAccounts()\n  }\n}, [accessToken, fetchConnectedAccounts])\n\n// Auto-refetch when user returns to the website (handles webhook callbacks)\nuseEffect(() => {\n  const debouncedRefetch = () => {\n    if (refetchTimeoutRef.current) {\n      clearTimeout(refetchTimeoutRef.current)\n    }\n\n    refetchTimeoutRef.current = setTimeout(() => {\n      if (accessToken) {\n        fetchConnectedAccounts()\n      }\n    }, 500)\n  }\n\n  const handleVisibilityChange = () => {\n    if (!document.hidden && accessToken) {\n      debouncedRefetch()\n    }\n  }\n\n  const handleFocus = () => {\n    if (accessToken) {\n      debouncedRefetch()\n    }\n  }\n\n  // Listen for visibility changes (tab switching)\n  document.addEventListener('visibilitychange', handleVisibilityChange)\n\n  // Listen for window focus (returning from another app)\n  window.addEventListener('focus', handleFocus)\n\n  return () => {\n    if (refetchTimeoutRef.current) {\n      clearTimeout(refetchTimeoutRef.current)\n    }\n    document.removeEventListener('visibilitychange', handleVisibilityChange)\n    window.removeEventListener('focus', handleFocus)\n  }\n}, [accessToken, fetchConnectedAccounts])\n\nreturn {\n  connectedAccounts,\n  availablePlatforms,\n  loading,\n  error,\n  disconnecting,\n  fetchConnectedAccounts,\n  disconnectAccount,\n  connectPlatform,\n  isPlatformConnected,\n  getConnectedAccount\n}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3238, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/task2/src/hooks/useVoicesAndMusic.ts"],"sourcesContent":["'use client'\n\nimport { useState, useEffect, useCallback } from 'react'\nimport { apiService } from '@/lib/api-service'\nimport { Avatar } from '@/lib/api-service'\nimport { Voice } from '@/components/ui/voice-selector/types'\n\ninterface UseVoicesAndMusicProps {\n  preset: string | null | undefined\n  selectedAvatars: {\n    title: Avatar | null\n    body: Avatar | null\n    conclusion: Avatar | null\n  }\n  gender?: string | null // Gender from form dropdown\n}\n\ninterface UseVoicesAndMusicReturn {\n  voices: Voice[]  // Filtered voices based on preset/type\n  voicesLoading: boolean\n  voicesError: string | null\n  musicList: Voice[]  // Filtered music based on preset/type\n  musicLoading: boolean\n  musicError: string | null\n  allVoices: Voice[]  // All voices (low, medium, high)\n  allMusic: Voice[]  // All music (low, medium, high)\n}\n\nexport function useVoicesAndMusic({ preset, selectedAvatars, gender }: UseVoicesAndMusicProps): UseVoicesAndMusicReturn {\n  // Store ALL voices and music (low, medium, high combined)\n  const [allVoices, setAllVoices] = useState<Voice[]>([])\n  const [allMusic, setAllMusic] = useState<Voice[]>([])\n  \n  // Filtered voices and music based on preset/type\n  const [voices, setVoices] = useState<Voice[]>([])\n  const [musicList, setMusicList] = useState<Voice[]>([])\n  \n  const [voicesLoading, setVoicesLoading] = useState(false)\n  const [voicesError, setVoicesError] = useState<string | null>(null)\n  const [musicLoading, setMusicLoading] = useState(false)\n  const [musicError, setMusicError] = useState<string | null>(null)\n\n  // Helper function to get gender - only from form dropdown, NOT from avatar\n  const getGender = useCallback((): string | null => {\n    // Only use gender from form dropdown, ignore avatar gender\n    if (gender && gender.trim()) {\n      return gender.toLowerCase().trim()\n    }\n    // Return null if no gender is selected from dropdown\n    return null\n  }, [gender])\n\n  // Fetch ALL voices (low, medium, high) when avatars are selected - NO energyCategory parameter\n  const fetchAllVoices = useCallback(async (gender: string | null) => {\n    try {\n      setVoicesLoading(true)\n      setVoicesError(null)\n\n      // Fetch ALL voices without energyCategory parameter (only gender)\n      const response = await apiService.getVoices(undefined, gender)\n      \n      if (response.success && response.data) {\n        // Transform API response to Voice[] format\n        const apiVoices = Array.isArray(response.data) ? response.data : (response.data.voices || [])\n        \n        // Map API response to Voice interface\n        // API returns 'energy' field (not energyCategory), use it to determine type\n        // Check if voice is custom (has isCustom property or userId)\n        const transformedVoices: Voice[] = apiVoices.map((voice: any) => {\n          const isCustom = voice.isCustom === true || (voice.userId && voice.userId.trim() !== '')\n          \n          return {\n            id: voice.voice_id || voice.id || voice._id || '',\n            _id: voice._id || voice.id || undefined,\n            voice_id: voice.voice_id || voice.id || undefined,\n            name: voice.name || '',\n            artist: voice.artist || undefined,\n            type: isCustom ? 'custom' as const : ((voice.energy?.toLowerCase() || 'low') as 'low' | 'medium' | 'high'),\n            previewUrl: voice.preview_url || voice.previewUrl || voice.preview || undefined,\n            preview_url: voice.preview_url || voice.previewUrl || voice.preview || undefined,\n            thumbnailUrl: voice.thumbnail_url || voice.thumbnailUrl || voice.thumbnail || undefined,\n            isCustom: isCustom,\n            gender: voice.gender || undefined,\n            energy: voice.energy || undefined,\n            description: voice.description || undefined,\n            userId: voice.userId || voice.user_id || undefined\n          }\n        })\n        \n        setAllVoices(transformedVoices)\n        setVoicesError(null)\n      } else {\n        setVoicesError(response.message || 'Failed to load voices')\n        setAllVoices([])\n      }\n    } catch (error: any) {\n      setVoicesError(error.message || 'Failed to load voices')\n      setAllVoices([])\n    } finally {\n      setVoicesLoading(false)\n    }\n  }, [])\n\n  // Fetch ALL music (low, medium, high) when avatars are selected - NO energyCategory parameter\n  const fetchAllMusic = useCallback(async (gender: string | null) => {\n    try {\n      setMusicLoading(true)\n      setMusicError(null)\n\n      // Fetch ALL music with gender parameter if provided\n      const response = await apiService.getMusicTracks(undefined, gender)\n      \n      if (response.success && response.data) {\n        // Transform API response to Voice[] format\n        const musicData = Array.isArray(response.data) ? response.data : (response.data.tracks || response.data.music || [])\n        \n        // Transform music data according to the API response structure\n        // API should return energyCategory in the response, use it to determine type\n        const transformedMusic: Voice[] = musicData.map((music: any) => {\n          // Map s3PreviewUrl to preview_url and previewUrl for compatibility\n          const previewUrl = music.s3PreviewUrl || music.s3_preview_url || music.preview_url || music.previewUrl || music.preview || undefined\n          \n          return {\n            id: music.trackId || music.track_id || music.id || music._id || '',\n            _id: music._id || '', // Store the MongoDB _id for saving\n            name: music.name || '',\n            artist: music.metadata?.artist || music.artist || undefined,\n            type: (music.energyCategory?.toLowerCase() || 'low') as 'low' | 'medium' | 'high',\n            previewUrl: previewUrl,\n            preview_url: previewUrl, // Use s3PreviewUrl as preview_url\n            thumbnailUrl: music.thumbnail_url || music.thumbnailUrl || music.thumbnail || undefined,\n            s3FullTrackUrl: music.s3FullTrackUrl || music.s3_full_track_url || music.fullTrackUrl || undefined\n          }\n        })\n        \n        setAllMusic(transformedMusic)\n        setMusicError(null)\n      } else {\n        setMusicError(response.message || 'Failed to load music')\n        setAllMusic([])\n      }\n    } catch (error: any) {\n      setMusicError(error.message || 'Failed to load music')\n      setAllMusic([])\n    } finally {\n      setMusicLoading(false)\n    }\n  }, [])\n\n  // Effect to fetch voices and music ONLY when gender is selected from dropdown\n  // APIs are NOT called when avatar is selected - only when gender is explicitly selected\n  useEffect(() => {\n    // Check if gender is explicitly selected from dropdown\n    const hasGender = gender && String(gender).trim().length > 0\n    \n    console.log('ðŸŽµ useVoicesAndMusic - Gender effect triggered:', {\n      gender,\n      hasGender\n    })\n    \n    // Only call APIs if gender is explicitly selected from dropdown\n    // Avatar selection does NOT trigger API calls - removed avatar dependencies\n    if (hasGender) {\n      // Normalize gender to lowercase\n      const currentGender = String(gender).trim().toLowerCase()\n      console.log('ðŸŽµ Calling APIs with gender:', currentGender)\n      // Call APIs with gender parameter (only when gender is selected)\n      fetchAllVoices(currentGender)\n      fetchAllMusic(currentGender)\n    } else {\n      // Clear data only if no gender (but keep data if avatar is selected without gender)\n      const hasAvatar = selectedAvatars.body || selectedAvatars.title || selectedAvatars.conclusion\n      if (!hasAvatar) {\n        console.log('ðŸŽµ Clearing data - no gender and no avatar')\n        setAllVoices([])\n        setAllMusic([])\n        setVoices([])\n        setMusicList([])\n        setVoicesError(null)\n        setMusicError(null)\n      } else {\n        console.log('ðŸŽµ No gender selected but avatar exists - keeping existing data')\n      }\n    }\n    // If avatar is selected but no gender - do nothing (don't call APIs)\n    // Note: selectedAvatars is used inside but not in deps - this is intentional\n    // We only want to react to gender changes, not avatar changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [gender, fetchAllVoices, fetchAllMusic])\n\n  // Effect to filter voices and music based on preset\n  useEffect(() => {\n    if (!preset || !preset.trim()) {\n      // If no preset, show all voices and music\n      setVoices(allVoices)\n      setMusicList(allMusic)\n      return\n    }\n\n    const energyCategory = preset.toLowerCase()\n    \n    // Filter voices and music based on preset\n    const filteredVoices = allVoices.filter(v => v.type === energyCategory)\n    const filteredMusic = allMusic.filter(m => m.type === energyCategory)\n    \n    setVoices(filteredVoices)\n    setMusicList(filteredMusic)\n  }, [preset, allVoices, allMusic])\n\n  return {\n    voices,  // Filtered based on preset\n    voicesLoading,\n    voicesError,\n    musicList,  // Filtered based on preset\n    musicLoading,\n    musicError,\n    allVoices,  // All voices (low, medium, high)\n    allMusic  // All music (low, medium, high)\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}