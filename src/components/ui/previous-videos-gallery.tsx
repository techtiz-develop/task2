'use client'

import { useState, useMemo, useEffect, useCallback, useRef } from 'react'
import CreateVideoModal from './create-video-modal'
import ConnectAccountsModal from './connect-accounts-modal'
import CreatePostModal from './create-post-modal'
import DeleteVideoConfirmationModal from './delete-video-confirmation-modal'
import { IoMdArrowDropdown } from "react-icons/io";
import { X, NotebookPen, AlertCircle, PencilLine } from 'lucide-react'
import { useSelector } from 'react-redux';
import { RootState } from '@/store';
import { apiService } from '@/lib/api-service';
import { useUnifiedSocketContext } from '@/components/providers/UnifiedSocketProvider';
import { useNotificationStore } from './global-notification';

type SortOrder = 'newest' | 'oldest'

type VideoCard = {
  id: string
  videoId: string
  title: string
  status: 'processing' | 'ready' | 'completed' | 'success' | 'failed'
  createdAt: string
  updatedAt: string
  videoUrl?: string
  downloadUrl?: string | null
  autoGenerated?: boolean
  metadata?: {
    duration?: number
    size?: number
    format?: string
  }
  error?: string
  socialMediaCaptions?: {
    instagram_caption?: string
    facebook_caption?: string
    linkedin_caption?: string
    twitter_caption?: string
    tiktok_caption?: string
    youtube_caption?: string
  }
}

interface PreviousVideosGalleryProps {
  className?: string
}

export default function PreviousVideosGallery({ className }: PreviousVideosGalleryProps) {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false)
  const [isConnectAccountsModalOpen, setIsConnectAccountsModalOpen] = useState(false)
  const [isCreatePostModalOpen, setIsCreatePostModalOpen] = useState(false)
  const [selectedAccountsForPost, setSelectedAccountsForPost] = useState<any[]>([])
  const [selectedVideoForCreation, setSelectedVideoForCreation] = useState<string>('')
  const [isDeleteVideoModalOpen, setIsDeleteVideoModalOpen] = useState(false)
  const [videoToDelete, setVideoToDelete] = useState<VideoCard | null>(null)
  const [isDeleting, setIsDeleting] = useState(false)
  const [selectedVideoData, setSelectedVideoData] = useState<{
    title: string; youtubeUrl: string; thumbnail: string, videoUrl: string, socialMediaCaptions: {
      instagram_caption?: string
      facebook_caption?: string
      linkedin_caption?: string
      twitter_caption?: string
      tiktok_caption?: string
      youtube_caption?: string
    }
  } | null>(null)
  const [searchQuery, setSearchQuery] = useState('')
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('')
  const [sortOrder, setSortOrder] = useState<SortOrder>('newest')
  const [isSortDropdownOpen, setIsSortDropdownOpen] = useState(false)
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1)
  const [limit] = useState(10) // Fixed limit, can be made configurable later
  const [totalPages, setTotalPages] = useState(1)
  const [totalCount, setTotalCount] = useState(0)
  // State for API data
  const [videos, setVideos] = useState<VideoCard[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [loadingVideos, setLoadingVideos] = useState<Set<string>>(new Set())
  // Note feature state
  const [videoNotes, setVideoNotes] = useState<Record<string, string>>({})
  const [isNoteModalOpen, setIsNoteModalOpen] = useState(false)
  const [selectedVideoForNote, setSelectedVideoForNote] = useState<VideoCard | null>(null)
  const [currentNoteText, setCurrentNoteText] = useState('')
  const [noteError, setNoteError] = useState<string>('')

  // Notification hook
  const { showNotification } = useNotificationStore()

  // Get access token and user from Redux store
  const accessToken = useSelector((state: RootState) => state.user.accessToken)
  const currentUser = useSelector((state: RootState) => state.user.user)

  // Get unified socket context
  const {
    latestVideoUpdate,
    pendingVideos
  } = useUnifiedSocketContext()

  // Store fetchVideos in ref to avoid dependency issues
  const fetchVideosRef = useRef<(() => Promise<void>) | null>(null)

  // Fetch videos from API with pagination, search, and sort
  const fetchVideos = useCallback(async () => {
    if (!accessToken) {
      setError('Authentication required')
      setLoading(false)
      return
    }

    try {
      setLoading(true)
      setError(null)

      const result = await apiService.getVideoGallery({
        page: currentPage,
        limit: limit,
        sort: sortOrder,
        search: debouncedSearchQuery || undefined
      })

      if (result.success && result.data) {
        // Type assertion for API response structure
        const apiData = result.data as {
          videos: any[];
          pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
          };
          stats?: {
            totalCount: number;
            readyCount: number;
            processingCount: number;
            failedCount: number;
          };
          // Legacy fields for backward compatibility
          totalCount?: number;
          totalPages?: number;
        };
        
        // Map API response to VideoCard format, preserving original videoUrl
        const mappedVideos = apiData.videos
          .map((video: any) => {
            return {
              ...video,
              // Keep the original videoUrl from API, don't override with downloadUrl
              videoUrl: video.videoUrl || video.downloadUrl || ''
            }
          })
        setVideos(mappedVideos)
        
        if (apiData.stats?.totalCount !== undefined) {
          setTotalCount(apiData.stats.totalCount)
        }
        if (apiData.pagination?.totalPages !== undefined) {
          setTotalPages(apiData.pagination.totalPages)
        } else if (apiData.pagination?.total !== undefined) {
          setTotalPages(Math.ceil(apiData.pagination.total / limit))
        } else if (apiData.stats?.totalCount !== undefined) {
          setTotalPages(Math.ceil(apiData.stats.totalCount / limit))
        }
        
        const notesFromAPI: Record<string, string> = {}
        apiData.videos.forEach((video: any) => {
          const videoId = video.videoId || video.id
          if (videoId && video.note) {
            notesFromAPI[videoId] = video.note
          }
        })
        setVideoNotes(notesFromAPI)
      } else {
        throw new Error(result.message || 'Failed to fetch videos')
      }
    } catch (err: any) {
      const errorMessage = err.message || 'Failed to fetch videos'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }, [accessToken, currentPage, limit, sortOrder, debouncedSearchQuery])

  // Debounce search query to avoid excessive API calls
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchQuery(searchQuery)
      // Reset to page 1 when search changes
      setCurrentPage(1)
    }, 500) // 500ms debounce delay

    return () => clearTimeout(timer)
  }, [searchQuery])

  // Reset to page 1 when sort order changes
  useEffect(() => {
    setCurrentPage(1)
  }, [sortOrder])

  // Update ref when fetchVideos changes
  useEffect(() => {
    fetchVideosRef.current = fetchVideos
  }, [fetchVideos])

  // Fetch videos on component mount and when dependencies change
  useEffect(() => {
    fetchVideosRef.current?.()
  }, [accessToken, currentPage, sortOrder, debouncedSearchQuery]) // Trigger on pagination, sort, and search changes

  // No need for cleanup effects since we're using derived state from socket updates

  // Handle video completion - refresh gallery when video is done
  useEffect(() => {
    if (!currentUser || !latestVideoUpdate) return

    const { status } = latestVideoUpdate
    console.log('ðŸŽ¬ Gallery received video update:', { status, message: latestVideoUpdate.message })

    if (status === 'completed' || status === 'success') {
      console.log('ðŸŽ¬ Video completed successfully, refreshing gallery...')
      // Use a ref to avoid dependency on fetchVideos
      const timeoutId = setTimeout(() => {
        fetchVideosRef.current?.()
      }, 1000)

      return () => clearTimeout(timeoutId)
    }
  }, [latestVideoUpdate, currentUser])

  const handleViewVideo = (video: VideoCard) => {
    console.log('firstvideo', video)
    console.log('handleViewVideo', video)
    if (video.status !== 'ready') {
      return
    }

    if (!video.downloadUrl) {
      return
    }

    setSelectedVideoForCreation(video.title)
    setSelectedVideoData({
      title: video.title,
      videoUrl: video.videoUrl || '',
      youtubeUrl: video.downloadUrl, // Use the S3 download URL for viewing
      thumbnail: '' ,// No thumbnail needed
      socialMediaCaptions:
        typeof video.socialMediaCaptions === 'string'
          ? JSON.parse(video.socialMediaCaptions)
          : video.socialMediaCaptions || {}
    })
    setIsCreateModalOpen(true)
  }

  const handlePostVideo = (video: VideoCard) => {
    console.log('handlePostVideo', video)
    if (video.status !== 'ready') {
      return
    }

    setSelectedVideoForCreation(video.title)
    setSelectedVideoData({
      title: video.title,
      videoUrl: video.videoUrl || '',
      youtubeUrl: video.downloadUrl || '',
      thumbnail: '',
      socialMediaCaptions:
        typeof video.socialMediaCaptions === 'string'
          ? JSON.parse(video.socialMediaCaptions)
          : video.socialMediaCaptions || {}
    })
    setIsConnectAccountsModalOpen(true)
  }

  const handleCreatePost = (accounts: any[]) => {
    setSelectedAccountsForPost(accounts)
    setIsConnectAccountsModalOpen(false)
    setIsCreatePostModalOpen(true)
  }

  const handlePostSubmit = (postData: {
    date: string
    time: string
    caption: string
    accounts: any[]
    video: any
  }) => {
    console.log('Post submitted:', postData)
    // Here you would typically call an API to create the post
    setIsCreatePostModalOpen(false)
    setSelectedAccountsForPost([])
  }

  const handleDeleteVideo = (video: VideoCard) => {
    setVideoToDelete(video)
    setIsDeleteVideoModalOpen(true)
  }

  const handleConfirmDelete = async () => {
    if (!videoToDelete) return

    const videoId = videoToDelete.videoId || videoToDelete.id
    if (!videoId) {
      showNotification('Video ID not found', 'error')
      return
    }

    try {
      setIsDeleting(true)
      const result = await apiService.deleteVideo(videoId)

      if (result.success) {
        setVideos(prev => prev.filter(video => 
          (video.videoId || video.id) !== videoId
        ))
        showNotification('Video deleted successfully', 'success')
        setIsDeleteVideoModalOpen(false)
        setVideoToDelete(null)
      } else {
        throw new Error(result.message || 'Failed to delete video')
      }
    } catch (err: any) {
      console.error('Failed to delete video:', err)
      showNotification(err.message || 'Failed to delete video', 'error')
    } finally {
      setIsDeleting(false)
    }
  }

  const handleCancelDelete = () => {
    setIsDeleteVideoModalOpen(false)
    setVideoToDelete(null)
  }

  const validateNote = (note: string): string => {
    const trimmedNote = note.trim()
    if (trimmedNote.length === 0) {
      return 'Note is required'
    }
    const words = trimmedNote.split(/\s+/).filter(word => word.length > 0)
    if (words.length === 0) {
      return 'Note must contain at least one word'
    }
    return ''
  }

  // Note feature handlers
  const handleOpenNoteModal = (video: VideoCard) => {
    const videoId = video.videoId || video.id
    setSelectedVideoForNote(video)
    setCurrentNoteText(videoNotes[videoId] || '')
    setNoteError('')
    setIsNoteModalOpen(true)
  }

  const handleSaveNote = async () => {
    if (!selectedVideoForNote) return
    
    const videoId = selectedVideoForNote.videoId || selectedVideoForNote.id
    if (!videoId) {
      showNotification('Video ID not found', 'error')
      return
    }

    // Validate note before saving
    const validationError = validateNote(currentNoteText)
    if (validationError) {
      setNoteError(validationError)
      return
    }

    try {
      const noteText = currentNoteText.trim()
      const result = await apiService.updateVideoNote(videoId, noteText)
      
      if (result.success) {
        setVideoNotes(prev => ({
          ...prev,
          [videoId]: noteText
        }))
        showNotification('Note saved successfully', 'success')
        // Close modal
        setIsNoteModalOpen(false)
        setSelectedVideoForNote(null)
        setCurrentNoteText('')
        setNoteError('')
      } else {
        showNotification(result.message || 'Failed to save note', 'error')
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to save note'
      showNotification(errorMessage, 'error')
    }
  }

  const handleCancelNote = () => {
    setIsNoteModalOpen(false)
    setSelectedVideoForNote(null)
    setCurrentNoteText('')
    setNoteError('')
  }

  const handleNoteTextChange = (value: string) => {
    setCurrentNoteText(value)
    // Validate and update error state
    const error = validateNote(value)
    setNoteError(error)
  }

  // Merge pending videos (from socket) with API videos
  // Server-side filtering and sorting is already handled by the API
  const displayVideos = useMemo(() => {
    console.log('ðŸ”„ Recalculating displayVideos:', {
      pendingVideosCount: pendingVideos.length,
      apiVideosCount: videos.length
    })

    // Start with API videos (already filtered, sorted, and paginated by server)
    const allVideos = [...videos]

    // Add loading cards for each pending video (processing videos from socket)
    if (pendingVideos.length > 0) {
      console.log(`âž• Adding ${pendingVideos.length} loading card(s) to video list`)
      
      // Create loading cards for each pending video
      const loadingCards: VideoCard[] = pendingVideos.map((video) => ({
        id: video.id,
        videoId: video.id,
        title: video.title,
        status: 'processing',
        createdAt: video.timestamp,
        updatedAt: video.timestamp,
        downloadUrl: null,
        metadata: {
          duration: 0,
          size: 0,
          format: 'processing'
        }
      }))

      // Separate processing videos from completed videos
      const processingVideos = allVideos.filter(video => video.status === 'processing')
      const completedVideos = allVideos.filter(video => video.status !== 'processing')

      // Sort processing videos by creation date (newest first) for consistent display
      const sortedProcessingVideos = processingVideos.sort((a, b) => {
        const dateA = new Date(a.createdAt).getTime()
        const dateB = new Date(b.createdAt).getTime()
        return dateB - dateA
      })

      // Always show pending videos first, then processing videos from API, then completed videos
      return [...loadingCards, ...sortedProcessingVideos, ...completedVideos]
    }

    // If no pending videos, return API videos as-is (already sorted by server)
    return allVideos
  }, [videos, pendingVideos])

  const handleSortChange = (newSortOrder: SortOrder) => {
    setSortOrder(newSortOrder)
    setIsSortDropdownOpen(false)
  }

  if (error) {
    return (
      <div className={`w-full ${className}`}>
        <div className="flex items-center justify-center py-12">
          <div className="text-center">
            <p className="text-red-500 text-lg mb-4">{error}</p>
            <button
              onClick={fetchVideos}
              className="bg-[#5046E5] text-white px-6 py-2 rounded-full hover:bg-[#4338CA] transition-colors"
            >
              Try Again
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className={`w-full ${className}`}>
      {/* Shimmer animation styles - added once for all videos */}
      {loadingVideos.size > 0 && (
        <style dangerouslySetInnerHTML={{
          __html: `
            @keyframes shimmer {
              0% {
                transform: translateX(-100%);
              }
              100% {
                transform: translateX(100%);
              }
            }
          `
        }} />
      )}

      {/* Search, Sort Controls and Create Button */}
      <div className="flex flex-col md:flex-row md:justify-between justify-end gap-4 mb-8">
        {/* Left side: Search Bar */}
        <div className="relative flex-1 md:max-w-[447px] max-w-full">
          <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M9.5 16C7.68333 16 6.146 15.3707 4.888 14.112C3.63 12.8533 3.00067 11.316 3 9.5C2.99933 7.684 3.62867 6.14667 4.888 4.888C6.14733 3.62933 7.68467 3 9.5 3C11.3153 3 12.853 3.62933 14.113 4.888C15.373 6.14667 16.002 7.684 16 9.5C16 10.2333 15.8833 10.925 15.65 11.575C15.4167 12.225 15.1 12.8 14.7 13.3L20.3 18.9C20.4833 19.0833 20.575 19.3167 20.575 19.6C20.575 19.8833 20.4833 20.1167 20.3 20.3C20.1167 20.4833 19.8833 20.575 19.6 20.575C19.3167 20.575 19.0833 20.4833 18.9 20.3L13.3 14.7C12.8 15.1 12.225 15.4167 11.575 15.65C10.925 15.8833 10.2333 16 9.5 16ZM9.5 14C10.75 14 11.8127 13.5627 12.688 12.688C13.5633 11.8133 14.0007 10.7507 14 9.5C13.9993 8.24933 13.562 7.187 12.688 6.313C11.814 5.439 10.7513 5.00133 9.5 5C8.24867 4.99867 7.18633 5.43633 6.313 6.313C5.43967 7.18967 5.002 8.252 5 9.5C4.998 10.748 5.43567 11.8107 6.313 12.688C7.19033 13.5653 8.25267 14.0027 9.5 14Z" fill="#5F5F5F" />
            </svg>
          </div>
          <input
            type="text"
            placeholder="Search"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            style={{
              boxShadow: "0px -1.5px 0px 0px #FFFFFF52 inset, 0px 0.5px 0px 0px #FFFFFF52 inset"
            }}
            className="w-full pr-10 pl-4 py-[7.4px] bg-transparent hover:bg-[#F5F5F5] rounded-[39px] text-[#5F5F5F] placeholder-[#5F5F5F] transition-all duration-300 focus:outline-none focus:ring focus:ring-[#5046E5] focus:bg-white border-2 border-[#5F5F5F] text-[20px] font-semibold"
          />
        </div>

        {/* Right side: Sort Dropdown, Refresh Button and Create Button */}
        <div className="flex gap-4 justify-end">
          {/* Refresh Button */}
          <button
            onClick={fetchVideos}
            disabled={loading}
            className="px-4 py-[7.4px] bg-[#5046E5] text-white rounded-[39px] transition-all duration-300 focus:outline-none focus:ring focus:ring-[#5046E5] flex items-center gap-2 min-w-[120px] justify-center text-[20px] font-semibold hover:bg-[#4338CA] disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 4V10H4.58152M19.9381 11C19.446 7.05369 16.0796 4 12 4C8.64262 4 5.76829 6.06817 4.58152 9M4.58152 9H10M20 20V14H19.4185M19.4185 14C18.2317 16.9318 15.3574 19 12 19C7.92038 19 4.55399 15.9463 4.06189 12M19.4185 14H14" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
            </svg>
            Refresh
          </button>

          {/* Sort Dropdown */}
          <div className="relative">
            <button
              type="button"
              onClick={() => setIsSortDropdownOpen(!isSortDropdownOpen)}
              className="px-4 py-[7.4px] bg-transparent cursor-pointer border-2 border-[#5F5F5F] rounded-[39px] text-[#5F5F5F] transition-all duration-300 focus:outline-none focus:ring focus:ring-[#5046E5] focus:bg-white flex items-center gap-2 min-w-[154px] justify-center text-[20px] font-semibold"
              style={{
                boxShadow: "0px -1.5px 0px 0px #FFFFFF52 inset, 0px 0.5px 0px 0px #FFFFFF52 inset"
              }}
            >
              <span>
                {sortOrder === 'newest' ? 'Newest' : 'Oldest'}
              </span>
              <IoMdArrowDropdown
                className={`w-7 h-7 transition-transform text-[#5F5F5F] duration-300 ${isSortDropdownOpen ? 'rotate-180' : ''}`}
              />
            </button>

            {isSortDropdownOpen && (
              <div className="absolute z-50 w-full mt-1 bg-white border border-gray-200 rounded-[8px] shadow-lg">
                <button
                  type="button"
                  onClick={() => handleSortChange('newest')}
                  className={`w-full px-4 py-3 text-left cursor-pointer hover:bg-[#F5F5F5] transition-colors duration-200 rounded-t-[8px] text-[18px] font-semibold ${sortOrder === 'newest' ? 'bg-[#F5F5F5] text-[#5046E5]' : 'text-[#282828]'
                    }`}
                >
                  Newest
                </button>
                <button
                  type="button"
                  onClick={() => handleSortChange('oldest')}
                  className={`w-full px-4 py-3 cursor-pointer text-left hover:bg-[#F5F5F5] transition-colors duration-200 rounded-b-[8px] text-[18px] font-semibold ${sortOrder === 'oldest' ? 'bg-[#F5F5F5] text-[#5046E5]' : 'text-[#282828]'
                    }`}
                >
                  Oldest
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Video Grid */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-7">
        {loading ? (
          <div className="col-span-full text-center py-12">
            <div className="text-center">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[#5046E5] mx-auto mb-4"></div>
              <p className="text-gray-500 text-lg">Loading your videos...</p>
            </div>
          </div>
        ) : displayVideos.length === 0 ? (
          <div className="col-span-full text-center py-12">
            <p className="text-gray-500 text-lg">
              {debouncedSearchQuery ? 'No videos found matching your search.' : 'No videos available.'}
            </p>
          </div>
        ) : (
          displayVideos.map((video) => (
            <div
              key={video.id}
              className="bg-[#EEEEEE] rounded-[12px] overflow-hidden transition-all duration-300 group min-h-[240px] relative h-[384px]"
            >
              
              {/* Video Player Container */}
              <div className="relative aspect-video max-h-[200px] w-full bg-[#EEEEEE] px-3 pt-3 rounded-[8px] group">
                {/* Video Player */}
                {video.status === 'ready' && video.downloadUrl ? (
                  <>
                    <video
                      src={video.downloadUrl}
                      className="w-full h-[200px] object-cover rounded-[6px]"
                      preload="metadata"
                      poster=""
                      muted
                      loop
                      playsInline
                      webkit-playsinline="true"
                      onError={(e) => {
                        console.error('Video load error:', e)
                        setLoadingVideos(prev => {
                          const newSet = new Set(prev)
                          newSet.delete(video.id)
                          return newSet
                        })
                      }}
                      onLoadStart={() => {
                        setLoadingVideos(prev => new Set(prev).add(video.id))
                      }}
                      onLoadedMetadata={(e) => {
                        const videoElement = e.currentTarget;
                        if (videoElement) {
                          videoElement.currentTime = 1;
                        }
                        setLoadingVideos(prev => {
                          const newSet = new Set(prev)
                          newSet.delete(video.id)
                          return newSet
                        })
                      }}
                    >
                      Your browser does not support the video tag.
                    </video>
                    {/* Shimmer overlay - shows while video thumbnail is loading */}
                    {loadingVideos.has(video.id) && (
                      <div className="absolute inset-0 bg-gradient-to-br from-gray-200 to-gray-300 rounded-[6px] overflow-hidden z-10">
                        <div 
                          className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent"
                          style={{
                            animation: 'shimmer 1.5s infinite'
                          }}
                        />
                      </div>
                    )}
                    {/* View Video Button Overlay - Only visible on hover */}
                    <div className="absolute inset-0 flex items-center justify-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 bg-grey100 bg-opacity-30 rounded-[6px]" style={{ zIndex: 0 }}>
                      <button
                        onClick={() => handleViewVideo(video)}
                        className="bg-[#5046E5] text-white px-6 py-3 rounded-full font-semibold text-[16px] hover:bg-[#4338CA]/80 transition-colors duration-300 flex items-center justify-center gap-2 shadow-lg"
                      >
                        View Video
                      </button>
                      <button
                        onClick={() => handleDeleteVideo(video)}
                        className="bg-[#FF0000] text-white px-6 py-3 rounded-full font-semibold text-[16px] hover:bg-[#FF0000]/80 transition-colors duration-300 flex items-center justify-center gap-2 shadow-lg"
                      >
                        Delete Video
                      </button>
                    </div>
                  </>
                ) : video.id.startsWith('loading-') ? (
                  /* Professional Loading Video Card with Advanced Skeleton */
                  <div className="w-full h-[200px] bg-gradient-to-br from-slate-50 to-gray-100 rounded-[6px] relative overflow-hidden border border-gray-200/50">
                    {/* Animated Background Pattern */}
                    <div className="absolute inset-0 opacity-30">
                      <div className="absolute inset-0 bg-gradient-to-r from-transparent via-blue-500/10 to-transparent animate-pulse"></div>
                      <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-br from-transparent via-purple-500/5 to-transparent"></div>
                    </div>

                    {/* Main Content Container */}
                    <div className="absolute inset-0 flex flex-col items-center justify-center p-6">

                      {/* Processing Text with Typing Animation */}
                      <div className="text-center mb-4">
                        <div>
                          <div className="text-sm font-semibold text-gray-700 mb-2">
                            <span className="inline-block animate-pulse">Processing</span>
                            <span className="inline-block animate-bounce ml-1">.</span>
                            <span className="inline-block animate-bounce ml-0.5" style={{ animationDelay: '0.1s' }}>.</span>
                            <span className="inline-block animate-bounce ml-0.5" style={{ animationDelay: '0.2s' }}>.</span>
                          </div>
                          <div className="text-xs text-gray-500">
                            It usually takes 10â€“15 minutes to generate a video.
                          </div>
                        </div>
                      </div>

                      {/* Spinner */}
                      <div className="flex justify-center items-center">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-[#5046E5]"></div>
                      </div>
                    </div>
                  </div>
                ) : (
                  <div className="w-full h-[200px] bg-gradient-to-br from-gray-200 to-gray-300 flex items-center justify-center rounded-[6px]">
                    <div className="text-center">
                      <div className="text-gray-400 text-sm mb-2">
                        {video.status === 'processing' ? 'Processing...' :
                          video.status === 'failed' ? 'Failed to load' :
                            video.status === 'ready' && !video.downloadUrl ? 'No download URL' : 'Video not ready'}
                      </div>
                      {video.status === 'processing' && (
                        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-[#5046E5] mx-auto"></div>
                      )}
                      {video.status === 'ready' && !video.downloadUrl && (
                        <div className="text-red-400 text-xs">Missing download URL</div>
                      )}
                    </div>
                  </div>
                )}
              </div>

              {/* Content */}
              <div className="p-4 flex flex-col justify-between h-[160px]">
                {/* Video Title */}
                {video.id.startsWith('loading-') ? (
                  /* Professional Skeleton Title */
                  <div className="my-3">
                    <div className="w-3/4 h-5 bg-gradient-to-r from-gray-200 to-gray-300 rounded-lg animate-pulse mb-2 shadow-sm"></div>
                    <div className="w-1/2 h-5 bg-gradient-to-r from-gray-200 to-gray-300 rounded-lg animate-pulse shadow-sm"></div>
                  </div>
                ) : (
                  /* Regular Title */
                  <div className="my-3">
                    <h3 className="text-[18px] font-medium text-[#171717] line-clamp-1">
                      {video.title}
                    </h3>
                    {/* Note Display */}
                    {videoNotes[video.videoId || video.id] ? (
                      <div className="mt-2 p-2 min-h-[60px] bg-white border border-blue-100 hover:border-blue-200 rounded-[6px] relative transition-all duration-300">
                        <div className="flex items-start gap-1 relative z-10 pr-[24px]">
                          <p className="text-sm text-[#5F5F5F] line-clamp-2 flex-1">
                           <span className="font-medium text-[#5F5F5F]">Note:</span> {videoNotes[video.videoId || video.id]}
                          </p>
                        </div>
                        {!video.id.startsWith('loading-') && (
                          <button
                            onClick={(e) => {
                              e.stopPropagation()
                              handleOpenNoteModal(video)
                            }}
                            className="absolute top-2 right-2 z-10 transition-all duration-200 flex items-center justify-center group/note"
                            title={videoNotes[video.videoId || video.id] ? 'Edit note' : 'Add note'}
                          >
                            <PencilLine 
                              className={`w-5 h-5 transition-colors duration-200 ${
                                videoNotes[video.videoId || video.id] 
                                  ? 'text-[#5F5F5F] hover:text-[#5046E5] ' 
                                  : 'text-[#5F5F5F] group-hover/note:text-[#5046E5]'
                              }`} 
                            />
                          </button>
                        )}
                      </div>
                    ) : (
                      <div className="mt-2 p-2 min-h-[60px] bg-white border border-blue-50 hover:border-blue-200 rounded-[6px] relative transition-all duration-300">
                        <div className="flex items-start gap-1">
                          <p className="text-sm font-normal text-[#9C9B9B]">Add a note</p>
                          {!video.id.startsWith('loading-') && (
                            <button
                              onClick={(e) => {
                                e.stopPropagation()
                                handleOpenNoteModal(video)
                              }}
                              className="absolute top-2 right-2 z-10 transition-all duration-200 flex items-center justify-center group/note"
                              title={videoNotes[video.videoId || video.id] ? 'Edit note' : 'Add note'}
                            >
                              <PencilLine 
                                className={`w-5 h-5 transition-colors duration-200 ${
                                  videoNotes[video.videoId || video.id] 
                                    ? 'text-[#5046E5] ' 
                                    : 'text-[#5F5F5F] hover:text-[#5046E5]'
                                }`} 
                              />
                            </button>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                )}
                {/* Buttons Container */}
                {video.id.startsWith('loading-') ? (
                  /* Professional Skeleton Buttons */
                  <div className="flex gap-2">
                    <div className="flex-1 py-[3px] px-4 rounded-full">
                      <div className="w-full h-8 bg-gradient-to-r from-gray-200 to-gray-300 rounded-full animate-pulse shadow-sm border border-gray-200/50"></div>
                    </div>
                    <div className="flex-1 py-[3px] px-4 rounded-full">
                      <div className="w-full h-8 bg-gradient-to-r from-gray-200 to-gray-300 rounded-full animate-pulse shadow-sm border border-gray-200/50"></div>
                    </div>
                  </div>
                ) : (
                  /* Regular Buttons - Two buttons in a row */
                  <div className="flex gap-2">
                    {!video.autoGenerated && (
                      <button
                        onClick={() => handlePostVideo(video)}
                        disabled={video.status !== 'ready'}
                        className={`flex-1 py-[3px] px-4 rounded-full font-semibold text-[16px] transition-colors duration-300 flex items-center justify-center gap-2 group/btn cursor-pointer ${video.status === 'ready'
                          ? 'bg-[#5046E5] text-white hover:bg-transparent hover:text-[#5046E5] border-2 border-[#5046E5]'
                          : 'bg-gray-300 text-gray-500 cursor-not-allowed border-2 border-gray-300'
                          }`}
                      >
                        Post Video
                      </button>
                    )}
                  </div>
                )}
              </div>
            </div>
          ))
        )}
      </div>

      {/* Pagination Controls */}
      {totalPages > 1 && (
        <div className="flex items-center justify-center gap-4 mt-8">
          <button
            onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
            disabled={currentPage === 1 || loading}
            className="px-4 py-2 bg-[#5046E5] text-white rounded-[39px] transition-all duration-300 focus:outline-none focus:ring focus:ring-[#5046E5] disabled:opacity-50 disabled:cursor-not-allowed hover:bg-[#4338CA] text-[16px] font-semibold"
          >
            Previous
          </button>
          
          <div className="flex items-center gap-2">
            <span className="text-[#5F5F5F] text-[16px] font-semibold">
              Page {currentPage} of {totalPages}
            </span>
            {totalCount > 0 && (
              <span className="text-[#9C9B9B] text-[14px]">
                ({totalCount} {totalCount === 1 ? 'video' : 'videos'})
              </span>
            )}
          </div>
          
          <button
            onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
            disabled={currentPage === totalPages || loading}
            className="px-4 py-2 bg-[#5046E5] text-white rounded-[39px] transition-all duration-300 focus:outline-none focus:ring focus:ring-[#5046E5] disabled:opacity-50 disabled:cursor-not-allowed hover:bg-[#4338CA] text-[16px] font-semibold"
          >
            Next
          </button>
        </div>
      )}

      {/* Click outside to close dropdown */}
      {isSortDropdownOpen && (
        <div
          className="fixed inset-0 z-40"
          onClick={() => setIsSortDropdownOpen(false)}
        />
      )}

      {/* Create Video Modal */}
      <CreateVideoModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        videoTitle={selectedVideoForCreation}
        startAtComplete={true}
        videoData={selectedVideoData}
      />

      {/* Connect Accounts Modal */}
      <ConnectAccountsModal
        isOpen={isConnectAccountsModalOpen}
        onClose={() => setIsConnectAccountsModalOpen(false)}
        onNext={() => {
          setIsConnectAccountsModalOpen(false)
          // Handle the next step after connecting accounts
          console.log('Accounts connected, proceeding to next step')
        }}
        video={selectedVideoData ? {
          id: selectedVideoData.title,
          title: selectedVideoData.title,
          status: 'ready',
          url: selectedVideoData.youtubeUrl,
          thumbnail: selectedVideoData.thumbnail,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        } : undefined}
        onCreatePost={handleCreatePost}
      />

      {/* Create Post Modal */}
      {selectedVideoData && (
        <CreatePostModal
          isOpen={isCreatePostModalOpen}
          onClose={() => setIsCreatePostModalOpen(false)}
          onPost={handlePostSubmit}
          selectedAccounts={selectedAccountsForPost}
          video={{
            id: selectedVideoData.title,
            title: selectedVideoData.title,
            status: 'ready',
            videoUrl: selectedVideoData.videoUrl,
            url: selectedVideoData.youtubeUrl,
            thumbnail: selectedVideoData.thumbnail,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            socialMediaCaptions: selectedVideoData.socialMediaCaptions,
          }}
        />
      )}

      <DeleteVideoConfirmationModal
        isOpen={isDeleteVideoModalOpen}
        onClose={handleCancelDelete}
        onConfirm={handleConfirmDelete}
        videoTitle={videoToDelete?.title}
        isDeleting={isDeleting}
      />

      {/* Note Modal */}
      {isNoteModalOpen && selectedVideoForNote && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[100] p-4">
          <div className="bg-white rounded-xl max-w-md w-full shadow-xl">
            <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200">
              <h2 className="text-xl font-semibold text-black">
                {videoNotes[selectedVideoForNote.videoId || selectedVideoForNote.id] ? 'Edit Note' : 'Add Note'}
              </h2>
              <button
                type="button"
                onClick={handleCancelNote}
                className="w-8 h-8 flex items-center justify-center hover:bg-gray-100 rounded-full transition-colors duration-200"
              >
                <X className="w-5 h-5 text-black" />
              </button>
            </div>
            
            <div className="p-6 space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Note for: <span className="text-gray-500 font-normal">{selectedVideoForNote.title}</span>
                </label>
                <textarea
                  value={currentNoteText}
                  onChange={(e) => handleNoteTextChange(e.target.value)}
                  required={true}
                  placeholder="Enter your note here..."
                  className={`w-full h-32 px-4 py-3 bg-[#EEEEEE] border-0 rounded-[8px] text-gray-800 placeholder-[#11101066] resize-none focus:outline-none focus:ring-2 focus:ring-[#5046E5] focus:bg-white transition-colors duration-200 ${noteError ? 'ring-2 ring-red-500' : ''}`}
                  autoFocus
                />
                {noteError && (
                  <p className="text-red-500 text-sm mt-1 flex items-center gap-1">
                    <AlertCircle className="w-4 h-4" />
                    {noteError}
                  </p>
                )}
              </div>

              <div className="flex gap-3 justify-end">
                <button
                  type="button"
                  onClick={handleCancelNote}
                  className="px-6 py-2 rounded-full font-semibold text-[16px] border-2 border-gray-300 hover:border-gray-700 text-gray-700 hover:bg-gray-700 hover:text-white transition-colors duration-200"
                >
                  Cancel
                </button>
                <button
                  type="button"
                  onClick={handleSaveNote}
                  disabled={!!noteError || !currentNoteText.trim() || currentNoteText.trim().split(/\s+/).filter(word => word.length > 0).length === 0}
                  className={`px-6 py-2 rounded-full font-semibold text-[16px] border-2 border-[#5046E5] transition-colors duration-200 ${
                    noteError || !currentNoteText.trim() || currentNoteText.trim().split(/\s+/).filter(word => word.length > 0).length === 0
                      ? 'opacity-50 cursor-not-allowed bg-[#5046E5] text-white'
                      : 'bg-[#5046E5] text-white hover:bg-transparent hover:text-[#5046E5]'
                  }`}
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}